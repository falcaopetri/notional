{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"notional Notional is loosely modeled after concepts found in SQLAlchemy and MongoEngine . This module is built on the notion-sdk-py library, providing higher-level access to the API. Developer Guides Getting Started Querying the API Content Iterators Document Parsing Object-Relational Mapping Getting Help If you are stuck, the best place to start is the Discussion area. Use this also as a resource for asking questions or providing suggestions. Known Issues See Issues on github. Feature Requests See Issues on github. Contributing Read the contributing guide .","title":"Home"},{"location":"#notional","text":"Notional is loosely modeled after concepts found in SQLAlchemy and MongoEngine . This module is built on the notion-sdk-py library, providing higher-level access to the API.","title":"notional"},{"location":"#developer-guides","text":"Getting Started Querying the API Content Iterators Document Parsing Object-Relational Mapping","title":"Developer Guides"},{"location":"#getting-help","text":"If you are stuck, the best place to start is the Discussion area. Use this also as a resource for asking questions or providing suggestions.","title":"Getting Help"},{"location":"#known-issues","text":"See Issues on github.","title":"Known Issues"},{"location":"#feature-requests","text":"See Issues on github.","title":"Feature Requests"},{"location":"#contributing","text":"Read the contributing guide .","title":"Contributing"},{"location":"contributing/","text":"Contributing Quick Start Fork the notional repository into your account and clone a local working copy. Create a new feature branch for your changes. Set up a local environment. Create a virtual environment: python3 -m venv .venv source .venv/bin/activate Install dependencies: pip3 install -r requirements/core.txt pip3 install -r requirements/dev.txt Install pre-commit hooks: pre-commit install Alternatively, use make devenv to set this all up for you. Follow the standards enforced by the tools. At any time, you may use the preflight target to run the unit tests and code checks. Provide tests for new code and ensure they are passing. Submit a pull request with your changes. Pull Requests Pull requests are highly encouraged! Please make sure the PR passes pre-commit prior to submission. Coding Standards Notional uses standard Python coding practices. Style All code must be formatted using black . Additionally, all import statements will be sorted according to isort . Static Analysis Code will be scanned using flake8 . Unit Tests Where practical, stand-alone unit tests ae strongly encouraged. In the future, code coverage may be enforced for new commits. If it is not practical to develop a unit test, evidence of working code must be provided in the pull request. Submitting Issues & Requests Please review the open issues and feature requests. This is a great place to start if you are looking for ways to contribute! Known Issues See Issues on github. Feature Requests See Issues on github.","title":"Contributing"},{"location":"contributing/#contributing","text":"","title":"Contributing"},{"location":"contributing/#quick-start","text":"Fork the notional repository into your account and clone a local working copy. Create a new feature branch for your changes. Set up a local environment. Create a virtual environment: python3 -m venv .venv source .venv/bin/activate Install dependencies: pip3 install -r requirements/core.txt pip3 install -r requirements/dev.txt Install pre-commit hooks: pre-commit install Alternatively, use make devenv to set this all up for you. Follow the standards enforced by the tools. At any time, you may use the preflight target to run the unit tests and code checks. Provide tests for new code and ensure they are passing. Submit a pull request with your changes.","title":"Quick Start"},{"location":"contributing/#pull-requests","text":"Pull requests are highly encouraged! Please make sure the PR passes pre-commit prior to submission.","title":"Pull Requests"},{"location":"contributing/#coding-standards","text":"Notional uses standard Python coding practices.","title":"Coding Standards"},{"location":"contributing/#style","text":"All code must be formatted using black . Additionally, all import statements will be sorted according to isort .","title":"Style"},{"location":"contributing/#static-analysis","text":"Code will be scanned using flake8 .","title":"Static Analysis"},{"location":"contributing/#unit-tests","text":"Where practical, stand-alone unit tests ae strongly encouraged. In the future, code coverage may be enforced for new commits. If it is not practical to develop a unit test, evidence of working code must be provided in the pull request.","title":"Unit Tests"},{"location":"contributing/#submitting-issues-requests","text":"Please review the open issues and feature requests. This is a great place to start if you are looking for ways to contribute!","title":"Submitting Issues &amp; Requests"},{"location":"contributing/#known-issues","text":"See Issues on github.","title":"Known Issues"},{"location":"contributing/#feature-requests","text":"See Issues on github.","title":"Feature Requests"},{"location":"iterators/","text":"Iterators The iterators provide convenient access to the Notion endpoints. Rather than looking for each page of data, the iterators take care of this and expose a standard Python iterator: import notional from notional.iterator import EndpointIterator notion = notional . connect ( auth = AUTH_TOKEN ) tasks = EndpointIterator ( endpoint = notion . databases () . query , database_id = task_db_id , sorts = [ { 'direction' : 'ascending' , 'property' : 'Last Update' } ] ) for data in tasks : # do the things Note that the parameters to the iterator follow the standard API parameters for the given endpoint.","title":"Iterators"},{"location":"iterators/#iterators","text":"The iterators provide convenient access to the Notion endpoints. Rather than looking for each page of data, the iterators take care of this and expose a standard Python iterator: import notional from notional.iterator import EndpointIterator notion = notional . connect ( auth = AUTH_TOKEN ) tasks = EndpointIterator ( endpoint = notion . databases () . query , database_id = task_db_id , sorts = [ { 'direction' : 'ascending' , 'property' : 'Last Update' } ] ) for data in tasks : # do the things Note that the parameters to the iterator follow the standard API parameters for the given endpoint.","title":"Iterators"},{"location":"license/","text":"MIT License Copyright (c) 2021 Jason Heddings Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"orm/","text":"Object-Relational Mapping This library has support for defining custom data types that wrap Notion pages. Typically, these pages are entries in a database (collection) with a consistent schema. Custom Types Custom types must exted the ConnectedPage object. To do so, first initalize a session and generate the page object: auth_token = os . getenv ( \"NOTION_AUTH_TOKEN\" ) notion = notional . connect ( auth = auth_token ) CustomPage = connected_page ( session = notion ) Data Objects Users may define custom types that map to entries in a Notion database. To accomplish this, delcare a class and its members using Notional types: class Task ( CustomPage , database = NOTION_DATABASE_ID ): Title = Property ( 'Title' , schema . Title ()) Priority = Property ( 'Priority' , schema . SelectOne ()) DueDate = Property ( 'Due Date' , schema . Date ()) Alternatively, you may set the database ID as a private member of the custom type: class Task ( CustomPage ): __database__ = NOTION_DATABSE_ID In the examples, NOTION_DATABASE_ID is defined as a string or UUID of a database visible to the current integration. Review the schema reference for all available types. Querying Connected pages expose a query() method, which returns a custom QueryBuilder for iterating over user-defined types: for task in Task . query () . execute (): print ( f \" { task . Title } => { task . Priority } \" ) task . DueDate = date . today () See the examples for more information and additional usage.","title":"Custom Types"},{"location":"orm/#object-relational-mapping","text":"This library has support for defining custom data types that wrap Notion pages. Typically, these pages are entries in a database (collection) with a consistent schema.","title":"Object-Relational Mapping"},{"location":"orm/#custom-types","text":"Custom types must exted the ConnectedPage object. To do so, first initalize a session and generate the page object: auth_token = os . getenv ( \"NOTION_AUTH_TOKEN\" ) notion = notional . connect ( auth = auth_token ) CustomPage = connected_page ( session = notion )","title":"Custom Types"},{"location":"orm/#data-objects","text":"Users may define custom types that map to entries in a Notion database. To accomplish this, delcare a class and its members using Notional types: class Task ( CustomPage , database = NOTION_DATABASE_ID ): Title = Property ( 'Title' , schema . Title ()) Priority = Property ( 'Priority' , schema . SelectOne ()) DueDate = Property ( 'Due Date' , schema . Date ()) Alternatively, you may set the database ID as a private member of the custom type: class Task ( CustomPage ): __database__ = NOTION_DATABSE_ID In the examples, NOTION_DATABASE_ID is defined as a string or UUID of a database visible to the current integration. Review the schema reference for all available types.","title":"Data Objects"},{"location":"orm/#querying","text":"Connected pages expose a query() method, which returns a custom QueryBuilder for iterating over user-defined types: for task in Task . query () . execute (): print ( f \" { task . Title } => { task . Priority } \" ) task . DueDate = date . today () See the examples for more information and additional usage.","title":"Querying"},{"location":"parser/","text":"Parsers Notional includes several parsers for importing exernal content. They will accept either string (data) or file-like objects to provide the input content. HTML Parser The HTML parser read an HTML document into Notion API objects. From there, the caller may create a page in Notion using the rendered content. from notional.parser import HtmlParser parser = HtmlParser ( base = \"https://www.example.com/\" ) with open ( filename , \"r\" ) as fp : parser . parse ( fp ) doc = notion . pages . create ( parent = parent_page , title = parser . title , children = parser . content , ) Note: while the parser aims to be general purpose, there may be conditions where it cannot interpret the HTML document. Please submit an issue if you find an example of valid HTML that is not properly converted. After parsing, the HtmlParser will contain title , meta , and content . HtmlParser.title If the parser encounters a <title> element, this property will be set to the contents. Otherwise, the parser will attempt to look for a name in the input data stream. Typically, this would be the filename if the data is a file-like object. If no <title> or name exists, this property will be None . HtmlParser.meta The meta property is a dict containing data from <meta> tags in the input. This property is a dict where each element has the form meta_name: meta_value . HtmlParser.content Content is rendered into a list of blocks, ready to be created or appended to a page. CSV Parser The CSV parser will read comma-separate value content and generate the appropriate database along with content. In order to populate the database, the contents must be created as individual pages. from notional.parser import CsvParser parser = CsvParser ( header_row = True ) with open ( filename , \"r\" ) as fp : parser . parse ( fp ) doc = notion . databases . create ( parent = parent_page , title = parser . title , schema = parser . schema , ) for props in parser . content : page = notion . pages . create ( parent = db , properties = props , ) The CsvParser accepts the follow configuration options when initialized: header_row - indicates that the input data has a header row, which will be used to generate the schema (defaults to True ) title_column - indicates which column number to use as the title for entries (defaults to 0 ) After parsing, the CsvParser will contain title , schema , and content . CsvParser.title The parser will attempt to read a name property from the input data source. As seen in the above example, this is a useful pproperty when creating the database. If there is no name available, this property will be None . CsvParser.schema The parser will generate a schema for the CSV data, which is used when creating the database. The schema is presented as a dict where each element is the form field_name: field_type and can be passed to the databases.create() method. CsvParser.content CSV data is created as a list of page properties in the database. The content must be created as separate pages with the new database parent. Specifically, the content property is a list where each element is a dict of the form field_name: field_value . These elements are a full set of properties for creating a new page.","title":"Parsers"},{"location":"parser/#parsers","text":"Notional includes several parsers for importing exernal content. They will accept either string (data) or file-like objects to provide the input content.","title":"Parsers"},{"location":"parser/#html-parser","text":"The HTML parser read an HTML document into Notion API objects. From there, the caller may create a page in Notion using the rendered content. from notional.parser import HtmlParser parser = HtmlParser ( base = \"https://www.example.com/\" ) with open ( filename , \"r\" ) as fp : parser . parse ( fp ) doc = notion . pages . create ( parent = parent_page , title = parser . title , children = parser . content , ) Note: while the parser aims to be general purpose, there may be conditions where it cannot interpret the HTML document. Please submit an issue if you find an example of valid HTML that is not properly converted. After parsing, the HtmlParser will contain title , meta , and content .","title":"HTML Parser"},{"location":"parser/#htmlparsertitle","text":"If the parser encounters a <title> element, this property will be set to the contents. Otherwise, the parser will attempt to look for a name in the input data stream. Typically, this would be the filename if the data is a file-like object. If no <title> or name exists, this property will be None .","title":"HtmlParser.title"},{"location":"parser/#htmlparsermeta","text":"The meta property is a dict containing data from <meta> tags in the input. This property is a dict where each element has the form meta_name: meta_value .","title":"HtmlParser.meta"},{"location":"parser/#htmlparsercontent","text":"Content is rendered into a list of blocks, ready to be created or appended to a page.","title":"HtmlParser.content"},{"location":"parser/#csv-parser","text":"The CSV parser will read comma-separate value content and generate the appropriate database along with content. In order to populate the database, the contents must be created as individual pages. from notional.parser import CsvParser parser = CsvParser ( header_row = True ) with open ( filename , \"r\" ) as fp : parser . parse ( fp ) doc = notion . databases . create ( parent = parent_page , title = parser . title , schema = parser . schema , ) for props in parser . content : page = notion . pages . create ( parent = db , properties = props , ) The CsvParser accepts the follow configuration options when initialized: header_row - indicates that the input data has a header row, which will be used to generate the schema (defaults to True ) title_column - indicates which column number to use as the title for entries (defaults to 0 ) After parsing, the CsvParser will contain title , schema , and content .","title":"CSV Parser"},{"location":"parser/#csvparsertitle","text":"The parser will attempt to read a name property from the input data source. As seen in the above example, this is a useful pproperty when creating the database. If there is no name available, this property will be None .","title":"CsvParser.title"},{"location":"parser/#csvparserschema","text":"The parser will generate a schema for the CSV data, which is used when creating the database. The schema is presented as a dict where each element is the form field_name: field_type and can be passed to the databases.create() method.","title":"CsvParser.schema"},{"location":"parser/#csvparsercontent","text":"CSV data is created as a list of page properties in the database. The content must be created as separate pages with the new database parent. Specifically, the content property is a list where each element is a dict of the form field_name: field_value . These elements are a full set of properties for creating a new page.","title":"CsvParser.content"},{"location":"query/","text":"Query Builder Notional provides a query builder for interacting with the Notion API. Query targets can be either a specific database ID or a custom ORM type. Filters Filters can be added for either timestamps or properties using the query builder. They operate using a set of constraints, depending on the object being filtered. Constraints may be appended to the query builder using keywords or by creating them directly: notion = notional . connect ( auth = auth_token ) query = ( notion . databases . query ( dbid ) . filter ( property = \"Title\" , text = TextConstraint ( contains = \"project\" )) . filter ( LastEditedTimeFilter . create ( DateConstraint ( past_week = {}))) . limit ( 1 ) ) data = query . first () # process query result Sorting Sorts can be added to the query using the sort() method: notion = notional . connect ( auth = auth_token ) query = notion . databases . query ( dbid ) . sort ( property = \"Title\" , direction = SortDirection . ascending ) for data in query . execute (): # something magic happens For more information about querying, read the official API documentation .","title":"Querying"},{"location":"query/#query-builder","text":"Notional provides a query builder for interacting with the Notion API. Query targets can be either a specific database ID or a custom ORM type.","title":"Query Builder"},{"location":"query/#filters","text":"Filters can be added for either timestamps or properties using the query builder. They operate using a set of constraints, depending on the object being filtered. Constraints may be appended to the query builder using keywords or by creating them directly: notion = notional . connect ( auth = auth_token ) query = ( notion . databases . query ( dbid ) . filter ( property = \"Title\" , text = TextConstraint ( contains = \"project\" )) . filter ( LastEditedTimeFilter . create ( DateConstraint ( past_week = {}))) . limit ( 1 ) ) data = query . first () # process query result","title":"Filters"},{"location":"query/#sorting","text":"Sorts can be added to the query using the sort() method: notion = notional . connect ( auth = auth_token ) query = notion . databases . query ( dbid ) . sort ( property = \"Title\" , direction = SortDirection . ascending ) for data in query . execute (): # something magic happens For more information about querying, read the official API documentation .","title":"Sorting"},{"location":"start/","text":"Quick Start Using Notional requires an understanding of concepts described in the Notion API . In particular, it is important to understand authorization and the data model. Authorization Obtain an authentication token from your Notion account. Token Security It is generally a best practice to read the auth token from an environment variable or a secrets file. To prevent accidental exposure, it is NOT recommended to save the token in source. Installation Install the most recent release using PyPI: pip install notional Note: it is recommended to use a virtual environment ( venv ) for installing libraries to prevent conflicting dependency versions. Connect Connect to the API using an integration token or an OAuth access token: import notional notion = notional . connect ( auth = AUTH_TOKEN ) Data Objects The majority of the Notion API expresses capabilities through data objects that follow a specific pattern. It is good to be familiar with the Notion API representation of these objects, as it will help understand concepts found in Notional. Many common uses of data objects require interacting with the internal data. Notional provides two helper methods for working with this strucure: compose and call. Constructing Constructing a data object requires manually setting up the internal data structures. Consider the following example: text = \"It was a dark and stormy night...\" nested = TextObject . NestedData ( content = text ) rtf = text . TextObject ( text = nested , plain_text = text ) content = blocks . Paragraph . NestedData ( text = [ rtf ]) para = blocks . Paragraph ( paragraph = content ) Notice how we build the NestedData object in order to construct the final Paragraph . This approach provides the most versatility when building complex objects. Technical note: since Notional uses pydantic for object serialization under the hood, the constructor for each object is generated based on the object properties. Composing Composing a data object provides the caller a shorthand to construction. Rather than explicitly laying out the nested data, the __compose__ method takes care of setting up the internal data structure. Consider our example from above. Using the composable feature of a Paragraph block changes the code like so: para = blocks . Paragraph [ \"It was a dark and stormy night...\" ] Note the use of [ ] in the composition example... This instructs the Paragraph to compose itself from the given parameters. The acceptable parameters for this method is specific to the object being composed. Technical note: since the constructor is provided by pydantic , we do not override it. Instead, we have chosen to provide an alternate form of creating objects. We refer to this form as \"composing\" from basic types. Calling Calling a data object provides access to the underlying data strcuture, which typically contains the content of the object. For example, to get the \"checked\" state of a ToDo block, we can use either the nested data structure directly or call the block: todo = blocks . ToDo ( ... ) # direct access checked = todo . to_do . checked # nested data access checked = todo () . checked # nested property access checked = todo ( \"checked\" ) In the above example, all three approaches for getting the checked field of our ToDo block produce the same result.","title":"Getting Started"},{"location":"start/#quick-start","text":"Using Notional requires an understanding of concepts described in the Notion API . In particular, it is important to understand authorization and the data model.","title":"Quick Start"},{"location":"start/#authorization","text":"Obtain an authentication token from your Notion account.","title":"Authorization"},{"location":"start/#token-security","text":"It is generally a best practice to read the auth token from an environment variable or a secrets file. To prevent accidental exposure, it is NOT recommended to save the token in source.","title":"Token Security"},{"location":"start/#installation","text":"Install the most recent release using PyPI: pip install notional Note: it is recommended to use a virtual environment ( venv ) for installing libraries to prevent conflicting dependency versions.","title":"Installation"},{"location":"start/#connect","text":"Connect to the API using an integration token or an OAuth access token: import notional notion = notional . connect ( auth = AUTH_TOKEN )","title":"Connect"},{"location":"start/#data-objects","text":"The majority of the Notion API expresses capabilities through data objects that follow a specific pattern. It is good to be familiar with the Notion API representation of these objects, as it will help understand concepts found in Notional. Many common uses of data objects require interacting with the internal data. Notional provides two helper methods for working with this strucure: compose and call.","title":"Data Objects"},{"location":"start/#constructing","text":"Constructing a data object requires manually setting up the internal data structures. Consider the following example: text = \"It was a dark and stormy night...\" nested = TextObject . NestedData ( content = text ) rtf = text . TextObject ( text = nested , plain_text = text ) content = blocks . Paragraph . NestedData ( text = [ rtf ]) para = blocks . Paragraph ( paragraph = content ) Notice how we build the NestedData object in order to construct the final Paragraph . This approach provides the most versatility when building complex objects. Technical note: since Notional uses pydantic for object serialization under the hood, the constructor for each object is generated based on the object properties.","title":"Constructing"},{"location":"start/#composing","text":"Composing a data object provides the caller a shorthand to construction. Rather than explicitly laying out the nested data, the __compose__ method takes care of setting up the internal data structure. Consider our example from above. Using the composable feature of a Paragraph block changes the code like so: para = blocks . Paragraph [ \"It was a dark and stormy night...\" ] Note the use of [ ] in the composition example... This instructs the Paragraph to compose itself from the given parameters. The acceptable parameters for this method is specific to the object being composed. Technical note: since the constructor is provided by pydantic , we do not override it. Instead, we have chosen to provide an alternate form of creating objects. We refer to this form as \"composing\" from basic types.","title":"Composing"},{"location":"start/#calling","text":"Calling a data object provides access to the underlying data strcuture, which typically contains the content of the object. For example, to get the \"checked\" state of a ToDo block, we can use either the nested data structure directly or call the block: todo = blocks . ToDo ( ... ) # direct access checked = todo . to_do . checked # nested data access checked = todo () . checked # nested property access checked = todo ( \"checked\" ) In the above example, all three approaches for getting the checked field of our ToDo block produce the same result.","title":"Calling"},{"location":"reference/","text":"Provide a simple ORM for Notion objects. connect ( ** kwargs ) Connect to Notion using the provided integration token. Source code in notional/__init__.py def connect ( ** kwargs ): \"\"\"Connect to Notion using the provided integration token.\"\"\" log . debug ( \"connecting to Notion...\" ) return Session ( ** kwargs ) __main__ special Main entry point for notional. At the moment, this simply prints the current version and exits. blocks Wrapper for Notion API blocks. Blocks are specifc records that hold content. Similar to other records, these object provide access to the primitive data structure used in the Notion API as well as higher-level methods. Block ( Record , TypedObject ) pydantic-model A standard block object in Notion. Calling the block will expose the nested data in the object. Source code in notional/blocks.py class Block ( Record , TypedObject , object = \"block\" ): \"\"\"A standard block object in Notion. Calling the block will expose the nested data in the object. \"\"\" Bookmark ( Block ) pydantic-model A bookmark block in Notion. Source code in notional/blocks.py class Bookmark ( Block , type = \"bookmark\" ): \"\"\"A bookmark block in Notion.\"\"\" class _NestedData ( NestedObject ): url : str = None caption : Optional [ List [ RichTextObject ]] = None bookmark : _NestedData = _NestedData () @classmethod def __compose__ ( cls , url ): \"\"\"Compoase a new `Bookmark` block from a specific URL.\"\"\" return Bookmark ( bookmark = Bookmark . _NestedData ( url = url )) @property def URL ( self ): \"\"\"Return the URL contained in this `Bookmark` block.\"\"\" return self . bookmark . url @property def Markdown ( self ): \"\"\"Return the contents of this block as markdown text.\"\"\" if self . bookmark and self . bookmark . url : return f \"< { self . bookmark . url } >\" return \"\" Markdown property readonly Return the contents of this block as markdown text. URL property readonly Return the URL contained in this Bookmark block. __compose__ ( url ) classmethod special Compoase a new Bookmark block from a specific URL. Source code in notional/blocks.py @classmethod def __compose__ ( cls , url ): \"\"\"Compoase a new `Bookmark` block from a specific URL.\"\"\" return Bookmark ( bookmark = Bookmark . _NestedData ( url = url )) Breadcrumb ( Block ) pydantic-model A breadcrumb block in Notion. Source code in notional/blocks.py class Breadcrumb ( Block , type = \"breadcrumb\" ): \"\"\"A breadcrumb block in Notion.\"\"\" class _NestedData ( NestedObject ): pass breadcrumb : _NestedData = _NestedData () BulletedListItem ( TextBlock , WithChildrenMixin ) pydantic-model A bulleted list item in Notion. Source code in notional/blocks.py class BulletedListItem ( TextBlock , WithChildrenMixin , type = \"bulleted_list_item\" ): \"\"\"A bulleted list item in Notion.\"\"\" class _NestedData ( NestedObject ): rich_text : List [ RichTextObject ] = [] children : Optional [ List [ Block ]] = None color : FullColor = FullColor . DEFAULT bulleted_list_item : _NestedData = _NestedData () @property def Markdown ( self ): \"\"\"Return the contents of this block as markdown text.\"\"\" if self . bulleted_list_item and self . bulleted_list_item . rich_text : return f \"- { markdown ( * self . bulleted_list_item . rich_text ) } \" return \"\" Markdown property readonly Return the contents of this block as markdown text. Callout ( TextBlock , WithChildrenMixin ) pydantic-model A callout block in Notion. Source code in notional/blocks.py class Callout ( TextBlock , WithChildrenMixin , type = \"callout\" ): \"\"\"A callout block in Notion.\"\"\" class _NestedData ( NestedObject ): rich_text : List [ RichTextObject ] = [] children : Optional [ List [ Block ]] = None icon : Optional [ Union [ FileObject , EmojiObject ]] = None color : FullColor = FullColor . DEFAULT callout : _NestedData = _NestedData () ChildDatabase ( Block ) pydantic-model A child database block in Notion. Source code in notional/blocks.py class ChildDatabase ( Block , type = \"child_database\" ): \"\"\"A child database block in Notion.\"\"\" class _NestedData ( NestedObject ): title : str = None child_database : _NestedData = _NestedData () ChildPage ( Block ) pydantic-model A child page block in Notion. Source code in notional/blocks.py class ChildPage ( Block , type = \"child_page\" ): \"\"\"A child page block in Notion.\"\"\" class _NestedData ( NestedObject ): title : str = None child_page : _NestedData = _NestedData () Code ( TextBlock ) pydantic-model A code block in Notion. Source code in notional/blocks.py class Code ( TextBlock , type = \"code\" ): \"\"\"A code block in Notion.\"\"\" class _NestedData ( NestedObject ): rich_text : List [ RichTextObject ] = [] caption : List [ RichTextObject ] = [] language : CodingLanguage = CodingLanguage . PLAIN_TEXT code : _NestedData = _NestedData () @classmethod def __compose__ ( cls , text , lang = CodingLanguage . PLAIN_TEXT ): \"\"\"Compose a `Code` block from the given text and language.\"\"\" return Code ( code = Code . _NestedData ( rich_text = [ TextObject [ text ]], language = lang , ) ) @property def Markdown ( self ): \"\"\"Return the contents of this block as markdown text.\"\"\" lang = self . code . language if self . code and self . code . language else \"\" # FIXME this is not the standard way to represent code blocks in markdown... if self . code and self . code . rich_text : return f \"``` { lang } \\n { markdown ( * self . code . rich_text ) } \\n ```\" return \"\" Markdown property readonly Return the contents of this block as markdown text. __compose__ ( text , lang =< CodingLanguage . PLAIN_TEXT : 'plain text' > ) classmethod special Compose a Code block from the given text and language. Source code in notional/blocks.py @classmethod def __compose__ ( cls , text , lang = CodingLanguage . PLAIN_TEXT ): \"\"\"Compose a `Code` block from the given text and language.\"\"\" return Code ( code = Code . _NestedData ( rich_text = [ TextObject [ text ]], language = lang , ) ) Column ( Block ) pydantic-model A column block in Notion. Source code in notional/blocks.py class Column ( Block , type = \"column\" ): \"\"\"A column block in Notion.\"\"\" class _NestedData ( NestedObject ): pass column : _NestedData = _NestedData () ColumnList ( Block ) pydantic-model A column list block in Notion. Source code in notional/blocks.py class ColumnList ( Block , type = \"column_list\" ): \"\"\"A column list block in Notion.\"\"\" class _NestedData ( NestedObject ): pass column_list : _NestedData = _NestedData () Divider ( Block ) pydantic-model A divider block in Notion. Source code in notional/blocks.py class Divider ( Block , type = \"divider\" ): \"\"\"A divider block in Notion.\"\"\" divider : Any = {} @property def Markdown ( self ): \"\"\"Return the contents of this block as markdown text.\"\"\" return \"---\" Markdown property readonly Return the contents of this block as markdown text. Embed ( Block ) pydantic-model An embed block in Notion. Source code in notional/blocks.py class Embed ( Block , type = \"embed\" ): \"\"\"An embed block in Notion.\"\"\" class _NestedData ( NestedObject ): url : str = None embed : _NestedData = _NestedData () @classmethod def __compose__ ( cls , url ): \"\"\"Create a new `Embed` block from the given URL.\"\"\" return Embed ( embed = Embed . _NestedData ( url = url )) @property def URL ( self ): \"\"\"Return the URL contained in this `Embed` block.\"\"\" return self . embed . url @property def Markdown ( self ): \"\"\"Return the contents of this block as markdown text.\"\"\" if self . embed and self . embed . url : return f \"< { self . embed . url } >\" return \"\" Markdown property readonly Return the contents of this block as markdown text. URL property readonly Return the URL contained in this Embed block. __compose__ ( url ) classmethod special Create a new Embed block from the given URL. Source code in notional/blocks.py @classmethod def __compose__ ( cls , url ): \"\"\"Create a new `Embed` block from the given URL.\"\"\" return Embed ( embed = Embed . _NestedData ( url = url )) File ( Block ) pydantic-model A file block in Notion. Source code in notional/blocks.py class File ( Block , type = \"file\" ): \"\"\"A file block in Notion.\"\"\" file : FileObject = None Heading1 ( TextBlock ) pydantic-model A heading_1 block in Notion. Source code in notional/blocks.py class Heading1 ( TextBlock , type = \"heading_1\" ): \"\"\"A heading_1 block in Notion.\"\"\" class _NestedData ( NestedObject ): rich_text : List [ RichTextObject ] = [] color : FullColor = FullColor . DEFAULT heading_1 : _NestedData = _NestedData () @property def Markdown ( self ): \"\"\"Return the contents of this block as markdown text.\"\"\" if self . heading_1 and self . heading_1 . rich_text : return f \"# { markdown ( * self . heading_1 . rich_text ) } #\" return \"\" Markdown property readonly Return the contents of this block as markdown text. Heading2 ( TextBlock ) pydantic-model A heading_2 block in Notion. Source code in notional/blocks.py class Heading2 ( TextBlock , type = \"heading_2\" ): \"\"\"A heading_2 block in Notion.\"\"\" class _NestedData ( NestedObject ): rich_text : List [ RichTextObject ] = [] color : FullColor = FullColor . DEFAULT heading_2 : _NestedData = _NestedData () @property def Markdown ( self ): \"\"\"Return the contents of this block as markdown text.\"\"\" if self . heading_2 and self . heading_2 . rich_text : return f \"## { markdown ( * self . heading_2 . rich_text ) } ##\" return \"\" Markdown property readonly Return the contents of this block as markdown text. Heading3 ( TextBlock ) pydantic-model A heading_3 block in Notion. Source code in notional/blocks.py class Heading3 ( TextBlock , type = \"heading_3\" ): \"\"\"A heading_3 block in Notion.\"\"\" class _NestedData ( NestedObject ): rich_text : List [ RichTextObject ] = [] color : FullColor = FullColor . DEFAULT heading_3 : _NestedData = _NestedData () @property def Markdown ( self ): \"\"\"Return the contents of this block as markdown text.\"\"\" if self . heading_3 and self . heading_3 . rich_text : return f \"### { markdown ( * self . heading_3 . rich_text ) } ###\" return \"\" Markdown property readonly Return the contents of this block as markdown text. Image ( Block ) pydantic-model An image block in Notion. Source code in notional/blocks.py class Image ( Block , type = \"image\" ): \"\"\"An image block in Notion.\"\"\" image : FileObject = None LinkPreview ( Block ) pydantic-model A link_preview block in Notion. Source code in notional/blocks.py class LinkPreview ( Block , type = \"link_preview\" ): \"\"\"A link_preview block in Notion.\"\"\" class _NestedData ( NestedObject ): url : str = None link_preview : _NestedData = _NestedData () @classmethod def __compose__ ( cls , url ): \"\"\"Create a new `LinkPreview` block from the given URL.\"\"\" return LinkPreview ( link_preview = LinkPreview . _NestedData ( url = url )) @property def URL ( self ): \"\"\"Return the URL contained in this `LinkPreview` block.\"\"\" return self . link_preview . url @property def Markdown ( self ): \"\"\"Return the contents of this block as markdown text.\"\"\" if self . link_preview and self . link_preview . url : return f \"< { self . link_preview . url } >\" return \"\" Markdown property readonly Return the contents of this block as markdown text. URL property readonly Return the URL contained in this LinkPreview block. __compose__ ( url ) classmethod special Create a new LinkPreview block from the given URL. Source code in notional/blocks.py @classmethod def __compose__ ( cls , url ): \"\"\"Create a new `LinkPreview` block from the given URL.\"\"\" return LinkPreview ( link_preview = LinkPreview . _NestedData ( url = url )) LinkToPage ( Block ) pydantic-model A link_to_page block in Notion. Source code in notional/blocks.py class LinkToPage ( Block , type = \"link_to_page\" ): \"\"\"A link_to_page block in Notion.\"\"\" link_to_page : ParentRef NumberedListItem ( TextBlock , WithChildrenMixin ) pydantic-model A numbered list item in Notion. Source code in notional/blocks.py class NumberedListItem ( TextBlock , WithChildrenMixin , type = \"numbered_list_item\" ): \"\"\"A numbered list item in Notion.\"\"\" class _NestedData ( NestedObject ): rich_text : List [ RichTextObject ] = [] children : Optional [ List [ Block ]] = None color : FullColor = FullColor . DEFAULT numbered_list_item : _NestedData = _NestedData () @property def Markdown ( self ): \"\"\"Return the contents of this block as markdown text.\"\"\" if self . numbered_list_item and self . numbered_list_item . rich_text : return f \"1. { markdown ( * self . numbered_list_item . rich_text ) } \" return \"\" Markdown property readonly Return the contents of this block as markdown text. PDF ( Block ) pydantic-model A pdf block in Notion. Source code in notional/blocks.py class PDF ( Block , type = \"pdf\" ): \"\"\"A pdf block in Notion.\"\"\" pdf : FileObject = None Paragraph ( TextBlock , WithChildrenMixin ) pydantic-model A paragraph block in Notion. Source code in notional/blocks.py class Paragraph ( TextBlock , WithChildrenMixin , type = \"paragraph\" ): \"\"\"A paragraph block in Notion.\"\"\" class _NestedData ( NestedObject ): rich_text : List [ RichTextObject ] = [] children : Optional [ List [ Block ]] = None color : FullColor = FullColor . DEFAULT paragraph : _NestedData = _NestedData () @property def Markdown ( self ): \"\"\"Return the contents of this block as markdown text.\"\"\" if self . paragraph and self . paragraph . rich_text : return markdown ( * self . paragraph . rich_text ) return \"\" Markdown property readonly Return the contents of this block as markdown text. Quote ( TextBlock , WithChildrenMixin ) pydantic-model A quote block in Notion. Source code in notional/blocks.py class Quote ( TextBlock , WithChildrenMixin , type = \"quote\" ): \"\"\"A quote block in Notion.\"\"\" class _NestedData ( NestedObject ): rich_text : List [ RichTextObject ] = [] children : Optional [ List [ Block ]] = None color : FullColor = FullColor . DEFAULT quote : _NestedData = _NestedData () @property def Markdown ( self ): \"\"\"Return the contents of this block as markdown text.\"\"\" if self . quote and self . quote . rich_text : return \"> \" + markdown ( * self . quote . rich_text ) return \"\" Markdown property readonly Return the contents of this block as markdown text. SyncedBlock ( Block , WithChildrenMixin ) pydantic-model A synced_block block in Notion - either original or synced. Source code in notional/blocks.py class SyncedBlock ( Block , WithChildrenMixin , type = \"synced_block\" ): \"\"\"A synced_block block in Notion - either original or synced.\"\"\" class _NestedData ( NestedObject ): synced_from : Optional [ BlockRef ] = None children : Optional [ List [ Block ]] = None synced_block : _NestedData = _NestedData () @property def IsOriginal ( self ): \"\"\"Determine if this block represents the original content. If this method returns `False`, the block represents the sync'ed block. \"\"\" return self . synced_block . synced_from is None IsOriginal property readonly Determine if this block represents the original content. If this method returns False , the block represents the sync'ed block. Table ( Block , WithChildrenMixin ) pydantic-model A table block in Notion. Source code in notional/blocks.py class Table ( Block , WithChildrenMixin , type = \"table\" ): \"\"\"A table block in Notion.\"\"\" class _NestedData ( NestedObject ): table_width : int = 0 has_column_header : bool = False has_row_header : bool = False # note that children will not be populated when getting this block # https://developers.notion.com/reference/block#table-blocks children : Optional [ List [ TableRow ]] = [] table : _NestedData = _NestedData () def append ( self , block : TableRow ): \"\"\"Append the given row to this table. This method is only applicable when creating a new `Table` block. In order to add rows to an existing `Table`, use the `blocks.children.append()` endpoint. When adding a row, this method will rase an exception if the width does not match the expected number of cells for existing rows in the block. \"\"\" # XXX need to review whether this is applicable during update... may need # to raise an error if the block has already been created on the server if not isinstance ( block , TableRow ): raise ValueError ( \"Only TableRow may be appended to Table blocks.\" ) if self . Width == 0 : self . table . table_width = block . Width elif self . Width != block . Width : raise ValueError ( \"Number of cells in row must match table\" ) self . table . children . append ( block ) @property def Width ( self ): \"\"\"Return the current width of this table.\"\"\" return self . table . table_width Width property readonly Return the current width of this table. append ( self , block ) Append the given row to this table. This method is only applicable when creating a new Table block. In order to add rows to an existing Table , use the blocks.children.append() endpoint. When adding a row, this method will rase an exception if the width does not match the expected number of cells for existing rows in the block. Source code in notional/blocks.py def append ( self , block : TableRow ): \"\"\"Append the given row to this table. This method is only applicable when creating a new `Table` block. In order to add rows to an existing `Table`, use the `blocks.children.append()` endpoint. When adding a row, this method will rase an exception if the width does not match the expected number of cells for existing rows in the block. \"\"\" # XXX need to review whether this is applicable during update... may need # to raise an error if the block has already been created on the server if not isinstance ( block , TableRow ): raise ValueError ( \"Only TableRow may be appended to Table blocks.\" ) if self . Width == 0 : self . table . table_width = block . Width elif self . Width != block . Width : raise ValueError ( \"Number of cells in row must match table\" ) self . table . children . append ( block ) TableOfContents ( Block ) pydantic-model A table_of_contents block in Notion. Source code in notional/blocks.py class TableOfContents ( Block , type = \"table_of_contents\" ): \"\"\"A table_of_contents block in Notion.\"\"\" class _NestedData ( NestedObject ): color : FullColor = FullColor . DEFAULT table_of_contents : _NestedData = _NestedData () TableRow ( Block ) pydantic-model A table_row block in Notion. Source code in notional/blocks.py class TableRow ( Block , type = \"table_row\" ): \"\"\"A table_row block in Notion.\"\"\" class _NestedData ( NestedObject ): cells : List [ List [ RichTextObject ]] = None table_row : _NestedData = _NestedData () def append ( self , text ): \"\"\"Append the given text as a new cell in this `TableRow`. `text` may be a string, `RichTextObject` or a list of `RichTextObject`'s. :param text: the text content to append \"\"\" if self . table_row . cells is None : self . table_row . cells = [] if isinstance ( text , list ): self . table_row . cells . append ( list ) elif isinstance ( text , RichTextObject ): self . table_row . cells . append ([ text ]) else : rtf = TextObject . from_value ( text ) self . table_row . cells . append ([ rtf ]) @property def Width ( self ): \"\"\"Return the width (number of cells) in this `TableRow`.\"\"\" return len ( self . table_row . cells ) if self . table_row . cells else 0 Width property readonly Return the width (number of cells) in this TableRow . append ( self , text ) Append the given text as a new cell in this TableRow . text may be a string, RichTextObject or a list of RichTextObject 's. :param text: the text content to append Source code in notional/blocks.py def append ( self , text ): \"\"\"Append the given text as a new cell in this `TableRow`. `text` may be a string, `RichTextObject` or a list of `RichTextObject`'s. :param text: the text content to append \"\"\" if self . table_row . cells is None : self . table_row . cells = [] if isinstance ( text , list ): self . table_row . cells . append ( list ) elif isinstance ( text , RichTextObject ): self . table_row . cells . append ([ text ]) else : rtf = TextObject . from_value ( text ) self . table_row . cells . append ([ rtf ]) Template ( Block , WithChildrenMixin ) pydantic-model A template block in Notion. Source code in notional/blocks.py class Template ( Block , WithChildrenMixin , type = \"template\" ): \"\"\"A template block in Notion.\"\"\" class _NestedData ( NestedObject ): rich_text : Optional [ List [ RichTextObject ]] = None children : Optional [ List [ Block ]] = None template : _NestedData = _NestedData () TextBlock ( Block , ABC ) pydantic-model A standard text block object in Notion. Source code in notional/blocks.py class TextBlock ( Block , ABC ): \"\"\"A standard text block object in Notion.\"\"\" # text blocks have a nested object with 'type' name and a 'text' child @property def __text__ ( self ): \"\"\"Provide short-hand access to the nested text content in this block.\"\"\" return self ( \"rich_text\" ) @classmethod def __compose__ ( cls , text ): \"\"\"Compose a `TextBlock` from the given text.\"\"\" if text is None : return None obj = cls () obj . concat ( text ) return obj def concat ( self , * text ): \"\"\"Concatenate text (either `RichTextObject` or `str` items) to this block.\"\"\" nested = self () if not hasattr ( nested , \"rich_text\" ): raise AttributeError ( \"nested data does not contain text\" ) if nested . rich_text is None : nested . rich_text = [] for obj in text : if obj is None : continue self . _append_object ( obj ) def _append_object ( self , obj ): \"\"\"Append the given object to the internal text of this TextObject.\"\"\" if isinstance ( obj , RichTextObject ): self . _append_rtf ( obj ) elif isinstance ( obj , str ): self . _append_text ( obj ) else : raise ValueError ( \"unsupported text object\" ) def _append_rtf ( self , rtf ): \"\"\"Append the given RichTextObject to this TextObject.\"\"\" nested = self () nested . rich_text . append ( rtf ) def _append_text ( self , text ): \"\"\"Append the given text to this TextObject. This text will be split into chunks in accordance with the Notion API. \"\"\" nested = self () # break up the text and compose new TextObject's from the pieces for chunk in chunky ( text ): obj = TextObject [ chunk ] nested . rich_text . append ( obj ) @property def PlainText ( self ): \"\"\"Return the contents of this Block as plain text.\"\"\" content = self . __text__ return None if content is None else plain_text ( * content ) PlainText property readonly Return the contents of this Block as plain text. __text__ property readonly special Provide short-hand access to the nested text content in this block. __compose__ ( text ) classmethod special Compose a TextBlock from the given text. Source code in notional/blocks.py @classmethod def __compose__ ( cls , text ): \"\"\"Compose a `TextBlock` from the given text.\"\"\" if text is None : return None obj = cls () obj . concat ( text ) return obj concat ( self , * text ) Concatenate text (either RichTextObject or str items) to this block. Source code in notional/blocks.py def concat ( self , * text ): \"\"\"Concatenate text (either `RichTextObject` or `str` items) to this block.\"\"\" nested = self () if not hasattr ( nested , \"rich_text\" ): raise AttributeError ( \"nested data does not contain text\" ) if nested . rich_text is None : nested . rich_text = [] for obj in text : if obj is None : continue self . _append_object ( obj ) ToDo ( TextBlock , WithChildrenMixin ) pydantic-model A todo list item in Notion. Source code in notional/blocks.py class ToDo ( TextBlock , WithChildrenMixin , type = \"to_do\" ): \"\"\"A todo list item in Notion.\"\"\" class _NestedData ( NestedObject ): rich_text : List [ RichTextObject ] = [] checked : bool = False children : Optional [ List [ Block ]] = None color : FullColor = FullColor . DEFAULT to_do : _NestedData = _NestedData () @classmethod def __compose__ ( cls , text , checked = False , href = None ): \"\"\"Compose a ToDo block from the given text and checked state.\"\"\" return ToDo ( to_do = ToDo . _NestedData ( rich_text = [ TextObject [ text , href ]], checked = checked , ) ) @property def IsChecked ( self ): \"\"\"Determine if this ToDo is marked as checked or not. If the block is empty (e.g. no nested data), this method returns `None`. \"\"\" return self . to_do . checked if self . to_do else None @property def Markdown ( self ): \"\"\"Return the contents of this block as markdown text.\"\"\" if self . to_do and self . to_do . rich_text : if self . to_do . checked : return f \"- [x] { markdown ( * self . to_do . rich_text ) } \" return f \"- [ ] { markdown ( * self . to_do . rich_text ) } \" return \"\" IsChecked property readonly Determine if this ToDo is marked as checked or not. If the block is empty (e.g. no nested data), this method returns None . Markdown property readonly Return the contents of this block as markdown text. __compose__ ( text , checked = False , href = None ) classmethod special Compose a ToDo block from the given text and checked state. Source code in notional/blocks.py @classmethod def __compose__ ( cls , text , checked = False , href = None ): \"\"\"Compose a ToDo block from the given text and checked state.\"\"\" return ToDo ( to_do = ToDo . _NestedData ( rich_text = [ TextObject [ text , href ]], checked = checked , ) ) Toggle ( TextBlock , WithChildrenMixin ) pydantic-model A toggle list item in Notion. Source code in notional/blocks.py class Toggle ( TextBlock , WithChildrenMixin , type = \"toggle\" ): \"\"\"A toggle list item in Notion.\"\"\" class _NestedData ( NestedObject ): rich_text : List [ RichTextObject ] = [] children : Optional [ List [ Block ]] = None color : FullColor = FullColor . DEFAULT toggle : _NestedData = _NestedData () UnsupportedBlock ( Block ) pydantic-model A placeholder for unsupported blocks in the API. Source code in notional/blocks.py class UnsupportedBlock ( Block , type = \"unsupported\" ): \"\"\"A placeholder for unsupported blocks in the API.\"\"\" class _NestedData ( NestedObject ): pass unsupported : Optional [ _NestedData ] = None Video ( Block ) pydantic-model A video block in Notion. Source code in notional/blocks.py class Video ( Block , type = \"video\" ): \"\"\"A video block in Notion.\"\"\" video : FileObject = None WithChildrenMixin Mixin for blocks that support children blocks. Source code in notional/blocks.py class WithChildrenMixin : \"\"\"Mixin for blocks that support children blocks.\"\"\" @property def __children__ ( self ): \"\"\"Provide short-hand access to the children in this block.\"\"\" return self ( \"children\" ) def __iadd__ ( self , block ): \"\"\"Append the given block to the children of this parent in place.\"\"\" self . append ( block ) return self def append ( self , block ): \"\"\"Append the given block to the children of this parent.\"\"\" if block is None : raise ValueError ( \"block cannot be None\" ) nested = self () if not hasattr ( nested , \"children\" ): raise TypeError ( \"nested data does not contain children\" ) if nested . children is None : nested . children = [] nested . children . append ( block ) self . has_children = True __children__ property readonly special Provide short-hand access to the children in this block. __iadd__ ( self , block ) special Append the given block to the children of this parent in place. Source code in notional/blocks.py def __iadd__ ( self , block ): \"\"\"Append the given block to the children of this parent in place.\"\"\" self . append ( block ) return self append ( self , block ) Append the given block to the children of this parent. Source code in notional/blocks.py def append ( self , block ): \"\"\"Append the given block to the children of this parent.\"\"\" if block is None : raise ValueError ( \"block cannot be None\" ) nested = self () if not hasattr ( nested , \"children\" ): raise TypeError ( \"nested data does not contain children\" ) if nested . children is None : nested . children = [] nested . children . append ( block ) self . has_children = True core Base classes for working with the Notion API. ComposableObject ( ModelMetaclass ) Presents a meta class that composes objects using simple values. This is primarily to allow easy definition of data objects without disrupting the BaseModel constructor. e.g. rather than requiring a caller to understand how nested data works in the data objects, they can compose objects from simple values. Compare the following code for declaring a Paragraph: # using nested data objects: text = \"hello world\" nested = TextObject . _NestedData ( content = text ) rtf = text . TextObject ( text = nested , plain_text = text ) content = blocks . Paragraph . _NestedData ( text = [ rtf ]) para = blocks . Paragraph ( paragraph = content ) # using a composable object: para = blocks . Paragraph [ \"hello world\" ] Classes that support composition in this way must define and implement the internal __compose__ method. This method takes an arbitrary number of parameters, based on the needs of the implementation. It is up to the implementing class to ensure that the parameters are specificied correctly. Source code in notional/core.py class ComposableObject ( ModelMetaclass ): \"\"\"Presents a meta class that composes objects using simple values. This is primarily to allow easy definition of data objects without disrupting the `BaseModel` constructor. e.g. rather than requiring a caller to understand how nested data works in the data objects, they can compose objects from simple values. Compare the following code for declaring a Paragraph: ```python # using nested data objects: text = \"hello world\" nested = TextObject._NestedData(content=text) rtf = text.TextObject(text=nested, plain_text=text) content = blocks.Paragraph._NestedData(text=[rtf]) para = blocks.Paragraph(paragraph=content) # using a composable object: para = blocks.Paragraph[\"hello world\"] ``` Classes that support composition in this way must define and implement the internal `__compose__` method. This method takes an arbitrary number of parameters, based on the needs of the implementation. It is up to the implementing class to ensure that the parameters are specificied correctly. \"\"\" def __getitem__ ( self , params ): \"\"\"Return the requested class by composing using the given param. Types found in `params` will be compared to expected types in the `__compose__` method. If the requested class does not expose the `__compose__` method, this will raise an exception. \"\"\" if not hasattr ( self , \"__compose__\" ): raise NotImplementedError ( f \" { self } does not support object composition\" ) # XXX if params is empty / None, consider calling the default constructor compose = self . __compose__ if type ( params ) is tuple : return compose ( * params ) return compose ( params ) __getitem__ ( self , params ) special Return the requested class by composing using the given param. Types found in params will be compared to expected types in the __compose__ method. If the requested class does not expose the __compose__ method, this will raise an exception. Source code in notional/core.py def __getitem__ ( self , params ): \"\"\"Return the requested class by composing using the given param. Types found in `params` will be compared to expected types in the `__compose__` method. If the requested class does not expose the `__compose__` method, this will raise an exception. \"\"\" if not hasattr ( self , \"__compose__\" ): raise NotImplementedError ( f \" { self } does not support object composition\" ) # XXX if params is empty / None, consider calling the default constructor compose = self . __compose__ if type ( params ) is tuple : return compose ( * params ) return compose ( params ) DataObject ( BaseModel ) pydantic-model The base for all API objects. Source code in notional/core.py class DataObject ( BaseModel , metaclass = ComposableObject ): \"\"\"The base for all API objects.\"\"\" def __setattr__ ( self , name , value ): \"\"\"Set the attribute of this object to a given value. The implementation of `BaseModel.__setattr__` does not allow for properties. See https://github.com/samuelcolvin/pydantic/issues/1577 \"\"\" try : super () . __setattr__ ( name , value ) except ValueError as err : setters = inspect . getmembers ( self . __class__ , predicate = lambda x : isinstance ( x , property ) and x . fset is not None , ) for setter_name , _ in setters : if setter_name == name : object . __setattr__ ( self , name , value ) break else : raise err @classmethod def _modify_field_ ( cls , name , default = None ): \"\"\"Modify the `BaseModel` field information for a specific class instance. This is necessary in particular for sublcasses that change the default values of a model when defined. Notable examples are `TypedObject` and `NamedObject`. :param name: the named attribute in the class :param default: the new default for the named field \"\"\" setattr ( cls , name , default ) cls . __fields__ [ name ] . default = default cls . __fields__ [ name ] . required = default is None # https://github.com/samuelcolvin/pydantic/discussions/3139 def refresh ( __pydantic_self__ , ** data ): \"\"\"Refresh the internal attributes with new data.\"\"\" values , fields , error = validate_model ( __pydantic_self__ . __class__ , data ) if error : raise error for name in fields : value = values [ name ] log . debug ( \"set object data -- %s => %s \" , name , value ) setattr ( __pydantic_self__ , name , value ) return __pydantic_self__ def to_api ( self ): \"\"\"Convert to a suitable representation for the Notion API.\"\"\" # the API doesn't like \"undefined\" values... data = self . dict ( exclude_none = True , by_alias = True ) # we need to convert \"special\" types to string forms to help the JSON encoder. # there are efforts underway in pydantic to make this easier, but for now... return make_api_safe ( data ) __setattr__ ( self , name , value ) special Set the attribute of this object to a given value. The implementation of BaseModel.__setattr__ does not allow for properties. See https://github.com/samuelcolvin/pydantic/issues/1577 Source code in notional/core.py def __setattr__ ( self , name , value ): \"\"\"Set the attribute of this object to a given value. The implementation of `BaseModel.__setattr__` does not allow for properties. See https://github.com/samuelcolvin/pydantic/issues/1577 \"\"\" try : super () . __setattr__ ( name , value ) except ValueError as err : setters = inspect . getmembers ( self . __class__ , predicate = lambda x : isinstance ( x , property ) and x . fset is not None , ) for setter_name , _ in setters : if setter_name == name : object . __setattr__ ( self , name , value ) break else : raise err refresh ( __pydantic_self__ , ** data ) Refresh the internal attributes with new data. Source code in notional/core.py def refresh ( __pydantic_self__ , ** data ): \"\"\"Refresh the internal attributes with new data.\"\"\" values , fields , error = validate_model ( __pydantic_self__ . __class__ , data ) if error : raise error for name in fields : value = values [ name ] log . debug ( \"set object data -- %s => %s \" , name , value ) setattr ( __pydantic_self__ , name , value ) return __pydantic_self__ to_api ( self ) Convert to a suitable representation for the Notion API. Source code in notional/core.py def to_api ( self ): \"\"\"Convert to a suitable representation for the Notion API.\"\"\" # the API doesn't like \"undefined\" values... data = self . dict ( exclude_none = True , by_alias = True ) # we need to convert \"special\" types to string forms to help the JSON encoder. # there are efforts underway in pydantic to make this easier, but for now... return make_api_safe ( data ) NamedObject ( DataObject ) pydantic-model A Notion API object. Source code in notional/core.py class NamedObject ( DataObject ): \"\"\"A Notion API object.\"\"\" # XXX should NamedObject have the same typing ability as TypedObject? object : str def __init_subclass__ ( cls , object = None , ** kwargs ): \"\"\"Update `DataObject` defaults for the named object.\"\"\" super () . __init_subclass__ ( ** kwargs ) if object is not None : cls . _modify_field_ ( \"object\" , default = object ) __init_subclass__ ( object = None , ** kwargs ) classmethod special Update DataObject defaults for the named object. Source code in notional/core.py def __init_subclass__ ( cls , object = None , ** kwargs ): \"\"\"Update `DataObject` defaults for the named object.\"\"\" super () . __init_subclass__ ( ** kwargs ) if object is not None : cls . _modify_field_ ( \"object\" , default = object ) NestedObject ( DataObject ) pydantic-model Represents an API object with nested data. These objects require a 'type' property and a matching property of the same name, which holds additional data. For example, this contains a nested 'text' object: data = { type: \"text\", ... !!! text \"{\" ... } } Currently, this is a convenience class for clarity - it does not provide additional functionality at this time. Source code in notional/core.py class NestedObject ( DataObject ): \"\"\"Represents an API object with nested data. These objects require a 'type' property and a matching property of the same name, which holds additional data. For example, this contains a nested 'text' object: data = { type: \"text\", ... text: { ... } } Currently, this is a convenience class for clarity - it does not provide additional functionality at this time. \"\"\" TypedObject ( DataObject ) pydantic-model A type-referenced object. Many objects in the Notion API follow a generic->specific pattern with a 'type' parameter followed by additional data. These objects must specify a type attribute to ensure that the correct object is created. Calling the object provides direct access to the data stored in {type} . Source code in notional/core.py class TypedObject ( DataObject ): \"\"\"A type-referenced object. Many objects in the Notion API follow a generic->specific pattern with a 'type' parameter followed by additional data. These objects must specify a `type` attribute to ensure that the correct object is created. Calling the object provides direct access to the data stored in `{type}`. \"\"\" type : str # modified from the methods described in this discussion: # - https://github.com/samuelcolvin/pydantic/discussions/3091 def __init_subclass__ ( cls , type = None , ** kwargs ): \"\"\"Register the subtypes of the TypedObject subclass.\"\"\" super () . __init_subclass__ ( ** kwargs ) if type is not None : sub_type = type elif hasattr ( cls , \"__type__\" ): sub_type = cls . __type__ else : sub_type = cls . __name__ cls . _modify_field_ ( \"type\" , default = sub_type ) # initialize a __typemap__ map for each direct child of TypedObject # this allows different class trees to have the same 'type' name # but point to a different object (e.g. the 'date' type may have # different implementations depending where it is used in the API) # also, due to the order in which typed classes are defined, once # the map is defined for a subclass of TypedObject, any further # descendants of that class will have the new map via inheritance if TypedObject in cls . __bases__ and not hasattr ( cls , \"__typemap__\" ): cls . __typemap__ = {} if sub_type in cls . __typemap__ : raise ValueError ( f \"Duplicate subtype for class - { sub_type } :: { cls } \" ) log . debug ( \"registered new subtype: %s => %s \" , sub_type , cls ) cls . __typemap__ [ sub_type ] = cls def __call__ ( self , field = None ): \"\"\"Return nested data from this Block. If a field is provided, the contents of that field in the NestedData will be returned. Otherwise, the full contents of the NestedData will be returned. \"\"\" type = getattr ( self , \"type\" , None ) if type is None : raise AttributeError ( \"type not specified\" ) nested = getattr ( self , type ) if field is not None : nested = getattr ( nested , field ) return nested @classmethod def __get_validators__ ( cls ): \"\"\"Provide `BaseModel` with the means to convert `TypedObject`'s.\"\"\" yield cls . _convert_to_real_type_ @classmethod def parse_obj ( cls , obj ): \"\"\"Parse the structured object data into an instance of `TypedObject`. This method overrides `BaseModel.parse_obj()`. \"\"\" return cls . _convert_to_real_type_ ( obj ) @classmethod def _convert_to_real_type_ ( cls , data ): \"\"\"Instantiate the correct object based on the 'type' field.\"\"\" if isinstance ( data , cls ): return data if not isinstance ( data , dict ): raise ValueError ( \"Invalid 'data' object\" ) data_type = data . get ( \"type\" ) if data_type is None : raise ValueError ( \"Missing 'type' in TypedObject\" ) if not hasattr ( cls , \"__typemap__\" ): raise TypeError ( f \"Invalid TypedObject: { cls } - missing __typemap__\" ) sub = cls . __typemap__ . get ( data_type ) if sub is None : raise TypeError ( f \"Unsupport sub-type: { data_type } \" ) log . debug ( \"initializing typed object %s :: %s => %s -- %s \" , cls , data_type , sub , data ) return sub ( ** data ) __call__ ( self , field = None ) special Return nested data from this Block. If a field is provided, the contents of that field in the NestedData will be returned. Otherwise, the full contents of the NestedData will be returned. Source code in notional/core.py def __call__ ( self , field = None ): \"\"\"Return nested data from this Block. If a field is provided, the contents of that field in the NestedData will be returned. Otherwise, the full contents of the NestedData will be returned. \"\"\" type = getattr ( self , \"type\" , None ) if type is None : raise AttributeError ( \"type not specified\" ) nested = getattr ( self , type ) if field is not None : nested = getattr ( nested , field ) return nested __get_validators__ () classmethod special Provide BaseModel with the means to convert TypedObject 's. Source code in notional/core.py @classmethod def __get_validators__ ( cls ): \"\"\"Provide `BaseModel` with the means to convert `TypedObject`'s.\"\"\" yield cls . _convert_to_real_type_ __init_subclass__ ( type = None , ** kwargs ) classmethod special Register the subtypes of the TypedObject subclass. Source code in notional/core.py def __init_subclass__ ( cls , type = None , ** kwargs ): \"\"\"Register the subtypes of the TypedObject subclass.\"\"\" super () . __init_subclass__ ( ** kwargs ) if type is not None : sub_type = type elif hasattr ( cls , \"__type__\" ): sub_type = cls . __type__ else : sub_type = cls . __name__ cls . _modify_field_ ( \"type\" , default = sub_type ) # initialize a __typemap__ map for each direct child of TypedObject # this allows different class trees to have the same 'type' name # but point to a different object (e.g. the 'date' type may have # different implementations depending where it is used in the API) # also, due to the order in which typed classes are defined, once # the map is defined for a subclass of TypedObject, any further # descendants of that class will have the new map via inheritance if TypedObject in cls . __bases__ and not hasattr ( cls , \"__typemap__\" ): cls . __typemap__ = {} if sub_type in cls . __typemap__ : raise ValueError ( f \"Duplicate subtype for class - { sub_type } :: { cls } \" ) log . debug ( \"registered new subtype: %s => %s \" , sub_type , cls ) cls . __typemap__ [ sub_type ] = cls parse_obj ( obj ) classmethod Parse the structured object data into an instance of TypedObject . This method overrides BaseModel.parse_obj() . Source code in notional/core.py @classmethod def parse_obj ( cls , obj ): \"\"\"Parse the structured object data into an instance of `TypedObject`. This method overrides `BaseModel.parse_obj()`. \"\"\" return cls . _convert_to_real_type_ ( obj ) make_api_safe ( data ) Recursively convert the given data to an API-safe form. This is mostly to handle data types that will not directly serialize to JSON. Source code in notional/core.py def make_api_safe ( data ): \"\"\"Recursively convert the given data to an API-safe form. This is mostly to handle data types that will not directly serialize to JSON. \"\"\" # https://github.com/samuelcolvin/pydantic/issues/1409#issuecomment-877175194 if isinstance ( data , ( date , datetime )): return data . isoformat () if isinstance ( data , UUID ): return str ( data ) if isinstance ( data , Enum ): return data . value if isinstance ( data , dict ): return { name : make_api_safe ( value ) for name , value in data . items ()} if isinstance ( data , list ): return [ make_api_safe ( value ) for value in data ] if isinstance ( data , tuple ): return [ make_api_safe ( value ) for value in data ] return data iterator Iterator classes for notional. ContentIterator ( ABC ) Base class to handle pagination over arbitrary content. Source code in notional/iterator.py class ContentIterator ( ABC ): \"\"\"Base class to handle pagination over arbitrary content.\"\"\" def __init__ ( self ): \"\"\"Initialzie the iterator.\"\"\" self . log = log . getChild ( \"ContentIterator\" ) self . page = None self . page_index = - 1 self . page_num = 0 self . n_items = 0 def __iter__ ( self ): \"\"\"Initialize the iterator.\"\"\" self . log . debug ( \"initializing content iterator\" ) return self def __next__ ( self ): \"\"\"Return the next item from the result set or raise StopIteration.\"\"\" # load a new page if needed if self . page is None or self . page_index >= len ( self . page ): self . page_index = 0 self . page = self . load_next_page () self . page_num += 1 # if we have run out of results... if self . page is None or len ( self . page ) == 0 : raise StopIteration # pull the next item from the current page item = self . page [ self . page_index ] # setup for the next call self . page_index += 1 self . n_items += 1 return item @property def page_number ( self ): \"\"\"Return the current page number of results in this iterator.\"\"\" return self . page_num @property def total_items ( self ): \"\"\"Return the total number of items returns by this iterator.\"\"\" return self . n_items @abstractmethod def load_next_page ( self ): \"\"\"Retrieve the next page of data as a list of items.\"\"\" page_number property readonly Return the current page number of results in this iterator. total_items property readonly Return the total number of items returns by this iterator. __init__ ( self ) special Initialzie the iterator. Source code in notional/iterator.py def __init__ ( self ): \"\"\"Initialzie the iterator.\"\"\" self . log = log . getChild ( \"ContentIterator\" ) self . page = None self . page_index = - 1 self . page_num = 0 self . n_items = 0 __iter__ ( self ) special Initialize the iterator. Source code in notional/iterator.py def __iter__ ( self ): \"\"\"Initialize the iterator.\"\"\" self . log . debug ( \"initializing content iterator\" ) return self __next__ ( self ) special Return the next item from the result set or raise StopIteration. Source code in notional/iterator.py def __next__ ( self ): \"\"\"Return the next item from the result set or raise StopIteration.\"\"\" # load a new page if needed if self . page is None or self . page_index >= len ( self . page ): self . page_index = 0 self . page = self . load_next_page () self . page_num += 1 # if we have run out of results... if self . page is None or len ( self . page ) == 0 : raise StopIteration # pull the next item from the current page item = self . page [ self . page_index ] # setup for the next call self . page_index += 1 self . n_items += 1 return item load_next_page ( self ) Retrieve the next page of data as a list of items. Source code in notional/iterator.py @abstractmethod def load_next_page ( self ): \"\"\"Retrieve the next page of data as a list of items.\"\"\" EndpointIterator ( ResultSetIterator ) Base class for iterating over results from an API endpoint. Source code in notional/iterator.py class EndpointIterator ( ResultSetIterator ): \"\"\"Base class for iterating over results from an API endpoint.\"\"\" def __init__ ( self , endpoint , ** params ): \"\"\"Initialize the `EndpointIterator` for a specific API endpoint. :param endpoint: the concrete endpoint to use for this iterator :param params: parameters sent to the endpoint when called \"\"\" super () . __init__ () self . endpoint = endpoint self . params = params or {} self . log = log . getChild ( \"EndpointIterator\" ) def __setitem__ ( self , name , value ): \"\"\"Set the parameter in this `EndpointIterator`.\"\"\" self . params [ name ] = value def load_page_data ( self , params ): \"\"\"Return the next page with given parameters.\"\"\" params . update ( self . params ) return self . endpoint ( ** params ) __init__ ( self , endpoint , ** params ) special Initialize the EndpointIterator for a specific API endpoint. :param endpoint: the concrete endpoint to use for this iterator :param params: parameters sent to the endpoint when called Source code in notional/iterator.py def __init__ ( self , endpoint , ** params ): \"\"\"Initialize the `EndpointIterator` for a specific API endpoint. :param endpoint: the concrete endpoint to use for this iterator :param params: parameters sent to the endpoint when called \"\"\" super () . __init__ () self . endpoint = endpoint self . params = params or {} self . log = log . getChild ( \"EndpointIterator\" ) __setitem__ ( self , name , value ) special Set the parameter in this EndpointIterator . Source code in notional/iterator.py def __setitem__ ( self , name , value ): \"\"\"Set the parameter in this `EndpointIterator`.\"\"\" self . params [ name ] = value load_page_data ( self , params ) Return the next page with given parameters. Source code in notional/iterator.py def load_page_data ( self , params ): \"\"\"Return the next page with given parameters.\"\"\" params . update ( self . params ) return self . endpoint ( ** params ) PageIterator ( ContentIterator , ABC ) Base class to handle pagination by page number. Source code in notional/iterator.py class PageIterator ( ContentIterator , ABC ): \"\"\"Base class to handle pagination by page number.\"\"\" def load_next_page ( self ): \"\"\"Retrieve the next page of data as a list of items.\"\"\" return self . get_page_content ( self . page_num + 1 ) @abstractmethod def get_page_content ( self , page_num ): \"\"\"Retrieve the page of data with the given number.\"\"\" get_page_content ( self , page_num ) Retrieve the page of data with the given number. Source code in notional/iterator.py @abstractmethod def get_page_content ( self , page_num ): \"\"\"Retrieve the page of data with the given number.\"\"\" load_next_page ( self ) Retrieve the next page of data as a list of items. Source code in notional/iterator.py def load_next_page ( self ): \"\"\"Retrieve the next page of data as a list of items.\"\"\" return self . get_page_content ( self . page_num + 1 ) PositionalIterator ( ContentIterator , ABC ) Base class to handle pagination by positional cursor. Source code in notional/iterator.py class PositionalIterator ( ContentIterator , ABC ): \"\"\"Base class to handle pagination by positional cursor.\"\"\" def __init__ ( self ): \"\"\"Initialize the iterator.\"\"\" super () . __init__ () self . cursor = None self . first_pass = True def load_next_page ( self ): \"\"\"Load the next page of data from this iterator.\"\"\" if not self . first_pass and not self . cursor : return None results = self . get_page_data ( self . cursor ) self . cursor = results . next_cursor self . first_pass = False return results . items @abstractmethod def get_page_data ( self , cursor ): \"\"\"Retrieve the page of data starting at the given cursor.\"\"\" class PageData ( BaseModel ): \"\"\"Represents a page of data from the Notion API.\"\"\" this_cursor : Optional [ Any ] = None next_cursor : Optional [ Any ] = None items : Optional [ List [ Any ]] = None @property def page_size ( self ): \"\"\"Return the page size for this data set.\"\"\" return - 1 if self . items is None else len ( self . items ) PageData ( BaseModel ) pydantic-model Represents a page of data from the Notion API. Source code in notional/iterator.py class PageData ( BaseModel ): \"\"\"Represents a page of data from the Notion API.\"\"\" this_cursor : Optional [ Any ] = None next_cursor : Optional [ Any ] = None items : Optional [ List [ Any ]] = None @property def page_size ( self ): \"\"\"Return the page size for this data set.\"\"\" return - 1 if self . items is None else len ( self . items ) page_size property readonly Return the page size for this data set. __init__ ( self ) special Initialize the iterator. Source code in notional/iterator.py def __init__ ( self ): \"\"\"Initialize the iterator.\"\"\" super () . __init__ () self . cursor = None self . first_pass = True get_page_data ( self , cursor ) Retrieve the page of data starting at the given cursor. Source code in notional/iterator.py @abstractmethod def get_page_data ( self , cursor ): \"\"\"Retrieve the page of data starting at the given cursor.\"\"\" load_next_page ( self ) Load the next page of data from this iterator. Source code in notional/iterator.py def load_next_page ( self ): \"\"\"Load the next page of data from this iterator.\"\"\" if not self . first_pass and not self . cursor : return None results = self . get_page_data ( self . cursor ) self . cursor = results . next_cursor self . first_pass = False return results . items ResultSetIterator ( PositionalIterator , ABC ) Base class for iterating over Notion API result sets. Source code in notional/iterator.py class ResultSetIterator ( PositionalIterator , ABC ): \"\"\"Base class for iterating over Notion API result sets.\"\"\" def get_page_data ( self , cursor ): \"\"\"Retrieve the page of data starting at the given cursor.\"\"\" params = { \"page_size\" : CONTENT_PAGE_SIZE } if cursor : params [ \"start_cursor\" ] = cursor self . log . debug ( \"loading next page - start cursor: %s \" , cursor ) # TODO error checking on result data = self . load_page_data ( params ) results = PositionalIterator . PageData ( this_cursor = cursor , next_cursor = data [ \"next_cursor\" ] if data [ \"has_more\" ] else None , items = data [ \"results\" ] if \"results\" in data else None , ) self . log . debug ( \"loaded %d results; next cursor: %s \" , results . page_size , results . next_cursor ) return results @property def last_page ( self ): \"\"\"Return true if this is the last page of results.\"\"\" return not self . first_pass and self . cursor is None @abstractmethod def load_page_data ( self , params ): \"\"\"Load the page of data defined by the given params.\"\"\" last_page property readonly Return true if this is the last page of results. get_page_data ( self , cursor ) Retrieve the page of data starting at the given cursor. Source code in notional/iterator.py def get_page_data ( self , cursor ): \"\"\"Retrieve the page of data starting at the given cursor.\"\"\" params = { \"page_size\" : CONTENT_PAGE_SIZE } if cursor : params [ \"start_cursor\" ] = cursor self . log . debug ( \"loading next page - start cursor: %s \" , cursor ) # TODO error checking on result data = self . load_page_data ( params ) results = PositionalIterator . PageData ( this_cursor = cursor , next_cursor = data [ \"next_cursor\" ] if data [ \"has_more\" ] else None , items = data [ \"results\" ] if \"results\" in data else None , ) self . log . debug ( \"loaded %d results; next cursor: %s \" , results . page_size , results . next_cursor ) return results load_page_data ( self , params ) Load the page of data defined by the given params. Source code in notional/iterator.py @abstractmethod def load_page_data ( self , params ): \"\"\"Load the page of data defined by the given params.\"\"\" orm Utilities for working with Notion as an ORM. There are two primary constructs in this module that enable custom type definitions in Notional: Property() and connected_page() . ConnectedPage Base class for \"live\" pages via the Notion API. All changes are committed in real time. Source code in notional/orm.py class ConnectedPage : \"\"\"Base class for \"live\" pages via the Notion API. All changes are committed in real time. \"\"\" def __init__ ( self , ** data ): \"\"\"Construct a page from the given data dictionary.\"\"\" self . _notional__page = Page ( ** data ) if data else None def __init_subclass__ ( cls , database = None , ** kwargs ): \"\"\"Register new subclasses of a ConnectedPage.\"\"\" super ( cls ) . __init_subclass__ ( ** kwargs ) if database is not None : cls . _notional__database = database elif hasattr ( cls , \"__database__\" ): cls . _notional__database = cls . __database__ @property def id ( self ): \"\"\"Return the ID of this page (if available).\"\"\" return self . _notional__page . id if self . _notional__page else None @property def children ( self ): \"\"\"Return an iterator for all child blocks of this Page.\"\"\" if self . _notional__page is None : return [] return self . _notional__session . blocks . children . list ( parent = self . _notional__page ) @property def cover ( self ): \"\"\"Return the cover for the Page.\"\"\" return self . _notional__page . cover @cover . setter def cover ( self , file ): \"\"\"Set the cover for the Page.\"\"\" self . _notional__session . pages . set ( self . _notional__page , cover = file ) @property def icon ( self ): \"\"\"Return the icon for the Page.\"\"\" return self . _notional__page . icon @icon . setter def icon ( self , emoji ): \"\"\"Set the icon for the Page. :param emoji: may be either a single emoji string or an `EmojiObject` \"\"\" if isinstance ( emoji , str ): emoji = EmojiObject [ emoji ] elif not isinstance ( emoji , EmojiObject ): raise ValueError ( \"Invalid emoji; unsupported type\" ) self . _notional__session . pages . set ( self . _notional__page , icon = emoji ) def __iadd__ ( self , block ): \"\"\"Append the given block to this page. This operation takes place on the Notion server, causing the page to save immediately. \"\"\" self . append ( block ) return self def append ( self , * blocks ): \"\"\"Append the given blocks as children of this ConnectedPage. This operation takes place on the Notion server, causing the page to update immediately. \"\"\" if self . _notional__page is None : raise ValueError ( \"Cannot append blocks; missing page\" ) if self . _notional__session is None : raise ValueError ( \"Cannot append blocks; invalid session\" ) log . debug ( \"appending %d blocks to page :: %s \" , len ( blocks ), self . _notional__page . id ) self . _notional__session . blocks . children . append ( self . _notional__page , * blocks ) @classmethod def bind ( cls , to_session ): \"\"\"Attach this ConnectedPage to the given session. Setting this to None will detach the page. \"\"\" cls . _notional__session = to_session @classmethod def query ( cls ): \"\"\"Return a `QueryBuilder` for the custom type.\"\"\" if cls . _notional__session is None : raise ValueError ( \"Unable to query; invalid session\" ) if cls . _notional__database is None : raise ValueError ( \"Unable to query; invalid database\" ) return cls . _notional__session . databases . query ( cls ) @classmethod def create ( cls , ** kwargs ): \"\"\"Create a new instance of the ConnectedPage type. Any properties that support object composition may defined in `kwargs`. This operation takes place on the Notion server, creating the page immediately. :param properties: the properties to initialize for this object as a `dict()` with format `name: value` where `name` is the attribute in the custom type and `value` is a supported type for composing \"\"\" if cls . _notional__session is None : raise ValueError ( \"Cannot create Page; invalid session\" ) if cls . _notional__database is None : raise ValueError ( \"Cannot create Page; invalid database\" ) log . debug ( \"creating new %s :: %s \" , cls , cls . _notional__database ) parent = DatabaseRef ( database_id = cls . _notional__database ) connected = cls () connected . _notional__page = cls . _notional__session . pages . create ( parent = parent ) # FIXME it would be better to convert properties to a dict and pass to the API, # rather than setting them individually here... for name , value in kwargs . items (): setattr ( connected , name , value ) return connected @classmethod def parse_obj ( cls , data ): \"\"\"Invoke the class constructor using the structured data. Similar to `BaseModel.parse_obj(data)`. \"\"\" return cls ( ** data ) children property readonly Return an iterator for all child blocks of this Page. cover property writable Return the cover for the Page. icon property writable Return the icon for the Page. id property readonly Return the ID of this page (if available). __iadd__ ( self , block ) special Append the given block to this page. This operation takes place on the Notion server, causing the page to save immediately. Source code in notional/orm.py def __iadd__ ( self , block ): \"\"\"Append the given block to this page. This operation takes place on the Notion server, causing the page to save immediately. \"\"\" self . append ( block ) return self __init__ ( self , ** data ) special Construct a page from the given data dictionary. Source code in notional/orm.py def __init__ ( self , ** data ): \"\"\"Construct a page from the given data dictionary.\"\"\" self . _notional__page = Page ( ** data ) if data else None __init_subclass__ ( database = None , ** kwargs ) classmethod special Register new subclasses of a ConnectedPage. Source code in notional/orm.py def __init_subclass__ ( cls , database = None , ** kwargs ): \"\"\"Register new subclasses of a ConnectedPage.\"\"\" super ( cls ) . __init_subclass__ ( ** kwargs ) if database is not None : cls . _notional__database = database elif hasattr ( cls , \"__database__\" ): cls . _notional__database = cls . __database__ append ( self , * blocks ) Append the given blocks as children of this ConnectedPage. This operation takes place on the Notion server, causing the page to update immediately. Source code in notional/orm.py def append ( self , * blocks ): \"\"\"Append the given blocks as children of this ConnectedPage. This operation takes place on the Notion server, causing the page to update immediately. \"\"\" if self . _notional__page is None : raise ValueError ( \"Cannot append blocks; missing page\" ) if self . _notional__session is None : raise ValueError ( \"Cannot append blocks; invalid session\" ) log . debug ( \"appending %d blocks to page :: %s \" , len ( blocks ), self . _notional__page . id ) self . _notional__session . blocks . children . append ( self . _notional__page , * blocks ) bind ( to_session ) classmethod Attach this ConnectedPage to the given session. Setting this to None will detach the page. Source code in notional/orm.py @classmethod def bind ( cls , to_session ): \"\"\"Attach this ConnectedPage to the given session. Setting this to None will detach the page. \"\"\" cls . _notional__session = to_session create ( ** kwargs ) classmethod Create a new instance of the ConnectedPage type. Any properties that support object composition may defined in kwargs . This operation takes place on the Notion server, creating the page immediately. :param properties: the properties to initialize for this object as a dict() with format name: value where name is the attribute in the custom type and value is a supported type for composing Source code in notional/orm.py @classmethod def create ( cls , ** kwargs ): \"\"\"Create a new instance of the ConnectedPage type. Any properties that support object composition may defined in `kwargs`. This operation takes place on the Notion server, creating the page immediately. :param properties: the properties to initialize for this object as a `dict()` with format `name: value` where `name` is the attribute in the custom type and `value` is a supported type for composing \"\"\" if cls . _notional__session is None : raise ValueError ( \"Cannot create Page; invalid session\" ) if cls . _notional__database is None : raise ValueError ( \"Cannot create Page; invalid database\" ) log . debug ( \"creating new %s :: %s \" , cls , cls . _notional__database ) parent = DatabaseRef ( database_id = cls . _notional__database ) connected = cls () connected . _notional__page = cls . _notional__session . pages . create ( parent = parent ) # FIXME it would be better to convert properties to a dict and pass to the API, # rather than setting them individually here... for name , value in kwargs . items (): setattr ( connected , name , value ) return connected parse_obj ( data ) classmethod Invoke the class constructor using the structured data. Similar to BaseModel.parse_obj(data) . Source code in notional/orm.py @classmethod def parse_obj ( cls , data ): \"\"\"Invoke the class constructor using the structured data. Similar to `BaseModel.parse_obj(data)`. \"\"\" return cls ( ** data ) query () classmethod Return a QueryBuilder for the custom type. Source code in notional/orm.py @classmethod def query ( cls ): \"\"\"Return a `QueryBuilder` for the custom type.\"\"\" if cls . _notional__session is None : raise ValueError ( \"Unable to query; invalid session\" ) if cls . _notional__database is None : raise ValueError ( \"Unable to query; invalid database\" ) return cls . _notional__session . databases . query ( cls ) ConnectedPageFactory A factory that builds custom types for ConnectedPage classes. Typically, these generated classes will be extended to form a custom type. Source code in notional/orm.py class ConnectedPageFactory : \"\"\"A factory that builds custom types for `ConnectedPage` classes. Typically, these generated classes will be extended to form a custom type. \"\"\" # TODO consider making this more general purpose (e.g. extend other base objects) def __init__ ( self , name = \"CustomBase\" , base = None , metaclass = None , ): \"\"\"Initialze the `ConnectedPageFactory` with the given parameters. :param name: the name of the class generated by this factory; defaults to \"CustomPage\" :param base: the class (or tuple of classes) used as the base class for types generated by this factory; defaults to `None` :param metaclass: the callable metaclass to use for generating new types; defaults to `type` \"\"\" self . name = name if base is None : self . bases = ( ConnectedPage ,) elif isinstance ( base , tuple ): self . bases = base else : self . bases = ( base ,) if metaclass is None : self . metaclass = type else : self . metaclass = metaclass def __call__ ( self , session , database , schema = None ): \"\"\"Return a new type from this factory with the given configuration.\"\"\" attrs = { \"_notional__session\" : session , \"_notional__database\" : database , } if schema is not None : for name , obj in schema . items (): safe_name = make_safe_python_name ( name ) prop = Property ( name , obj ) attrs [ safe_name ] = prop return self . metaclass ( self . name , self . bases , attrs ) __call__ ( self , session , database , schema = None ) special Return a new type from this factory with the given configuration. Source code in notional/orm.py def __call__ ( self , session , database , schema = None ): \"\"\"Return a new type from this factory with the given configuration.\"\"\" attrs = { \"_notional__session\" : session , \"_notional__database\" : database , } if schema is not None : for name , obj in schema . items (): safe_name = make_safe_python_name ( name ) prop = Property ( name , obj ) attrs [ safe_name ] = prop return self . metaclass ( self . name , self . bases , attrs ) __init__ ( self , name = 'CustomBase' , base = None , metaclass = None ) special Initialze the ConnectedPageFactory with the given parameters. :param name: the name of the class generated by this factory; defaults to \"CustomPage\" :param base: the class (or tuple of classes) used as the base class for types generated by this factory; defaults to None :param metaclass: the callable metaclass to use for generating new types; defaults to type Source code in notional/orm.py def __init__ ( self , name = \"CustomBase\" , base = None , metaclass = None , ): \"\"\"Initialze the `ConnectedPageFactory` with the given parameters. :param name: the name of the class generated by this factory; defaults to \"CustomPage\" :param base: the class (or tuple of classes) used as the base class for types generated by this factory; defaults to `None` :param metaclass: the callable metaclass to use for generating new types; defaults to `type` \"\"\" self . name = name if base is None : self . bases = ( ConnectedPage ,) elif isinstance ( base , tuple ): self . bases = base else : self . bases = ( base ,) if metaclass is None : self . metaclass = type else : self . metaclass = metaclass ConnectedProperty Contains the information and methods needed for a connected property. When created, this object does not have a reference to its parent object. Before this property is accessed for the first time, callers must use bind() to set the containing object at runtime. Source code in notional/orm.py class ConnectedProperty : \"\"\"Contains the information and methods needed for a connected property. When created, this object does not have a reference to its parent object. Before this property is accessed for the first time, callers must use `bind()` to set the containing object at runtime. \"\"\" def __init__ ( self , name , schema , default =... ): \"\"\"Initialize the property wrapper. :param name: the name of this property as it appears on Notional :param schema: the PropertyObject that defines the type of this property :param default: an optional parameter that will return a default value if one is not provided by the API \"\"\" if name is None or len ( name ) == 0 : raise ValueError ( \"Must provide a valid property name\" ) if schema is None : raise ValueError ( \"Invalid schema; cannot be None\" ) self . name = name self . default = default self . schema = schema self . data_type = type ( schema ) if not hasattr ( self . data_type , \"type\" ) or self . data_type . type is None : raise ValueError ( \"Invalid schema; undefined type\" ) self . type_name = self . data_type . type # this is kind of an ugly way to grab the value type from the schema type... # mostly b/c we are using internal knowledge of TypedObject.__typemap__ if self . type_name not in PropertyValue . __typemap__ : raise TypeError ( f \"Invalid schema; missing value type ' { self . type_name } '\" ) self . value_type = PropertyValue . __typemap__ [ self . type_name ] def bind ( self , obj ): \"\"\"Binds this property to the given object.\"\"\" if not isinstance ( obj , ConnectedPage ): raise TypeError ( \"Properties must be used in a ConnectedPage object\" ) # XXX should we do any additional error checking on the object? self . parent = obj self . page_data = self . parent . _notional__page self . session = self . parent . _notional__session def get ( self ): \"\"\"Return the current value of the property as a python object.\"\"\" log . debug ( \"fget :: %s [ %s ]\" , self . type_name , self . name ) # TODO raise instead? if self . page_data is None : return None try : prop = self . page_data [ self . name ] except AttributeError : if self . default == ... : raise AttributeError ( f \"Missing property: ' { self . name } '\" ) return self . default if not isinstance ( prop , self . value_type ): raise TypeError ( \"Type mismatch\" ) if hasattr ( prop , \"Value\" ): return prop . Value return prop def set ( self , value ): \"\"\"Set the property to the given value.\"\"\" log . debug ( \"fset :: %s [ %s ] => %s \" , self . type_name , self . name , type ( value )) # TODO raise instead? if self . page_data is None : return if isinstance ( value , self . value_type ): prop = value elif hasattr ( self . value_type , \"__compose__\" ): prop = self . value_type . __compose__ ( value ) else : raise TypeError ( f \"Unsupported value type for ' { self . type_name } '\" ) # update the property on the server (which will refresh the local data) self . session . pages . update ( self . page_data , ** { self . name : prop }) def delete ( self ): \"\"\"Delete the value assotiated with this property.\"\"\" # TODO raise instead? if self . page_data is None : return empty = self . value_type () self . session . pages . update ( self . page_data , ** { self . name : empty }) __init__ ( self , name , schema , default = Ellipsis ) special Initialize the property wrapper. :param name: the name of this property as it appears on Notional :param schema: the PropertyObject that defines the type of this property :param default: an optional parameter that will return a default value if one is not provided by the API Source code in notional/orm.py def __init__ ( self , name , schema , default =... ): \"\"\"Initialize the property wrapper. :param name: the name of this property as it appears on Notional :param schema: the PropertyObject that defines the type of this property :param default: an optional parameter that will return a default value if one is not provided by the API \"\"\" if name is None or len ( name ) == 0 : raise ValueError ( \"Must provide a valid property name\" ) if schema is None : raise ValueError ( \"Invalid schema; cannot be None\" ) self . name = name self . default = default self . schema = schema self . data_type = type ( schema ) if not hasattr ( self . data_type , \"type\" ) or self . data_type . type is None : raise ValueError ( \"Invalid schema; undefined type\" ) self . type_name = self . data_type . type # this is kind of an ugly way to grab the value type from the schema type... # mostly b/c we are using internal knowledge of TypedObject.__typemap__ if self . type_name not in PropertyValue . __typemap__ : raise TypeError ( f \"Invalid schema; missing value type ' { self . type_name } '\" ) self . value_type = PropertyValue . __typemap__ [ self . type_name ] bind ( self , obj ) Binds this property to the given object. Source code in notional/orm.py def bind ( self , obj ): \"\"\"Binds this property to the given object.\"\"\" if not isinstance ( obj , ConnectedPage ): raise TypeError ( \"Properties must be used in a ConnectedPage object\" ) # XXX should we do any additional error checking on the object? self . parent = obj self . page_data = self . parent . _notional__page self . session = self . parent . _notional__session delete ( self ) Delete the value assotiated with this property. Source code in notional/orm.py def delete ( self ): \"\"\"Delete the value assotiated with this property.\"\"\" # TODO raise instead? if self . page_data is None : return empty = self . value_type () self . session . pages . update ( self . page_data , ** { self . name : empty }) get ( self ) Return the current value of the property as a python object. Source code in notional/orm.py def get ( self ): \"\"\"Return the current value of the property as a python object.\"\"\" log . debug ( \"fget :: %s [ %s ]\" , self . type_name , self . name ) # TODO raise instead? if self . page_data is None : return None try : prop = self . page_data [ self . name ] except AttributeError : if self . default == ... : raise AttributeError ( f \"Missing property: ' { self . name } '\" ) return self . default if not isinstance ( prop , self . value_type ): raise TypeError ( \"Type mismatch\" ) if hasattr ( prop , \"Value\" ): return prop . Value return prop set ( self , value ) Set the property to the given value. Source code in notional/orm.py def set ( self , value ): \"\"\"Set the property to the given value.\"\"\" log . debug ( \"fset :: %s [ %s ] => %s \" , self . type_name , self . name , type ( value )) # TODO raise instead? if self . page_data is None : return if isinstance ( value , self . value_type ): prop = value elif hasattr ( self . value_type , \"__compose__\" ): prop = self . value_type . __compose__ ( value ) else : raise TypeError ( f \"Unsupported value type for ' { self . type_name } '\" ) # update the property on the server (which will refresh the local data) self . session . pages . update ( self . page_data , ** { self . name : prop }) Property ( name , schema = None , default = Ellipsis ) Define a property for a Notion Page object. Internally, this method uses a custom wrapper to manage the property methods. :param name: the Notion table property name :param data_type: the schema that defines this property (default = RichText) :param default: a default value when creating new objects Source code in notional/orm.py def Property ( name , schema = None , default =... ): \"\"\"Define a property for a Notion Page object. Internally, this method uses a custom wrapper to manage the property methods. :param name: the Notion table property name :param data_type: the schema that defines this property (default = RichText) :param default: a default value when creating new objects \"\"\" log . debug ( \"creating new Property: %s \" , name ) if schema is None : schema = RichText () elif not isinstance ( schema , PropertyObject ): raise TypeError ( \"Invalid data_type; not a PropertyObject\" ) cprop = ConnectedProperty ( name = name , schema = schema , default = default , ) def fget ( self ): \"\"\"Return the current value of the property as a python object.\"\"\" cprop . bind ( self ) return cprop . get () def fset ( self , value ): \"\"\"Set the property to the given value.\"\"\" cprop . bind ( self ) cprop . set ( value ) def fdel ( self ): \"\"\"Delete the value for this property.\"\"\" cprop . bind ( self ) cprop . delete () return property ( fget , fset , fdel ) connected_page ( session = None , source_db = None , schema = None , cls = None ) Return a base class for \"connected\" pages through the Notion API. Subclasses may then inherit from the returned class to define custom ORM types. :param session: an active Notional session where the database is hosted :param source_db: if provided, the returned class will use the ID and schema of this object to initialize the connected page :param schema: if provided, the returned class will contain properties according to the schema provided; defaults to None :param cls: the returned class will inherit from the given class, which must be a sublass of ConnectedPage ; defaults to ConnectedPage Source code in notional/orm.py def connected_page ( session = None , source_db = None , schema = None , cls = None ): \"\"\"Return a base class for \"connected\" pages through the Notion API. Subclasses may then inherit from the returned class to define custom ORM types. :param session: an active Notional session where the database is hosted :param source_db: if provided, the returned class will use the ID and schema of this object to initialize the connected page :param schema: if provided, the returned class will contain properties according to the schema provided; defaults to `None` :param cls: the returned class will inherit from the given class, which must be a sublass of `ConnectedPage`; defaults to `ConnectedPage` \"\"\" if cls is None : cls = ConnectedPage elif not issubclass ( cls , ConnectedPage ): raise ValueError ( \"'cls' must subclass ConnectedPage\" ) if source_db is None : dbid = None elif not isinstance ( source_db , Database ): raise ValueError ( \"'source_db' must be a Database\" ) else : if schema is None : schema = source_db . properties dbid = source_db . id factory = ConnectedPageFactory ( base = cls ) return factory ( session = session , database = dbid , schema = schema , ) parser Utilities for parsing other document types in Notion. These parsers provide an alternative to the \"Import\" cabilities of the Notion client and Notion Web Clipper. Perhaps that capability will be exposed to the API in the future, which would effectively render these parsers unnecessary. CsvParser ( DocumentParser ) A standard CSV parser. Contents of this parser are available as a list of page properties according to the determined schema. Specifically, this content follows the format: ``` [ { column_1_name: entry_1_column_1_data, column_2_name: entry_1_column_2_data, column_3_name: entry_1_column_3_data, ... }, { column_1_name: entry_2_column_1_data, column_2_name: entry_2_column_2_data, column_3_name: entry_2_column_3_data, ... }, ... ] ``` Source code in notional/parser.py class CsvParser ( DocumentParser ): \"\"\"A standard CSV parser. Contents of this parser are available as a list of page properties according to the determined schema. Specifically, this content follows the format: ``` [ { column_1_name: entry_1_column_1_data, column_2_name: entry_1_column_2_data, column_3_name: entry_1_column_3_data, ... }, { column_1_name: entry_2_column_1_data, column_2_name: entry_2_column_2_data, column_3_name: entry_2_column_3_data, ... }, ... ] ``` \"\"\" schema : dict def __init__ ( self , header_row = True , title_column = 0 ): \"\"\"Initialize a new `CsvParser`. :param header_row: indicates that data will have a header row (for the schema) :param title_column: set the column in data to use for page titles \"\"\" super () . __init__ () self . _has_header = header_row self . _title_index = title_column self . schema = {} self . _field_names = [] def parse ( self , data ): \"\"\"Parse the given CSV data. Upon return, the following properties will be available in the parser: `schema`: a computed schema for the supplied data `title`: the name of the CSV file being parsed (if available) `content`: a list of page properties with the tabular data \"\"\" super () . parse ( data ) if isinstance ( data , str ): data = io . StringIO ( data , newline = \"\" ) reader = csv . reader ( data ) self . _process ( reader ) def _process ( self , reader ): # build the schema based on the first row try : header = next ( reader ) except StopIteration : raise ValueError ( \"Invalid CSV: empty data\" ) if self . _has_header : self . _build_schema ( * header ) else : cols = [ str ( num ) for num in range ( len ( header ))] self . _build_schema ( * cols ) self . _build_record ( * header ) # process remaining entries for entry in reader : self . _build_record ( * entry ) def _build_schema ( self , * fields ): if fields is None or len ( fields ) < 1 : raise ValueError ( \"Invalid CSV: empty header\" ) column = 0 for field in fields : field = field . strip () while field in self . _field_names : field = f \" { field } _ { column } \" if column == self . _title_index : self . schema [ field ] = schema . Title () else : self . schema [ field ] = schema . RichText () self . _field_names . append ( field ) column += 1 def _build_record ( self , * fields ): if len ( fields ) != len ( self . _field_names ): raise ValueError ( \"Invalid CSV: incorrect number of fields in data\" ) record = {} column = 0 for col in self . _field_names : value = fields [ column ] if column == self . _title_index : record [ col ] = types . Title [ value ] else : record [ col ] = types . RichText [ value ] column += 1 self . content . append ( record ) __init__ ( self , header_row = True , title_column = 0 ) special Initialize a new CsvParser . :param header_row: indicates that data will have a header row (for the schema) :param title_column: set the column in data to use for page titles Source code in notional/parser.py def __init__ ( self , header_row = True , title_column = 0 ): \"\"\"Initialize a new `CsvParser`. :param header_row: indicates that data will have a header row (for the schema) :param title_column: set the column in data to use for page titles \"\"\" super () . __init__ () self . _has_header = header_row self . _title_index = title_column self . schema = {} self . _field_names = [] parse ( self , data ) Parse the given CSV data. Upon return, the following properties will be available in the parser: schema : a computed schema for the supplied data title : the name of the CSV file being parsed (if available) content : a list of page properties with the tabular data Source code in notional/parser.py def parse ( self , data ): \"\"\"Parse the given CSV data. Upon return, the following properties will be available in the parser: `schema`: a computed schema for the supplied data `title`: the name of the CSV file being parsed (if available) `content`: a list of page properties with the tabular data \"\"\" super () . parse ( data ) if isinstance ( data , str ): data = io . StringIO ( data , newline = \"\" ) reader = csv . reader ( data ) self . _process ( reader ) DocumentParser ( ABC ) Base class for document parsers. Source code in notional/parser.py class DocumentParser ( ABC ): \"\"\"Base class for document parsers.\"\"\" title : str content : list def __init__ ( self ): \"\"\"Initlize the document parser.\"\"\" self . title = None self . content = [] @abstractmethod def parse ( self , data ): \"\"\"Parse the given data. This method will attempt to determine a default name for the document from the data source. Subclasses should call this method when implemting `parse()` locally. \"\"\" if hasattr ( data , \"name\" ): self . title = basename ( data . name ) __init__ ( self ) special Initlize the document parser. Source code in notional/parser.py def __init__ ( self ): \"\"\"Initlize the document parser.\"\"\" self . title = None self . content = [] parse ( self , data ) Parse the given data. This method will attempt to determine a default name for the document from the data source. Subclasses should call this method when implemting parse() locally. Source code in notional/parser.py @abstractmethod def parse ( self , data ): \"\"\"Parse the given data. This method will attempt to determine a default name for the document from the data source. Subclasses should call this method when implemting `parse()` locally. \"\"\" if hasattr ( data , \"name\" ): self . title = basename ( data . name ) HtmlParser ( DocumentParser ) An HTML parser that leverages the WHATWG HTML spec. Source code in notional/parser.py class HtmlParser ( DocumentParser ): \"\"\"An HTML parser that leverages the WHATWG HTML spec.\"\"\" meta : dict def __init__ ( self , base = None ): \"\"\"Initialize an empty `HtmlParser`. :param base: the base URL for resolving relative paths \"\"\" super () . __init__ () self . _base_url = base self . meta = {} self . _current_href = None self . _current_text_style = Annotations () def parse ( self , data ): \"\"\"Parse the given HTML data. Upon return, the following properties will be available in the parser: `title`: contents of the `<title>` element if found `content`: a list of blocks containing rendered content from the HTML data `meta`: a dictionary of any `<meta>` tags that were found \"\"\" super () . parse ( data ) doc = html5lib . parse ( data , namespaceHTMLElements = False ) self . _render ( doc ) def _render ( self , elem , parent = None ): \"\"\"Render the given element as a child of `parent`. This method will look for an appropriate `render_*` method to handle the given tag name. If there is not an available method, the element will be ignored. :param elem: the ElementTree object to render :param parent: the parent block for the rendered content or `None` \"\"\" log . debug ( \"rendering element - %s :: %s \" , elem . tag , type ( parent )) if parent is None : parent = self . content if hasattr ( self , f \"_render_ { elem . tag } \" ): log . debug ( \"handler func -- _render_ %s \" , elem . tag ) pfunc = getattr ( self , f \"_render_ { elem . tag } \" ) pfunc ( elem , parent ) log . debug ( \"block complete; %d total block(s)\" , len ( self . content )) def _render_a ( self , elem , parent ): self . _current_href = elem . get ( \"href\" ) self . _process_contents ( elem , parent = parent ) self . _current_href = None def _render_b ( self , elem , parent ): self . _current_text_style . bold = True self . _process_contents ( elem , parent = parent ) self . _current_text_style . bold = False def _render_base ( self , elem , parent ): base = elem . get ( \"href\" ) if base is not None : self . _base_url = base def _render_blockquote ( self , elem , parent ): block = blocks . Quote () self . _process_contents ( elem , parent = block ) parent . append ( block ) def _render_body ( self , elem , parent ): self . _process_contents ( elem , parent = parent ) def _render_br ( self , elem , parent ): if isinstance ( parent , blocks . TextBlock ): parent . concat ( \" \\n \" ) def _render_code ( self , elem , parent ): self . _current_text_style . code = True self . _process_contents ( elem , parent = parent ) self . _current_text_style . code = False def _render_dd ( self , elem , parent ): self . _process_contents ( elem , parent = parent ) def _render_del ( self , elem , parent ): self . _current_text_style . strikethrough = True self . _process_contents ( elem , parent = parent ) self . _current_text_style . strikethrough = False def _render_div ( self , elem , parent ): self . _process_contents ( elem , parent ) def _render_dl ( self , elem , parent ): dl = blocks . Paragraph () self . _process_contents ( elem , parent = dl ) parent . append ( dl ) def _render_dt ( self , elem , parent ): self . _process_contents ( elem , parent = parent ) def _render_em ( self , elem , parent ): self . _render_i ( elem , parent ) def _render_h1 ( self , elem , parent ): h1 = blocks . Heading1 () self . _process_contents ( elem , parent = h1 ) parent . append ( h1 ) def _render_h2 ( self , elem , parent ): h2 = blocks . Heading2 () self . _process_contents ( elem , parent = h2 ) parent . append ( h2 ) def _render_h3 ( self , elem , parent ): h3 = blocks . Heading3 () self . _process_contents ( elem , parent = h3 ) parent . append ( h3 ) def _render_h4 ( self , elem , parent ): self . _render_h3 ( elem , parent ) def _render_h5 ( self , elem , parent ): self . _render_h3 ( elem , parent ) def _render_h6 ( self , elem , parent ): self . _render_h3 ( elem , parent ) def _render_head ( self , elem , parent ): self . _process_contents ( elem , parent = parent ) def _render_hgroup ( self , elem , parent ): self . _process_contents ( elem , parent = parent ) def _render_hr ( self , elem , parent ): parent . append ( blocks . Divider ()) def _render_html ( self , elem , parent ): self . _process_contents ( elem , parent = parent ) def _render_i ( self , elem , parent ): self . _current_text_style . italic = True self . _process_contents ( elem , parent = parent ) self . _current_text_style . italic = False def _render_iframe ( self , elem , parent ): src = elem . get ( \"src\" ) if src is not None : block = blocks . Embed [ src ] parent . append ( block ) def _render_img ( self , elem , parent ): src = elem . get ( \"src\" ) # TODO use self._base_url for relative paths # TODO support embedded images (data:image) as HostedFile... if src is not None : file = types . ExternalFile [ src ] img = blocks . Image ( image = file ) parent . append ( img ) def _render_ins ( self , elem , parent ): self . _render_u ( elem , parent ) def _render_kbd ( self , elem , parent ): self . _render_code ( elem , parent ) def _render_li ( self , elem , parent ): self . _process_contents ( elem , parent ) def _render_menu ( self , elem , parent ): self . _render_ul ( elem , parent ) def _render_meta ( self , elem , parent ): name = elem . get ( \"name\" ) value = elem . get ( \"content\" ) if name and value : self . meta [ name ] = value def _render_object ( self , elem , parent ): # XXX support 'data' attribute as an embed or upload? self . _process_contents ( elem , parent = parent ) def _render_ol ( self , elem , parent ): self . _process_list ( elem , parent , blocks . NumberedListItem ) def _render_p ( self , elem , parent ): para = blocks . Paragraph () self . _process_contents ( elem , parent = para ) parent . append ( para ) def _render_pre ( self , elem , parent ): block = blocks . Code () self . _process_contents ( elem , parent = block ) parent . append ( block ) def _render_s ( self , elem , parent ): self . _render_del ( elem , parent ) def _render_samp ( self , elem , parent ): self . _render_code ( elem , parent ) def _render_span ( self , elem , parent ): self . _process_contents ( elem , parent = parent ) def _render_strike ( self , elem , parent ): self . _render_del ( elem , parent ) def _render_strong ( self , elem , parent ): self . _render_b ( elem , parent ) def _render_table ( self , elem , parent ): table = blocks . Table () self . _process_contents ( elem , parent = table ) if table . Width > 0 : parent . append ( table ) def _render_tbody ( self , elem , parent ): self . _process_contents ( elem , parent ) def _render_td ( self , elem , parent ): if not isinstance ( parent , blocks . TableRow ): raise TypeError ( \"Invalid parent for <td>\" ) if elem_has_text ( elem ): self . _process_contents ( elem , parent = parent ) else : self . _append_text ( \"\" , parent ) def _render_tfoot ( self , elem , parent ): self . _process_contents ( elem , parent = parent ) def _render_th ( self , elem , parent ): self . _render_td ( elem , parent = parent ) def _render_thead ( self , elem , parent ): if not isinstance ( parent , blocks . Table ): raise TypeError ( \"Invalid parent for <thead>\" ) parent . table . has_column_header = True self . _process_contents ( elem , parent = parent ) def _render_title ( self , elem , parent ): self . title = gather_text ( elem ) def _render_tr ( self , elem , parent ): if not isinstance ( parent , blocks . Table ): raise TypeError ( \"Invalid parent for <tr>\" ) row = blocks . TableRow () for td in elem . findall ( \"td\" ): self . _render ( td , parent = row ) parent . append ( row ) def _render_tt ( self , elem , parent ): self . _render_pre ( elem , parent = parent ) def _render_u ( self , elem , parent ): self . _current_text_style . underline = True self . _process_contents ( elem , parent = parent ) self . _current_text_style . underline = False def _render_ul ( self , elem , parent ): self . _process_list ( elem , parent , blocks . BulletedListItem ) def _render_var ( self , elem , parent ): self . _render_code ( elem , parent = parent ) def _append_text ( self , text , parent ): \"\"\"Append text to the given parent using current style and link information. If the parent does not support text children, the text will be ignored. When appropriate, whitespace in the text will be removed. \"\"\" log . debug ( \"appending text :: %s => ' %s '\" , parent . type , truncate ( text , 10 )) if not isinstance ( parent , blocks . Code ): text = condense_text ( text ) obj = TextObject [ text , self . _current_href , self . _current_text_style ] if isinstance ( parent , blocks . TextBlock ): if obj is not None : parent . concat ( obj ) elif isinstance ( parent , blocks . TableRow ): parent . append ( obj ) def _process_contents ( self , elem , parent ): \"\"\"Process the contents of the given element as children of `parent`. This will process all children of the element, including text and nodes. \"\"\" log . debug ( \"processing contents :: %s %s \" , elem . tag , type ( parent )) # empty elements don't need text processing... if not elem_has_text ( elem , with_children = False ): has_text = False # TextBlock's can hold text directly... elif isinstance ( parent , blocks . TextBlock ): has_text = True # so can TableRow's... elif isinstance ( parent , blocks . TableRow ): has_text = True # otherwise, we need a new parent to hold text... else : has_text = True new_parent = blocks . Paragraph () parent . append ( new_parent ) parent = new_parent if has_text : self . _append_text ( elem . text , parent ) for child in elem : self . _render ( child , parent ) if has_text : self . _append_text ( child . tail , parent ) if isinstance ( parent , blocks . TextBlock ): strip_text_block ( parent ) def _process_list ( self , elem , parent , kind ): \"\"\"Process contents of the given element as a list. :param elem: the element to process :param parent: the parent for list items and nested lists :param kind: a class used to render `<li>` tags \"\"\" list_parent = parent for child in elem : if child . tag == \"li\" : list_parent = kind () self . _render ( child , parent = list_parent ) parent . append ( list_parent ) else : self . _render ( child , list_parent ) def _process_img_data ( self , elem ): import base64 import tempfile log . debug ( \"processing image\" ) # TODO this probably needs more error handling and better flow img_src = elem [ \"src\" ] m = img_data_re . match ( img_src ) if m is None : raise ValueError ( \"Image data missing\" ) img_type = m . groups ()[ 0 ] img_data_enc = m . groups ()[ 1 ] img_data_str = m . groups ()[ 2 ] log . debug ( \"decoding embedded image: %s [ %s ]\" , img_type , img_data_enc ) if img_data_enc == \"base64\" : log . debug ( \"decoding base64 image: %d bytes\" , len ( img_data_str )) img_data_b64 = img_data_str . encode ( \"ascii\" ) img_data = base64 . b64decode ( img_data_b64 ) else : raise ValueError ( f \"Unsupported img encoding: { img_data_enc } \" ) log . debug ( \"preparing %d bytes for image upload\" , len ( img_data )) with tempfile . NamedTemporaryFile ( suffix = f \". { img_type } \" ) as fp : log . debug ( \"using temporary file: %s \" , fp . name ) fp . write ( img_data ) # TODO upload the image to Notion __init__ ( self , base = None ) special Initialize an empty HtmlParser . :param base: the base URL for resolving relative paths Source code in notional/parser.py def __init__ ( self , base = None ): \"\"\"Initialize an empty `HtmlParser`. :param base: the base URL for resolving relative paths \"\"\" super () . __init__ () self . _base_url = base self . meta = {} self . _current_href = None self . _current_text_style = Annotations () parse ( self , data ) Parse the given HTML data. Upon return, the following properties will be available in the parser: title : contents of the <title> element if found content : a list of blocks containing rendered content from the HTML data meta : a dictionary of any <meta> tags that were found Source code in notional/parser.py def parse ( self , data ): \"\"\"Parse the given HTML data. Upon return, the following properties will be available in the parser: `title`: contents of the `<title>` element if found `content`: a list of blocks containing rendered content from the HTML data `meta`: a dictionary of any `<meta>` tags that were found \"\"\" super () . parse ( data ) doc = html5lib . parse ( data , namespaceHTMLElements = False ) self . _render ( doc ) condense_text ( text ) Collapse contiguous whitespace from the given text. Source code in notional/parser.py def condense_text ( text ): \"\"\"Collapse contiguous whitespace from the given text.\"\"\" if text is None : return None return re . sub ( r \"\\s+\" , \" \" , text , flags = re . MULTILINE ) elem_has_text ( elem , with_children = True ) Determine if the element has any visible text. :param elem: the element to examine :param with_children: whether to include children nodes in the search Source code in notional/parser.py def elem_has_text ( elem , with_children = True ): \"\"\"Determine if the element has any visible text. :param elem: the element to examine :param with_children: whether to include children nodes in the search \"\"\" # first, check the direct text of the element... if elem . text is not None and not elem . text . isspace (): return True # now, we need to check the tail of each child... for child in elem : if with_children and elem_has_text ( child ): return True if child . tail is None : continue if not child . tail . isspace (): return True return False gather_text ( elem ) Return all text from the element and children. Source code in notional/parser.py def gather_text ( elem ): \"\"\"Return all text from the element and children.\"\"\" text = \"\" . join ( elem . itertext ()) return normalize_text ( text ) normalize_text ( text ) Remove extra whitespace from the given text. Source code in notional/parser.py def normalize_text ( text ): \"\"\"Remove extra whitespace from the given text.\"\"\" if text is None : return None text = text . strip () return condense_text ( text ) strip_text_block ( block ) Remove leading and trailing whitespace from text in the given block. Source code in notional/parser.py def strip_text_block ( block ): \"\"\"Remove leading and trailing whitespace from text in the given block.\"\"\" if not isinstance ( block , blocks . TextBlock ): return if isinstance ( block , blocks . Code ): return block_text = block . __text__ if block_text is not None and len ( block_text ) > 0 : lstrip ( block_text [ 0 ]) rstrip ( block_text [ - 1 ]) query Provides an interactive query builder for Notion databases. CheckboxCondition ( DataObject ) pydantic-model Represents checkbox criteria in Notion. Source code in notional/query.py class CheckboxCondition ( DataObject ): \"\"\"Represents checkbox criteria in Notion.\"\"\" equals : Optional [ bool ] = None does_not_equal : Optional [ bool ] = None CompoundFilter ( QueryFilter ) pydantic-model Represents a compound filter in Notion. Source code in notional/query.py class CompoundFilter ( QueryFilter ): \"\"\"Represents a compound filter in Notion.\"\"\" class Config : \"\"\"Pydantic configuration class to support keyword fields.\"\"\" allow_population_by_field_name = True and_ : Optional [ List [ QueryFilter ]] = Field ( None , alias = \"and\" ) or_ : Optional [ List [ QueryFilter ]] = Field ( None , alias = \"or\" ) Config Pydantic configuration class to support keyword fields. Source code in notional/query.py class Config : \"\"\"Pydantic configuration class to support keyword fields.\"\"\" allow_population_by_field_name = True CreatedTimeFilter ( TimestampFilter ) pydantic-model Represents a created_time filter in Notion. Source code in notional/query.py class CreatedTimeFilter ( TimestampFilter ): \"\"\"Represents a created_time filter in Notion.\"\"\" timestamp : TimestampKind = TimestampKind . CREATED_TIME created_time : DateCondition @classmethod def create ( cls , constraint ): \"\"\"Create a new `CreatedTimeFilter` using the given constraint.\"\"\" return CreatedTimeFilter ( created_time = constraint ) create ( constraint ) classmethod Create a new CreatedTimeFilter using the given constraint. Source code in notional/query.py @classmethod def create ( cls , constraint ): \"\"\"Create a new `CreatedTimeFilter` using the given constraint.\"\"\" return CreatedTimeFilter ( created_time = constraint ) DateCondition ( DataObject ) pydantic-model Represents date criteria in Notion. Source code in notional/query.py class DateCondition ( DataObject ): \"\"\"Represents date criteria in Notion.\"\"\" equals : Optional [ Union [ date , datetime ]] = None before : Optional [ Union [ date , datetime ]] = None after : Optional [ Union [ date , datetime ]] = None on_or_before : Optional [ Union [ date , datetime ]] = None on_or_after : Optional [ Union [ date , datetime ]] = None is_empty : Optional [ bool ] = None is_not_empty : Optional [ bool ] = None past_week : Optional [ Any ] = None past_month : Optional [ Any ] = None past_year : Optional [ Any ] = None next_week : Optional [ Any ] = None next_month : Optional [ Any ] = None next_year : Optional [ Any ] = None FilesCondition ( DataObject ) pydantic-model Represents files criteria in Notion. Source code in notional/query.py class FilesCondition ( DataObject ): \"\"\"Represents files criteria in Notion.\"\"\" is_empty : Optional [ bool ] = None is_not_empty : Optional [ bool ] = None FormulaCondition ( DataObject ) pydantic-model Represents formula criteria in Notion. Source code in notional/query.py class FormulaCondition ( DataObject ): \"\"\"Represents formula criteria in Notion.\"\"\" text : Optional [ TextCondition ] = None checkbox : Optional [ CheckboxCondition ] = None number : Optional [ NumberCondition ] = None date : Optional [ DateCondition ] = None LastEditedTimeFilter ( TimestampFilter ) pydantic-model Represents a last_edited_time filter in Notion. Source code in notional/query.py class LastEditedTimeFilter ( TimestampFilter ): \"\"\"Represents a last_edited_time filter in Notion.\"\"\" timestamp : TimestampKind = TimestampKind . LAST_EDITED_TIME last_edited_time : DateCondition @classmethod def create ( cls , constraint ): \"\"\"Create a new `LastEditedTimeFilter` using the given constraint.\"\"\" return LastEditedTimeFilter ( last_edited_time = constraint ) create ( constraint ) classmethod Create a new LastEditedTimeFilter using the given constraint. Source code in notional/query.py @classmethod def create ( cls , constraint ): \"\"\"Create a new `LastEditedTimeFilter` using the given constraint.\"\"\" return LastEditedTimeFilter ( last_edited_time = constraint ) MultiSelectCondition ( DataObject ) pydantic-model Represents a multi_select criteria in Notion. Source code in notional/query.py class MultiSelectCondition ( DataObject ): \"\"\"Represents a multi_select criteria in Notion.\"\"\" contains : Optional [ str ] = None does_not_contains : Optional [ str ] = None is_empty : Optional [ bool ] = None is_not_empty : Optional [ bool ] = None NumberCondition ( DataObject ) pydantic-model Represents number criteria in Notion. Source code in notional/query.py class NumberCondition ( DataObject ): \"\"\"Represents number criteria in Notion.\"\"\" equals : Optional [ Union [ float , int ]] = None does_not_equal : Optional [ Union [ float , int ]] = None greater_than : Optional [ Union [ float , int ]] = None less_than : Optional [ Union [ float , int ]] = None greater_than_or_equal_to : Optional [ Union [ float , int ]] = None less_than_or_equal_to : Optional [ Union [ float , int ]] = None is_empty : Optional [ bool ] = None is_not_empty : Optional [ bool ] = None PeopleCondition ( DataObject ) pydantic-model Represents people criteria in Notion. Source code in notional/query.py class PeopleCondition ( DataObject ): \"\"\"Represents people criteria in Notion.\"\"\" contains : Optional [ UUID ] = None does_not_contain : Optional [ UUID ] = None is_empty : Optional [ bool ] = None is_not_empty : Optional [ bool ] = None PropertyFilter ( QueryFilter ) pydantic-model Represents a database property filter in Notion. Source code in notional/query.py class PropertyFilter ( QueryFilter ): \"\"\"Represents a database property filter in Notion.\"\"\" property : str rich_text : Optional [ TextCondition ] = None phone_number : Optional [ TextCondition ] = None number : Optional [ NumberCondition ] = None checkbox : Optional [ CheckboxCondition ] = None select : Optional [ SelectCondition ] = None multi_select : Optional [ MultiSelectCondition ] = None date : Optional [ DateCondition ] = None people : Optional [ PeopleCondition ] = None files : Optional [ FilesCondition ] = None relation : Optional [ RelationCondition ] = None formula : Optional [ FormulaCondition ] = None PropertySort ( DataObject ) pydantic-model Represents a sort instruction in Notion. Source code in notional/query.py class PropertySort ( DataObject ): \"\"\"Represents a sort instruction in Notion.\"\"\" property : Optional [ str ] = None timestamp : Optional [ TimestampKind ] = None direction : Optional [ SortDirection ] = None Query ( DataObject ) pydantic-model Represents a query object in Notion. Source code in notional/query.py class Query ( DataObject ): \"\"\"Represents a query object in Notion.\"\"\" sorts : Optional [ List [ PropertySort ]] = None filter : Optional [ QueryFilter ] = None start_cursor : Optional [ UUID ] = None page_size : int = 100 @validator ( \"page_size\" ) def valid_page_size ( cls , value ): \"\"\"Validate that the given page size meets the Notion API requirements.\"\"\" assert value > 0 , \"size must be greater than zero\" assert value <= 100 , \"size must be less than or equal to 100\" return value valid_page_size ( value ) classmethod Validate that the given page size meets the Notion API requirements. Source code in notional/query.py @validator ( \"page_size\" ) def valid_page_size ( cls , value ): \"\"\"Validate that the given page size meets the Notion API requirements.\"\"\" assert value > 0 , \"size must be greater than zero\" assert value <= 100 , \"size must be less than or equal to 100\" return value QueryBuilder A query builder for the Notion API. :param endpoint: the session endpoint used to execute the query :param cls: an optional DataObject class for parsing results :param params: optional params that will be passed to the query Source code in notional/query.py class QueryBuilder : \"\"\"A query builder for the Notion API. :param endpoint: the session endpoint used to execute the query :param cls: an optional DataObject class for parsing results :param params: optional params that will be passed to the query \"\"\" def __init__ ( self , endpoint , cls = None , ** params ): \"\"\"Initialize a new `QueryBuilder` for the given endpoint.\"\"\" self . endpoint = endpoint self . params = params self . cls = cls self . query = Query () def filter ( self , filter = None , ** kwargs ): \"\"\"Add the given filter to the query.\"\"\" if filter is None : if \"property\" in kwargs : filter = PropertyFilter . parse_obj ( kwargs ) elif \"timestamp\" in kwargs and kwargs [ \"timestamp\" ] == \"created_time\" : filter = CreatedTimeFilter . parse_obj ( kwargs ) elif \"timestamp\" in kwargs and kwargs [ \"timestamp\" ] == \"last_edited_time\" : filter = LastEditedTimeFilter . parse_obj ( kwargs ) else : raise ValueError ( \"unrecognized filter\" ) elif not isinstance ( filter , QueryFilter ): raise ValueError ( \"filter must be of type QueryFilter\" ) # use CompoundFilter when necessary... if self . query . filter is None : self . query . filter = filter elif isinstance ( self . query . filter , CompoundFilter ): self . query . filter . and_ . append ( filter ) else : old_filter = self . query . filter self . query . filter = CompoundFilter ( and_ = [ old_filter , filter ]) return self def sort ( self , sort = None , ** kwargs ): \"\"\"Add the given sort elements to the query.\"\"\" # XXX should this support ORM properties also? # e.g. - query.sort(property=Task.Title) # but users won't always use ORM for queries... if sort is None : sort = PropertySort ( ** kwargs ) elif not isinstance ( filter , PropertySort ): raise ValueError ( \"sort must be of type PropertySort\" ) # use multiple sorts when necessary if self . query . sorts is None : self . query . sorts = [ sort ] else : self . query . sorts . append ( sort ) return self def start_at ( self , page_id ): \"\"\"Set the start cursor to a specific page ID.\"\"\" self . query . start_cursor = page_id return self def limit ( self , page_size ): \"\"\"Limit the number of results to the given page size.\"\"\" self . query . page_size = page_size return self def execute ( self ): \"\"\"Execute the current query and return an iterator for the results.\"\"\" if self . endpoint is None : raise ValueError ( \"cannot execute query; no endpoint provided\" ) log . debug ( \"executing query - %s \" , self . query ) query = self . query . to_api () if self . params : query . update ( self . params ) exec = EndpointIterator ( endpoint = self . endpoint , ** query ) return ResultSet ( exec = exec , cls = self . cls ) def first ( self ): \"\"\"Execute the current query and return the first result only.\"\"\" try : return next ( self . execute ()) except StopIteration : log . debug ( \"iterator returned empty result set\" ) return None __init__ ( self , endpoint , cls = None , ** params ) special Initialize a new QueryBuilder for the given endpoint. Source code in notional/query.py def __init__ ( self , endpoint , cls = None , ** params ): \"\"\"Initialize a new `QueryBuilder` for the given endpoint.\"\"\" self . endpoint = endpoint self . params = params self . cls = cls self . query = Query () execute ( self ) Execute the current query and return an iterator for the results. Source code in notional/query.py def execute ( self ): \"\"\"Execute the current query and return an iterator for the results.\"\"\" if self . endpoint is None : raise ValueError ( \"cannot execute query; no endpoint provided\" ) log . debug ( \"executing query - %s \" , self . query ) query = self . query . to_api () if self . params : query . update ( self . params ) exec = EndpointIterator ( endpoint = self . endpoint , ** query ) return ResultSet ( exec = exec , cls = self . cls ) filter ( self , filter = None , ** kwargs ) Add the given filter to the query. Source code in notional/query.py def filter ( self , filter = None , ** kwargs ): \"\"\"Add the given filter to the query.\"\"\" if filter is None : if \"property\" in kwargs : filter = PropertyFilter . parse_obj ( kwargs ) elif \"timestamp\" in kwargs and kwargs [ \"timestamp\" ] == \"created_time\" : filter = CreatedTimeFilter . parse_obj ( kwargs ) elif \"timestamp\" in kwargs and kwargs [ \"timestamp\" ] == \"last_edited_time\" : filter = LastEditedTimeFilter . parse_obj ( kwargs ) else : raise ValueError ( \"unrecognized filter\" ) elif not isinstance ( filter , QueryFilter ): raise ValueError ( \"filter must be of type QueryFilter\" ) # use CompoundFilter when necessary... if self . query . filter is None : self . query . filter = filter elif isinstance ( self . query . filter , CompoundFilter ): self . query . filter . and_ . append ( filter ) else : old_filter = self . query . filter self . query . filter = CompoundFilter ( and_ = [ old_filter , filter ]) return self first ( self ) Execute the current query and return the first result only. Source code in notional/query.py def first ( self ): \"\"\"Execute the current query and return the first result only.\"\"\" try : return next ( self . execute ()) except StopIteration : log . debug ( \"iterator returned empty result set\" ) return None limit ( self , page_size ) Limit the number of results to the given page size. Source code in notional/query.py def limit ( self , page_size ): \"\"\"Limit the number of results to the given page size.\"\"\" self . query . page_size = page_size return self sort ( self , sort = None , ** kwargs ) Add the given sort elements to the query. Source code in notional/query.py def sort ( self , sort = None , ** kwargs ): \"\"\"Add the given sort elements to the query.\"\"\" # XXX should this support ORM properties also? # e.g. - query.sort(property=Task.Title) # but users won't always use ORM for queries... if sort is None : sort = PropertySort ( ** kwargs ) elif not isinstance ( filter , PropertySort ): raise ValueError ( \"sort must be of type PropertySort\" ) # use multiple sorts when necessary if self . query . sorts is None : self . query . sorts = [ sort ] else : self . query . sorts . append ( sort ) return self start_at ( self , page_id ) Set the start cursor to a specific page ID. Source code in notional/query.py def start_at ( self , page_id ): \"\"\"Set the start cursor to a specific page ID.\"\"\" self . query . start_cursor = page_id return self QueryFilter ( DataObject ) pydantic-model Base class for query filters. Source code in notional/query.py class QueryFilter ( DataObject ): \"\"\"Base class for query filters.\"\"\" RelationCondition ( DataObject ) pydantic-model Represents relation criteria in Notion. Source code in notional/query.py class RelationCondition ( DataObject ): \"\"\"Represents relation criteria in Notion.\"\"\" contains : Optional [ UUID ] = None does_not_contain : Optional [ UUID ] = None is_empty : Optional [ bool ] = None is_not_empty : Optional [ bool ] = None ResultSet A result for a specific query. Source code in notional/query.py class ResultSet : \"\"\"A result for a specific query.\"\"\" def __init__ ( self , exec , cls = None ): \"\"\"Initialize a new `ResultSet`.\"\"\" self . source = exec self . cls = cls def __iter__ ( self ): \"\"\"Return an iterator for this `ResultSet`.\"\"\" return self def __next__ ( self ): \"\"\"Return the next item from this `ResultSet`.\"\"\" item = next ( self . source ) if self . cls is not None : item = self . cls . parse_obj ( item ) elif \"object\" in item : if item [ \"object\" ] == \"page\" : item = Page . parse_obj ( item ) elif item [ \"object\" ] == \"database\" : item = Database . parse_obj ( item ) elif item [ \"object\" ] == \"block\" : item = Block . parse_obj ( item ) else : item = Record . parse_obj ( item ) return item __init__ ( self , exec , cls = None ) special Initialize a new ResultSet . Source code in notional/query.py def __init__ ( self , exec , cls = None ): \"\"\"Initialize a new `ResultSet`.\"\"\" self . source = exec self . cls = cls __iter__ ( self ) special Return an iterator for this ResultSet . Source code in notional/query.py def __iter__ ( self ): \"\"\"Return an iterator for this `ResultSet`.\"\"\" return self __next__ ( self ) special Return the next item from this ResultSet . Source code in notional/query.py def __next__ ( self ): \"\"\"Return the next item from this `ResultSet`.\"\"\" item = next ( self . source ) if self . cls is not None : item = self . cls . parse_obj ( item ) elif \"object\" in item : if item [ \"object\" ] == \"page\" : item = Page . parse_obj ( item ) elif item [ \"object\" ] == \"database\" : item = Database . parse_obj ( item ) elif item [ \"object\" ] == \"block\" : item = Block . parse_obj ( item ) else : item = Record . parse_obj ( item ) return item SelectCondition ( DataObject ) pydantic-model Represents select criteria in Notion. Source code in notional/query.py class SelectCondition ( DataObject ): \"\"\"Represents select criteria in Notion.\"\"\" equals : Optional [ str ] = None does_not_equal : Optional [ str ] = None is_empty : Optional [ bool ] = None is_not_empty : Optional [ bool ] = None SortDirection ( str , Enum ) Sort direction options. Source code in notional/query.py class SortDirection ( str , Enum ): \"\"\"Sort direction options.\"\"\" ASCENDING = \"ascending\" DESCENDING = \"descending\" TextCondition ( DataObject ) pydantic-model Represents text criteria in Notion. Source code in notional/query.py class TextCondition ( DataObject ): \"\"\"Represents text criteria in Notion.\"\"\" equals : Optional [ str ] = None does_not_equal : Optional [ str ] = None contains : Optional [ str ] = None does_not_contain : Optional [ str ] = None starts_with : Optional [ str ] = None ends_with : Optional [ str ] = None is_empty : Optional [ bool ] = None is_not_empty : Optional [ bool ] = None TimestampFilter ( QueryFilter ) pydantic-model Represents a timestamp filter in Notion. Source code in notional/query.py class TimestampFilter ( QueryFilter ): \"\"\"Represents a timestamp filter in Notion.\"\"\" timestamp : TimestampKind @classmethod def create ( cls , kind , constraint ): \"\"\"Create a new `TimeStampFilter` using the given constraint.\"\"\" if kind == TimestampKind . CREATED_TIME : return CreatedTimeFilter . create ( constraint ) if kind == TimestampKind . LAST_EDITED_TIME : return LastEditedTimeFilter . create ( constraint ) raise ValueError ( \"Unsupported kind for timestamp\" ) create ( kind , constraint ) classmethod Create a new TimeStampFilter using the given constraint. Source code in notional/query.py @classmethod def create ( cls , kind , constraint ): \"\"\"Create a new `TimeStampFilter` using the given constraint.\"\"\" if kind == TimestampKind . CREATED_TIME : return CreatedTimeFilter . create ( constraint ) if kind == TimestampKind . LAST_EDITED_TIME : return LastEditedTimeFilter . create ( constraint ) raise ValueError ( \"Unsupported kind for timestamp\" ) TimestampKind ( str , Enum ) Possible timestamp types. Source code in notional/query.py class TimestampKind ( str , Enum ): \"\"\"Possible timestamp types.\"\"\" CREATED_TIME = \"created_time\" LAST_EDITED_TIME = \"last_edited_time\" get_target_id ( target ) Examine the given target and returns the appropriate ID as a string. Source code in notional/query.py def get_target_id ( target ): \"\"\"Examine the given target and returns the appropriate ID as a string.\"\"\" if isinstance ( target , str ): return target if isinstance ( target , UUID ): return target . hex if isinstance ( target , Record ): return target . id . hex if isinstance ( target , ParentRef ): return target () . hex if isclass ( target ) and issubclass ( target , ConnectedPage ): return target . _notional__database raise ValueError ( \"unsupported query target\" ) records Wrapper for Notion API data types. These objects provide both access to the primitive data structure returned by the API as well as higher-level access methods. In general, attributes in lower case represent the primitive data structure, where capitalized attributes provide higher-level access. BlockRef ( ParentRef ) pydantic-model Reference a block. Source code in notional/records.py class BlockRef ( ParentRef , type = \"block_id\" ): \"\"\"Reference a block.\"\"\" block_id : UUID Database ( Record ) pydantic-model A database record type. Source code in notional/records.py class Database ( Record , object = \"database\" ): \"\"\"A database record type.\"\"\" title : List [ RichTextObject ] = None url : str = None parent : ParentRef = None icon : Optional [ Union [ FileObject , EmojiObject ]] = None cover : Optional [ FileObject ] = None properties : Dict [ str , PropertyObject ] = {} @property def Title ( self ): \"\"\"Return the title of this database as plain text.\"\"\" if self . title is None or len ( self . title ) == 0 : return None return plain_text ( * self . title ) Title property readonly Return the title of this database as plain text. DatabaseRef ( ParentRef ) pydantic-model Reference a database. Source code in notional/records.py class DatabaseRef ( ParentRef , type = \"database_id\" ): \"\"\"Reference a database.\"\"\" database_id : UUID Page ( Record ) pydantic-model A standard Notion page object. Source code in notional/records.py class Page ( Record , object = \"page\" ): \"\"\"A standard Notion page object.\"\"\" url : str = None parent : ParentRef = None icon : Optional [ Union [ FileObject , EmojiObject ]] = None cover : Optional [ FileObject ] = None properties : Dict [ str , PropertyValue ] = {} def __getitem__ ( self , name ): \"\"\"Indexer for the given property name. :param name: the name of the property to get from the internal properties \"\"\" log . debug ( \"get property :: { %s } [ %s ]\" , self . id , name ) if self . properties is None : raise AttributeError ( \"No properties in Page\" ) prop = self . properties . get ( name ) if prop is None : raise AttributeError ( f \"No such property: { name } \" ) return prop def __setitem__ ( self , name , value ): \"\"\"Set the object data for the given property. If `value` is `None`, the property data will be deleted from the page. This does not affect the schema of the page, only the contents of the property. :param name: the name of the property to set in the internal properties :param prop: the PropertyValue for the named property :param value: the new value for the given property \"\"\" log . debug ( \"set property :: { %s } [ %s ] => %s \" , self . id , name , value ) if value is None : self . properties . pop ( name , None ) elif not isinstance ( value , PropertyValue ): raise ValueError ( f \"Unable to set { name } :: unsupported value type\" ) else : self . properties [ name ] = value @property def Title ( self ): \"\"\"Return the title of this page as a string. The title of a page is stored in its properties. This method will examine the page properties, looking for the appropriate `title` entry and return as a string. \"\"\" if self . properties is None or len ( self . properties ) == 0 : return None for prop in self . properties . values (): if prop . id == \"title\" : return prop . Value or None return None Title property readonly Return the title of this page as a string. The title of a page is stored in its properties. This method will examine the page properties, looking for the appropriate title entry and return as a string. __getitem__ ( self , name ) special Indexer for the given property name. :param name: the name of the property to get from the internal properties Source code in notional/records.py def __getitem__ ( self , name ): \"\"\"Indexer for the given property name. :param name: the name of the property to get from the internal properties \"\"\" log . debug ( \"get property :: { %s } [ %s ]\" , self . id , name ) if self . properties is None : raise AttributeError ( \"No properties in Page\" ) prop = self . properties . get ( name ) if prop is None : raise AttributeError ( f \"No such property: { name } \" ) return prop __setitem__ ( self , name , value ) special Set the object data for the given property. If value is None , the property data will be deleted from the page. This does not affect the schema of the page, only the contents of the property. :param name: the name of the property to set in the internal properties :param prop: the PropertyValue for the named property :param value: the new value for the given property Source code in notional/records.py def __setitem__ ( self , name , value ): \"\"\"Set the object data for the given property. If `value` is `None`, the property data will be deleted from the page. This does not affect the schema of the page, only the contents of the property. :param name: the name of the property to set in the internal properties :param prop: the PropertyValue for the named property :param value: the new value for the given property \"\"\" log . debug ( \"set property :: { %s } [ %s ] => %s \" , self . id , name , value ) if value is None : self . properties . pop ( name , None ) elif not isinstance ( value , PropertyValue ): raise ValueError ( f \"Unable to set { name } :: unsupported value type\" ) else : self . properties [ name ] = value PageRef ( ParentRef ) pydantic-model Reference a page. Source code in notional/records.py class PageRef ( ParentRef , type = \"page_id\" ): \"\"\"Reference a page.\"\"\" page_id : UUID ParentRef ( TypedObject ) pydantic-model Reference another block. Source code in notional/records.py class ParentRef ( TypedObject ): \"\"\"Reference another block.\"\"\" # XXX Notion does not handle parent references consistently in the API... # in some cases, the `type` is accepted and in others it is not. eventually # these should all by TypedObject's with the appropriate fields @classmethod def __compose__ ( cls , record ): \"\"\"Return the correct parent ID based on the object type.\"\"\" if isinstance ( record , ParentRef ): return record if isinstance ( record , Page ): return PageRef ( page_id = record . id ) if isinstance ( record , Database ): return DatabaseRef ( database_id = record . id ) raise ValueError ( \"Unrecognized 'parent' attribute\" ) __compose__ ( record ) classmethod special Return the correct parent ID based on the object type. Source code in notional/records.py @classmethod def __compose__ ( cls , record ): \"\"\"Return the correct parent ID based on the object type.\"\"\" if isinstance ( record , ParentRef ): return record if isinstance ( record , Page ): return PageRef ( page_id = record . id ) if isinstance ( record , Database ): return DatabaseRef ( database_id = record . id ) raise ValueError ( \"Unrecognized 'parent' attribute\" ) Record ( NamedObject ) pydantic-model The base type for Notion API records. Source code in notional/records.py class Record ( NamedObject ): \"\"\"The base type for Notion API records.\"\"\" id : UUID = None created_time : datetime = None last_edited_time : datetime = None has_children : bool = False archived : bool = False WorkspaceParent ( ParentRef ) pydantic-model Reference the workspace. Source code in notional/records.py class WorkspaceParent ( ParentRef , type = \"workspace\" ): \"\"\"Reference the workspace.\"\"\" workspace : bool = True schema Objects representing a database schema. Checkbox ( PropertyObject ) pydantic-model Defines the checkbox configuration for a database property. Source code in notional/schema.py class Checkbox ( PropertyObject , type = \"checkbox\" ): \"\"\"Defines the checkbox configuration for a database property.\"\"\" checkbox : Any = {} CreatedBy ( PropertyObject ) pydantic-model Defines the created-by configuration for a database property. Source code in notional/schema.py class CreatedBy ( PropertyObject , type = \"created_by\" ): \"\"\"Defines the created-by configuration for a database property.\"\"\" created_by : Any = {} CreatedTime ( PropertyObject ) pydantic-model Defines the created-time configuration for a database property. Source code in notional/schema.py class CreatedTime ( PropertyObject , type = \"created_time\" ): \"\"\"Defines the created-time configuration for a database property.\"\"\" created_time : Any = {} Date ( PropertyObject ) pydantic-model Defines the date configuration for a database property. Source code in notional/schema.py class Date ( PropertyObject , type = \"date\" ): \"\"\"Defines the date configuration for a database property.\"\"\" date : Any = {} Email ( PropertyObject ) pydantic-model Defines the email configuration for a database property. Source code in notional/schema.py class Email ( PropertyObject , type = \"email\" ): \"\"\"Defines the email configuration for a database property.\"\"\" email : Any = {} Files ( PropertyObject ) pydantic-model Defines the files configuration for a database property. Source code in notional/schema.py class Files ( PropertyObject , type = \"files\" ): \"\"\"Defines the files configuration for a database property.\"\"\" files : Any = {} Formula ( PropertyObject ) pydantic-model Defines the formula configuration for a database property. Source code in notional/schema.py class Formula ( PropertyObject , type = \"formula\" ): \"\"\"Defines the formula configuration for a database property.\"\"\" class _NestedData ( NestedObject ): expression : str = None formula : _NestedData = _NestedData () Function ( str , Enum ) Standard aggregation functions. Source code in notional/schema.py class Function ( str , Enum ): \"\"\"Standard aggregation functions.\"\"\" COUNT_ALL = \"count_all\" COUNT_VALUES = \"count_values\" COUNT_UNIQUE_VALUES = \"count_unique_values\" COUNT_EMPTY = \"count_empty\" COUNT_NOT_EMPTY = \"count_not_empty\" PERCENT_EMPTY = \"percent_empty\" PERCENT_NOT_EMPTY = \"percent_not_empty\" AVERAGE = \"average\" MIN = \"min\" MAX = \"max\" MEDIAN = \"median\" RANGE = \"range\" SUM = \"sum\" EARLIEST_DATE = \"earliest_date\" LATEST_DATE = \"latest_date\" SHOW_ORIGINAL = \"show_original\" LastEditedBy ( PropertyObject ) pydantic-model Defines the last-edited-by configuration for a database property. Source code in notional/schema.py class LastEditedBy ( PropertyObject , type = \"last_edited_by\" ): \"\"\"Defines the last-edited-by configuration for a database property.\"\"\" last_edited_by : Any = {} LastEditedTime ( PropertyObject ) pydantic-model Defines the last-edited-time configuration for a database property. Source code in notional/schema.py class LastEditedTime ( PropertyObject , type = \"last_edited_time\" ): \"\"\"Defines the last-edited-time configuration for a database property.\"\"\" last_edited_time : Any = {} MultiSelect ( PropertyObject ) pydantic-model Defines the multi-select configuration for a database property. Source code in notional/schema.py class MultiSelect ( PropertyObject , type = \"multi_select\" ): \"\"\"Defines the multi-select configuration for a database property.\"\"\" class _NestedData ( NestedObject ): options : List [ SelectOption ] = [] multi_select : _NestedData = _NestedData () Number ( PropertyObject ) pydantic-model Defines the number configuration for a database property. Source code in notional/schema.py class Number ( PropertyObject , type = \"number\" ): \"\"\"Defines the number configuration for a database property.\"\"\" class _NestedData ( NestedObject ): format : NumberFormat = NumberFormat . NUMBER number : _NestedData = _NestedData () @classmethod def __compose__ ( cls , format ): \"\"\"Create a `Number` object with the expected format.\"\"\" return cls ( number = cls . _NestedData ( format = format )) __compose__ ( format ) classmethod special Create a Number object with the expected format. Source code in notional/schema.py @classmethod def __compose__ ( cls , format ): \"\"\"Create a `Number` object with the expected format.\"\"\" return cls ( number = cls . _NestedData ( format = format )) NumberFormat ( str , Enum ) Available number formats in Notion. Source code in notional/schema.py class NumberFormat ( str , Enum ): \"\"\"Available number formats in Notion.\"\"\" NUMBER = \"number\" NUMBER_WITH_COMMAS = \"number_with_commas\" PERCENT = \"percent\" DOLLAR = \"dollar\" CANADIAN_DOLLAR = \"canadian_dollar\" EURO = \"euro\" POUND = \"pound\" YEN = \"yen\" RUBLE = \"ruble\" RUPEE = \"rupee\" WON = \"won\" YUAN = \"yuan\" REAL = \"real\" LIRA = \"lira\" RUPIAH = \"rupiah\" FRANC = \"franc\" HONG_KONG_DOLLAR = \"hong_kong_dollar\" NEW_ZEALAND_DOLLAR = \"new_zealand_dollar\" KRONA = \"krona\" NORWEGIAN_KRONE = \"norwegian_krone\" MEXICAN_PESO = \"mexican_peso\" RAND = \"rand\" NEW_TAIWAN_DOLLAR = \"new_taiwan_dollar\" DANISH_KRONE = \"danish_krone\" ZLOTY = \"zloty\" BAHT = \"baht\" FORINT = \"forint\" KORUNA = \"koruna\" SHEKEL = \"shekel\" CHILEAN_PESO = \"chilean_peso\" PHILIPPINE_PESO = \"philippine_peso\" DIRHAM = \"dirham\" COLOMBIAN_PESO = \"colombian_peso\" RIYAL = \"riyal\" RINGGIT = \"ringgit\" LEU = \"leu\" People ( PropertyObject ) pydantic-model Defines the people configuration for a database property. Source code in notional/schema.py class People ( PropertyObject , type = \"people\" ): \"\"\"Defines the people configuration for a database property.\"\"\" people : Any = {} PhoneNumber ( PropertyObject ) pydantic-model Defines the phone number configuration for a database property. Source code in notional/schema.py class PhoneNumber ( PropertyObject , type = \"phone_number\" ): \"\"\"Defines the phone number configuration for a database property.\"\"\" phone_number : Any = {} PropertyObject ( TypedObject ) pydantic-model Base class for Notion property objects. Source code in notional/schema.py class PropertyObject ( TypedObject ): \"\"\"Base class for Notion property objects.\"\"\" id : Optional [ str ] = None name : Optional [ str ] = None Relation ( PropertyObject ) pydantic-model Defines the relation configuration for a database property. Source code in notional/schema.py class Relation ( PropertyObject , type = \"relation\" ): \"\"\"Defines the relation configuration for a database property.\"\"\" class _NestedData ( NestedObject ): database_id : UUID = None relation : _NestedData = _NestedData () @classmethod def __compose__ ( cls , database_id ): \"\"\"Create a `Relation` property using the target database ID.\"\"\" return cls ( relation = cls . _NestedData ( database_id = database_id )) __compose__ ( database_id ) classmethod special Create a Relation property using the target database ID. Source code in notional/schema.py @classmethod def __compose__ ( cls , database_id ): \"\"\"Create a `Relation` property using the target database ID.\"\"\" return cls ( relation = cls . _NestedData ( database_id = database_id )) RichText ( PropertyObject ) pydantic-model Defines the rich text configuration for a database property. Source code in notional/schema.py class RichText ( PropertyObject , type = \"rich_text\" ): \"\"\"Defines the rich text configuration for a database property.\"\"\" rich_text : Any = {} Rollup ( PropertyObject ) pydantic-model Defines the rollup configuration for a database property. Source code in notional/schema.py class Rollup ( PropertyObject , type = \"rollup\" ): \"\"\"Defines the rollup configuration for a database property.\"\"\" class _NestedData ( NestedObject ): function : Function = Function . COUNT_ALL relation_property_name : Optional [ str ] = None relation_property_id : Optional [ str ] = None rollup_property_name : Optional [ str ] = None rollup_property_id : Optional [ str ] = None rollup : _NestedData = _NestedData () Select ( PropertyObject ) pydantic-model Defines the select configuration for a database property. Source code in notional/schema.py class Select ( PropertyObject , type = \"select\" ): \"\"\"Defines the select configuration for a database property.\"\"\" class _NestedData ( NestedObject ): options : List [ SelectOption ] = [] select : _NestedData = _NestedData () @classmethod def __compose__ ( cls , options ): \"\"\"Create a `Select` object from the list of `SelectOption`'s.\"\"\" return cls ( select = cls . _NestedData ( options = options )) __compose__ ( options ) classmethod special Create a Select object from the list of SelectOption 's. Source code in notional/schema.py @classmethod def __compose__ ( cls , options ): \"\"\"Create a `Select` object from the list of `SelectOption`'s.\"\"\" return cls ( select = cls . _NestedData ( options = options )) SelectOption ( DataObject ) pydantic-model Options for select & multi-select objects. Source code in notional/schema.py class SelectOption ( DataObject ): \"\"\"Options for select & multi-select objects.\"\"\" name : str id : str = None color : str = Color . DEFAULT @classmethod def __compose__ ( cls , name , color = Color . DEFAULT ): \"\"\"Create a `SelectOption` object from the given name and color.\"\"\" return cls ( name = name , color = color ) __compose__ ( name , color =< Color . DEFAULT : 'default' > ) classmethod special Create a SelectOption object from the given name and color. Source code in notional/schema.py @classmethod def __compose__ ( cls , name , color = Color . DEFAULT ): \"\"\"Create a `SelectOption` object from the given name and color.\"\"\" return cls ( name = name , color = color ) Title ( PropertyObject ) pydantic-model Defines the title configuration for a database property. Source code in notional/schema.py class Title ( PropertyObject , type = \"title\" ): \"\"\"Defines the title configuration for a database property.\"\"\" title : Any = {} URL ( PropertyObject ) pydantic-model Defines the URL configuration for a database property. Source code in notional/schema.py class URL ( PropertyObject , type = \"url\" ): \"\"\"Defines the URL configuration for a database property.\"\"\" url : Any = {} session Provides direct access to the Notion API. BlocksEndpoint ( Endpoint ) Notional interface to the API 'blocks' endpoint. Source code in notional/session.py class BlocksEndpoint ( Endpoint ): \"\"\"Notional interface to the API 'blocks' endpoint.\"\"\" class ChildrenEndpoint ( Endpoint ): \"\"\"Notional interface to the API 'blocks/children' endpoint.\"\"\" def __call__ ( self ): \"\"\"Return the underlying endpoint in the Notion SDK.\"\"\" return self . session . client . blocks . children # https://developers.notion.com/reference/patch-block-children def append ( self , parent , * blocks ): \"\"\"Add the given blocks as children of the specified parent. The blocks info will be refreshed based on returned data. \"\"\" parent_id = get_target_id ( parent ) children = [ block . to_api () for block in blocks if block is not None ] log . info ( \"Appending %d blocks to %s ...\" , len ( children ), parent_id ) data = self () . append ( block_id = parent_id , children = children ) if \"results\" in data : if len ( blocks ) == len ( data [ \"results\" ]): for idx in range ( len ( blocks )): block = blocks [ idx ] result = data [ \"results\" ][ idx ] block . refresh ( ** result ) else : log . warning ( \"Unable to refresh results; size mismatch\" ) else : log . warning ( \"Unable to refresh results; not provided\" ) return parent # https://developers.notion.com/reference/get-block-children def list ( self , parent ): \"\"\"Return all Blocks contained by the specified parent.\"\"\" parent_id = get_target_id ( parent ) blocks = EndpointIterator ( endpoint = self () . list , block_id = parent_id ) log . info ( \"Listing blocks for %s ...\" , parent_id ) return ResultSet ( exec = blocks , cls = Block ) def __init__ ( self , * args , ** kwargs ): \"\"\"Initialize the `blocks` endpoint for the Notion API.\"\"\" super () . __init__ ( * args , ** kwargs ) self . children = BlocksEndpoint . ChildrenEndpoint ( * args , ** kwargs ) def __call__ ( self ): \"\"\"Return the underlying endpoint in the Notion SDK.\"\"\" return self . session . client . blocks # https://developers.notion.com/reference/delete-a-block def delete ( self , block ): \"\"\"Delete (archive) the specified Block.\"\"\" log . info ( \"Deleting block :: %s \" , block . id ) data = self () . delete ( block . id . hex ) return block . refresh ( ** data ) def restore ( self , block ): \"\"\"Restore (unarchive) the specified Block.\"\"\" log . info ( \"Restoring block :: %s \" , block . id ) data = self () . update ( block . id . hex , archived = False ) return block . refresh ( ** data ) # https://developers.notion.com/reference/retrieve-a-block def retrieve ( self , block_id ): \"\"\"Return the Block with the given ID.\"\"\" log . info ( \"Retrieving block :: %s \" , block_id ) data = self () . retrieve ( block_id ) return Block . parse_obj ( data ) # https://developers.notion.com/reference/update-a-block def update ( self , block ): \"\"\"Update the block content on the server. The block info will be refreshed to the latest version from the server. \"\"\" log . info ( \"Updating block :: %s \" , block . id ) data = self () . update ( block . id . hex , ** block . to_api ()) return block . refresh ( ** data ) ChildrenEndpoint ( Endpoint ) Notional interface to the API 'blocks/children' endpoint. Source code in notional/session.py class ChildrenEndpoint ( Endpoint ): \"\"\"Notional interface to the API 'blocks/children' endpoint.\"\"\" def __call__ ( self ): \"\"\"Return the underlying endpoint in the Notion SDK.\"\"\" return self . session . client . blocks . children # https://developers.notion.com/reference/patch-block-children def append ( self , parent , * blocks ): \"\"\"Add the given blocks as children of the specified parent. The blocks info will be refreshed based on returned data. \"\"\" parent_id = get_target_id ( parent ) children = [ block . to_api () for block in blocks if block is not None ] log . info ( \"Appending %d blocks to %s ...\" , len ( children ), parent_id ) data = self () . append ( block_id = parent_id , children = children ) if \"results\" in data : if len ( blocks ) == len ( data [ \"results\" ]): for idx in range ( len ( blocks )): block = blocks [ idx ] result = data [ \"results\" ][ idx ] block . refresh ( ** result ) else : log . warning ( \"Unable to refresh results; size mismatch\" ) else : log . warning ( \"Unable to refresh results; not provided\" ) return parent # https://developers.notion.com/reference/get-block-children def list ( self , parent ): \"\"\"Return all Blocks contained by the specified parent.\"\"\" parent_id = get_target_id ( parent ) blocks = EndpointIterator ( endpoint = self () . list , block_id = parent_id ) log . info ( \"Listing blocks for %s ...\" , parent_id ) return ResultSet ( exec = blocks , cls = Block ) __call__ ( self ) special Return the underlying endpoint in the Notion SDK. Source code in notional/session.py def __call__ ( self ): \"\"\"Return the underlying endpoint in the Notion SDK.\"\"\" return self . session . client . blocks . children append ( self , parent , * blocks ) Add the given blocks as children of the specified parent. The blocks info will be refreshed based on returned data. Source code in notional/session.py def append ( self , parent , * blocks ): \"\"\"Add the given blocks as children of the specified parent. The blocks info will be refreshed based on returned data. \"\"\" parent_id = get_target_id ( parent ) children = [ block . to_api () for block in blocks if block is not None ] log . info ( \"Appending %d blocks to %s ...\" , len ( children ), parent_id ) data = self () . append ( block_id = parent_id , children = children ) if \"results\" in data : if len ( blocks ) == len ( data [ \"results\" ]): for idx in range ( len ( blocks )): block = blocks [ idx ] result = data [ \"results\" ][ idx ] block . refresh ( ** result ) else : log . warning ( \"Unable to refresh results; size mismatch\" ) else : log . warning ( \"Unable to refresh results; not provided\" ) return parent list ( self , parent ) Return all Blocks contained by the specified parent. Source code in notional/session.py def list ( self , parent ): \"\"\"Return all Blocks contained by the specified parent.\"\"\" parent_id = get_target_id ( parent ) blocks = EndpointIterator ( endpoint = self () . list , block_id = parent_id ) log . info ( \"Listing blocks for %s ...\" , parent_id ) return ResultSet ( exec = blocks , cls = Block ) __call__ ( self ) special Return the underlying endpoint in the Notion SDK. Source code in notional/session.py def __call__ ( self ): \"\"\"Return the underlying endpoint in the Notion SDK.\"\"\" return self . session . client . blocks __init__ ( self , * args , ** kwargs ) special Initialize the blocks endpoint for the Notion API. Source code in notional/session.py def __init__ ( self , * args , ** kwargs ): \"\"\"Initialize the `blocks` endpoint for the Notion API.\"\"\" super () . __init__ ( * args , ** kwargs ) self . children = BlocksEndpoint . ChildrenEndpoint ( * args , ** kwargs ) delete ( self , block ) Delete (archive) the specified Block. Source code in notional/session.py def delete ( self , block ): \"\"\"Delete (archive) the specified Block.\"\"\" log . info ( \"Deleting block :: %s \" , block . id ) data = self () . delete ( block . id . hex ) return block . refresh ( ** data ) restore ( self , block ) Restore (unarchive) the specified Block. Source code in notional/session.py def restore ( self , block ): \"\"\"Restore (unarchive) the specified Block.\"\"\" log . info ( \"Restoring block :: %s \" , block . id ) data = self () . update ( block . id . hex , archived = False ) return block . refresh ( ** data ) retrieve ( self , block_id ) Return the Block with the given ID. Source code in notional/session.py def retrieve ( self , block_id ): \"\"\"Return the Block with the given ID.\"\"\" log . info ( \"Retrieving block :: %s \" , block_id ) data = self () . retrieve ( block_id ) return Block . parse_obj ( data ) update ( self , block ) Update the block content on the server. The block info will be refreshed to the latest version from the server. Source code in notional/session.py def update ( self , block ): \"\"\"Update the block content on the server. The block info will be refreshed to the latest version from the server. \"\"\" log . info ( \"Updating block :: %s \" , block . id ) data = self () . update ( block . id . hex , ** block . to_api ()) return block . refresh ( ** data ) DatabasesEndpoint ( Endpoint ) Notional interface to the API 'databases' endpoint. Source code in notional/session.py class DatabasesEndpoint ( Endpoint ): \"\"\"Notional interface to the API 'databases' endpoint.\"\"\" def __call__ ( self ): \"\"\"Return the underlying endpoint in the Notion SDK.\"\"\" return self . session . client . databases def _build_request ( self , parent = None , schema = None , title = None ): \"\"\"Build a request payload from the given items. *NOTE* this method does not anticipate what the request will be used for and as such does not validate the inputs for any particular requests. \"\"\" request = {} if parent is not None : ref = ParentRef [ parent ] request [ \"parent\" ] = ref . to_api () if isinstance ( title , TextObject ): request [ \"title\" ] = [ title . to_api ()] elif isinstance ( title , list ): request [ \"title\" ] = [ prop . to_api () for prop in title if prop is not None ] elif isinstance ( title , str ): prop = TextObject [ title ] request [ \"title\" ] = [ prop . to_api ()] elif title is not None : raise ValueError ( \"Unrecognized data in 'title'\" ) if schema is not None : request [ \"properties\" ] = { name : value . to_api () if value is not None else None for name , value in schema . items () } return request # https://developers.notion.com/reference/create-a-database def create ( self , parent , schema , title = None ): \"\"\"Add a database to the given Page parent.\"\"\" log . info ( \"Creating database %s - %s \" , parent , title ) request = self . _build_request ( parent , schema , title ) data = self () . create ( ** request ) return Database . parse_obj ( data ) # https://developers.notion.com/reference/get-databases def list ( self ): \"\"\"Return an iterator for all Database objects in the integration scope.\"\"\" # DEPRECATED ENDPOINT ### log . info ( \"Listing known databases...\" ) databases = EndpointIterator ( endpoint = self () . list ) return ResultSet ( exec = databases , cls = Database ) # https://developers.notion.com/reference/retrieve-a-database def retrieve ( self , database_id ): \"\"\"Return the Database with the given ID.\"\"\" log . info ( \"Retrieving database :: %s \" , database_id ) data = self () . retrieve ( database_id ) return Database . parse_obj ( data ) # https://developers.notion.com/reference/update-a-database def update ( self , database , title = None , schema = None ): \"\"\"Update the Database object on the server. The database info will be refreshed to the latest version from the server. \"\"\" dbid = get_target_id ( database ) log . info ( \"Updating database info :: \" , dbid ) request = self . _build_request ( schema = schema , title = title ) if request : data = self () . update ( dbid , ** request ) database = database . refresh ( ** data ) return database def delete ( self , database ): \"\"\"Delete (archive) the specified Database.\"\"\" log . info ( \"Deleting database :: %s \" , database . id ) return self . session . blocks . delete ( database ) def restore ( self , database ): \"\"\"Restore (unarchive) the specified Database.\"\"\" log . info ( \"Restoring database :: %s \" , database . id ) return self . session . blocks . restore ( database ) # https://developers.notion.com/reference/post-database-query def query ( self , target ): \"\"\"Initialize a new Query object with the target data class. :param target: either a string with the database ID or an ORM class \"\"\" log . info ( \"Initializing database query :: { %s }\" , get_target_id ( target )) database_id = get_target_id ( target ) cls = None if isclass ( target ) and issubclass ( target , ConnectedPage ): cls = target if cls . _notional__session != self . session : raise ValueError ( \"ConnectedPage belongs to a different session\" ) return QueryBuilder ( endpoint = self () . query , cls = cls , database_id = database_id ) __call__ ( self ) special Return the underlying endpoint in the Notion SDK. Source code in notional/session.py def __call__ ( self ): \"\"\"Return the underlying endpoint in the Notion SDK.\"\"\" return self . session . client . databases create ( self , parent , schema , title = None ) Add a database to the given Page parent. Source code in notional/session.py def create ( self , parent , schema , title = None ): \"\"\"Add a database to the given Page parent.\"\"\" log . info ( \"Creating database %s - %s \" , parent , title ) request = self . _build_request ( parent , schema , title ) data = self () . create ( ** request ) return Database . parse_obj ( data ) delete ( self , database ) Delete (archive) the specified Database. Source code in notional/session.py def delete ( self , database ): \"\"\"Delete (archive) the specified Database.\"\"\" log . info ( \"Deleting database :: %s \" , database . id ) return self . session . blocks . delete ( database ) list ( self ) Return an iterator for all Database objects in the integration scope. Source code in notional/session.py def list ( self ): \"\"\"Return an iterator for all Database objects in the integration scope.\"\"\" # DEPRECATED ENDPOINT ### log . info ( \"Listing known databases...\" ) databases = EndpointIterator ( endpoint = self () . list ) return ResultSet ( exec = databases , cls = Database ) query ( self , target ) Initialize a new Query object with the target data class. :param target: either a string with the database ID or an ORM class Source code in notional/session.py def query ( self , target ): \"\"\"Initialize a new Query object with the target data class. :param target: either a string with the database ID or an ORM class \"\"\" log . info ( \"Initializing database query :: { %s }\" , get_target_id ( target )) database_id = get_target_id ( target ) cls = None if isclass ( target ) and issubclass ( target , ConnectedPage ): cls = target if cls . _notional__session != self . session : raise ValueError ( \"ConnectedPage belongs to a different session\" ) return QueryBuilder ( endpoint = self () . query , cls = cls , database_id = database_id ) restore ( self , database ) Restore (unarchive) the specified Database. Source code in notional/session.py def restore ( self , database ): \"\"\"Restore (unarchive) the specified Database.\"\"\" log . info ( \"Restoring database :: %s \" , database . id ) return self . session . blocks . restore ( database ) retrieve ( self , database_id ) Return the Database with the given ID. Source code in notional/session.py def retrieve ( self , database_id ): \"\"\"Return the Database with the given ID.\"\"\" log . info ( \"Retrieving database :: %s \" , database_id ) data = self () . retrieve ( database_id ) return Database . parse_obj ( data ) update ( self , database , title = None , schema = None ) Update the Database object on the server. The database info will be refreshed to the latest version from the server. Source code in notional/session.py def update ( self , database , title = None , schema = None ): \"\"\"Update the Database object on the server. The database info will be refreshed to the latest version from the server. \"\"\" dbid = get_target_id ( database ) log . info ( \"Updating database info :: \" , dbid ) request = self . _build_request ( schema = schema , title = title ) if request : data = self () . update ( dbid , ** request ) database = database . refresh ( ** data ) return database Endpoint Notional wrapper for the API endpoints. Source code in notional/session.py class Endpoint ( object ): \"\"\"Notional wrapper for the API endpoints.\"\"\" def __init__ ( self , session ): \"\"\"Initialize the `Endpoint` for the supplied session.\"\"\" self . session = session __init__ ( self , session ) special Initialize the Endpoint for the supplied session. Source code in notional/session.py def __init__ ( self , session ): \"\"\"Initialize the `Endpoint` for the supplied session.\"\"\" self . session = session PagesEndpoint ( Endpoint ) Notional interface to the API 'pages' endpoint. Source code in notional/session.py class PagesEndpoint ( Endpoint ): \"\"\"Notional interface to the API 'pages' endpoint.\"\"\" def __call__ ( self ): \"\"\"Return the underlying endpoint in the Notion SDK.\"\"\" return self . session . client . pages # https://developers.notion.com/reference/post-page def create ( self , parent , title = None , properties = None , children = None ): \"\"\"Add a page to the given parent (Page or Database).\"\"\" if parent is None : raise ValueError ( \"'parent' must be provided\" ) parent = ParentRef [ parent ] request = { \"parent\" : parent . to_api ()} # the API requires a properties object, even if empty if properties is None : properties = {} if title is not None : properties [ \"title\" ] = Title [ title ] request [ \"properties\" ] = { name : prop . to_api () if prop is not None else None for name , prop in properties . items () } if children is not None : request [ \"children\" ] = [ child . to_api () for child in children if child is not None ] log . info ( \"Creating page :: %s => %s \" , parent , title ) data = self () . create ( ** request ) return Page . parse_obj ( data ) def delete ( self , page ): \"\"\"Delete (archive) the specified Page.\"\"\" return self . set ( page , archived = True ) def restore ( self , page ): \"\"\"Restore (unarchive) the specified Page.\"\"\" return self . set ( page , archived = False ) # https://developers.notion.com/reference/retrieve-a-page def retrieve ( self , page_id ): \"\"\"Return the Page with the given ID.\"\"\" log . info ( \"Retrieving page :: %s \" , page_id ) data = self () . retrieve ( page_id ) return Page . parse_obj ( data ) # https://developers.notion.com/reference/patch-page def update ( self , page , ** properties ): \"\"\"Update the Page object properties on the server. If `properties` are provided, only those values will be updated. If `properties` is empty, all page properties will be updated. `properties` are specified as `\"name\"`: `PropertyValue` pairs. The page info will be refreshed to the latest version from the server. \"\"\" log . info ( \"Updating page info :: %s \" , page . id ) if not properties : properties = page . properties props = { name : value . to_api () if value is not None else None for name , value in properties . items () } data = self () . update ( page . id . hex , properties = props ) return page . refresh ( ** data ) def set ( self , page , cover = False , icon = False , archived = None ): \"\"\"Set specific page attributes (such as cover, icon, etc) on the server. To remove an attribute, set its value to None. \"\"\" if cover is None : log . info ( \"Removing page cover :: %s \" , page . id ) data = self () . update ( page . id . hex , cover = {}) elif cover is not False : log . info ( \"Setting page cover :: %s => %s \" , page . id , cover ) data = self () . update ( page . id . hex , cover = cover . to_api ()) if icon is None : log . info ( \"Removing page icon :: %s \" , page . id ) data = self () . update ( page . id . hex , icon = {}) elif icon is not False : log . info ( \"Setting page icon :: %s => %s \" , page . id , icon ) data = self () . update ( page . id . hex , icon = icon . to_api ()) if archived is False : log . info ( \"Restoring page :: %s \" , page . id ) data = self () . update ( page . id . hex , archived = False ) elif archived is True : log . info ( \"Archiving page :: %s \" , page . id ) data = self () . update ( page . id . hex , archived = True ) return page . refresh ( ** data ) __call__ ( self ) special Return the underlying endpoint in the Notion SDK. Source code in notional/session.py def __call__ ( self ): \"\"\"Return the underlying endpoint in the Notion SDK.\"\"\" return self . session . client . pages create ( self , parent , title = None , properties = None , children = None ) Add a page to the given parent (Page or Database). Source code in notional/session.py def create ( self , parent , title = None , properties = None , children = None ): \"\"\"Add a page to the given parent (Page or Database).\"\"\" if parent is None : raise ValueError ( \"'parent' must be provided\" ) parent = ParentRef [ parent ] request = { \"parent\" : parent . to_api ()} # the API requires a properties object, even if empty if properties is None : properties = {} if title is not None : properties [ \"title\" ] = Title [ title ] request [ \"properties\" ] = { name : prop . to_api () if prop is not None else None for name , prop in properties . items () } if children is not None : request [ \"children\" ] = [ child . to_api () for child in children if child is not None ] log . info ( \"Creating page :: %s => %s \" , parent , title ) data = self () . create ( ** request ) return Page . parse_obj ( data ) delete ( self , page ) Delete (archive) the specified Page. Source code in notional/session.py def delete ( self , page ): \"\"\"Delete (archive) the specified Page.\"\"\" return self . set ( page , archived = True ) restore ( self , page ) Restore (unarchive) the specified Page. Source code in notional/session.py def restore ( self , page ): \"\"\"Restore (unarchive) the specified Page.\"\"\" return self . set ( page , archived = False ) retrieve ( self , page_id ) Return the Page with the given ID. Source code in notional/session.py def retrieve ( self , page_id ): \"\"\"Return the Page with the given ID.\"\"\" log . info ( \"Retrieving page :: %s \" , page_id ) data = self () . retrieve ( page_id ) return Page . parse_obj ( data ) set ( self , page , cover = False , icon = False , archived = None ) Set specific page attributes (such as cover, icon, etc) on the server. To remove an attribute, set its value to None. Source code in notional/session.py def set ( self , page , cover = False , icon = False , archived = None ): \"\"\"Set specific page attributes (such as cover, icon, etc) on the server. To remove an attribute, set its value to None. \"\"\" if cover is None : log . info ( \"Removing page cover :: %s \" , page . id ) data = self () . update ( page . id . hex , cover = {}) elif cover is not False : log . info ( \"Setting page cover :: %s => %s \" , page . id , cover ) data = self () . update ( page . id . hex , cover = cover . to_api ()) if icon is None : log . info ( \"Removing page icon :: %s \" , page . id ) data = self () . update ( page . id . hex , icon = {}) elif icon is not False : log . info ( \"Setting page icon :: %s => %s \" , page . id , icon ) data = self () . update ( page . id . hex , icon = icon . to_api ()) if archived is False : log . info ( \"Restoring page :: %s \" , page . id ) data = self () . update ( page . id . hex , archived = False ) elif archived is True : log . info ( \"Archiving page :: %s \" , page . id ) data = self () . update ( page . id . hex , archived = True ) return page . refresh ( ** data ) update ( self , page , ** properties ) Update the Page object properties on the server. If properties are provided, only those values will be updated. If properties is empty, all page properties will be updated. properties are specified as \"name\" : PropertyValue pairs. The page info will be refreshed to the latest version from the server. Source code in notional/session.py def update ( self , page , ** properties ): \"\"\"Update the Page object properties on the server. If `properties` are provided, only those values will be updated. If `properties` is empty, all page properties will be updated. `properties` are specified as `\"name\"`: `PropertyValue` pairs. The page info will be refreshed to the latest version from the server. \"\"\" log . info ( \"Updating page info :: %s \" , page . id ) if not properties : properties = page . properties props = { name : value . to_api () if value is not None else None for name , value in properties . items () } data = self () . update ( page . id . hex , properties = props ) return page . refresh ( ** data ) SearchEndpoint ( Endpoint ) Notional interface to the API 'search' endpoint. Source code in notional/session.py class SearchEndpoint ( Endpoint ): \"\"\"Notional interface to the API 'search' endpoint.\"\"\" # https://developers.notion.com/reference/post-search def __call__ ( self , text = None ): \"\"\"Perform a search with the optional text. If specified, the call will perform a search with the given text. :return: a `QueryBuilder` with the requested search :rtype: query.QueryBuilder \"\"\" params = {} if text is not None : params [ \"query\" ] = text return QueryBuilder ( endpoint = self . session . client . search , ** params ) __call__ ( self , text = None ) special Perform a search with the optional text. If specified, the call will perform a search with the given text. :return: a QueryBuilder with the requested search :rtype: query.QueryBuilder Source code in notional/session.py def __call__ ( self , text = None ): \"\"\"Perform a search with the optional text. If specified, the call will perform a search with the given text. :return: a `QueryBuilder` with the requested search :rtype: query.QueryBuilder \"\"\" params = {} if text is not None : params [ \"query\" ] = text return QueryBuilder ( endpoint = self . session . client . search , ** params ) Session An active session with the Notion SDK. Source code in notional/session.py class Session ( object ): \"\"\"An active session with the Notion SDK.\"\"\" def __init__ ( self , ** kwargs ): \"\"\"Initialize the `Session` object and the endpoints. `kwargs` will be passed direction to the Notion SDK Client. For more details, see the (full docs)[https://ramnes.github.io/notion-sdk-py/reference/client/]. :param auth: bearer token for authentication \"\"\" self . client = notion_client . Client ( ** kwargs ) self . blocks = BlocksEndpoint ( self ) self . databases = DatabasesEndpoint ( self ) self . pages = PagesEndpoint ( self ) self . search = SearchEndpoint ( self ) self . users = UsersEndpoint ( self ) log . info ( \"Initialized Notion SDK client\" ) @property def IsActive ( self ): \"\"\"Determine if the current session is active. The session is considered \"active\" if it has not been closed. This does not determine if the session can connect to the Notion API. \"\"\" return self . client is not None def close ( self ): \"\"\"Close the session and release resources.\"\"\" if self . client is None : raise SessionError ( \"Session is not active.\" ) self . client . close () self . client = None def ping ( self ): \"\"\"Confirm that the session is active and able to connect to Notion. Raises SessionError if there is a problem, otherwise returns True. \"\"\" if self . IsActive is False : return False error = None try : me = self . users . me () if me is None : raise SessionError ( \"Unable to get current user\" ) except ConnectError : error = \"Unable to connect to Notion\" except APIResponseError as err : error = str ( err ) if error is not None : raise SessionError ( error ) return True IsActive property readonly Determine if the current session is active. The session is considered \"active\" if it has not been closed. This does not determine if the session can connect to the Notion API. __init__ ( self , ** kwargs ) special Initialize the Session object and the endpoints. kwargs will be passed direction to the Notion SDK Client. For more details, see the (full docs)[https://ramnes.github.io/notion-sdk-py/reference/client/]. :param auth: bearer token for authentication Source code in notional/session.py def __init__ ( self , ** kwargs ): \"\"\"Initialize the `Session` object and the endpoints. `kwargs` will be passed direction to the Notion SDK Client. For more details, see the (full docs)[https://ramnes.github.io/notion-sdk-py/reference/client/]. :param auth: bearer token for authentication \"\"\" self . client = notion_client . Client ( ** kwargs ) self . blocks = BlocksEndpoint ( self ) self . databases = DatabasesEndpoint ( self ) self . pages = PagesEndpoint ( self ) self . search = SearchEndpoint ( self ) self . users = UsersEndpoint ( self ) log . info ( \"Initialized Notion SDK client\" ) close ( self ) Close the session and release resources. Source code in notional/session.py def close ( self ): \"\"\"Close the session and release resources.\"\"\" if self . client is None : raise SessionError ( \"Session is not active.\" ) self . client . close () self . client = None ping ( self ) Confirm that the session is active and able to connect to Notion. Raises SessionError if there is a problem, otherwise returns True. Source code in notional/session.py def ping ( self ): \"\"\"Confirm that the session is active and able to connect to Notion. Raises SessionError if there is a problem, otherwise returns True. \"\"\" if self . IsActive is False : return False error = None try : me = self . users . me () if me is None : raise SessionError ( \"Unable to get current user\" ) except ConnectError : error = \"Unable to connect to Notion\" except APIResponseError as err : error = str ( err ) if error is not None : raise SessionError ( error ) return True SessionError ( Exception ) Raised when there are issues with the Notion session. Source code in notional/session.py class SessionError ( Exception ): \"\"\"Raised when there are issues with the Notion session.\"\"\" def __init__ ( self , message ): \"\"\"Initialize the `SessionError` with a supplied message..\"\"\" super () . __init__ ( message ) __init__ ( self , message ) special Initialize the SessionError with a supplied message.. Source code in notional/session.py def __init__ ( self , message ): \"\"\"Initialize the `SessionError` with a supplied message..\"\"\" super () . __init__ ( message ) UsersEndpoint ( Endpoint ) Notional interface to the API 'users' endpoint. Source code in notional/session.py class UsersEndpoint ( Endpoint ): \"\"\"Notional interface to the API 'users' endpoint.\"\"\" def __call__ ( self ): \"\"\"Return the underlying endpoint in the Notion SDK.\"\"\" return self . session . client . users # https://developers.notion.com/reference/get-users def list ( self ): \"\"\"Return an iterator for all users in the workspace.\"\"\" users = EndpointIterator ( endpoint = self () . list ) log . info ( \"Listing known users...\" ) return ResultSet ( exec = users , cls = User ) # https://developers.notion.com/reference/get-user def retrieve ( self , user_id ): \"\"\"Return the User with the given ID.\"\"\" log . info ( \"Retrieving user :: %s \" , user_id ) data = self () . retrieve ( user_id ) return User . parse_obj ( data ) # https://developers.notion.com/reference/get-self def me ( self ): \"\"\"Return the current bot User.\"\"\" log . info ( \"Retrieving current integration bot\" ) data = self () . me () return User . parse_obj ( data ) __call__ ( self ) special Return the underlying endpoint in the Notion SDK. Source code in notional/session.py def __call__ ( self ): \"\"\"Return the underlying endpoint in the Notion SDK.\"\"\" return self . session . client . users list ( self ) Return an iterator for all users in the workspace. Source code in notional/session.py def list ( self ): \"\"\"Return an iterator for all users in the workspace.\"\"\" users = EndpointIterator ( endpoint = self () . list ) log . info ( \"Listing known users...\" ) return ResultSet ( exec = users , cls = User ) me ( self ) Return the current bot User. Source code in notional/session.py def me ( self ): \"\"\"Return the current bot User.\"\"\" log . info ( \"Retrieving current integration bot\" ) data = self () . me () return User . parse_obj ( data ) retrieve ( self , user_id ) Return the User with the given ID. Source code in notional/session.py def retrieve ( self , user_id ): \"\"\"Return the User with the given ID.\"\"\" log . info ( \"Retrieving user :: %s \" , user_id ) data = self () . retrieve ( user_id ) return User . parse_obj ( data ) text Utilities for working text, markdown & Rich Text in Notion. Annotations ( DataObject ) pydantic-model Style information for RichTextObject's. Source code in notional/text.py class Annotations ( DataObject ): \"\"\"Style information for RichTextObject's.\"\"\" bold : bool = False italic : bool = False strikethrough : bool = False underline : bool = False code : bool = False color : FullColor = None @property def is_plain ( self ): \"\"\"Determine if any flags are set in this `Annotations` object. If all flags match their defaults, this is considered a \"plain\" style. \"\"\" # XXX a better approach here would be to just compate all fields to defaults if self . bold : return False if self . italic : return False if self . strikethrough : return False if self . underline : return False if self . code : return False if self . color is not None : return False return True is_plain property readonly Determine if any flags are set in this Annotations object. If all flags match their defaults, this is considered a \"plain\" style. CodingLanguage ( str , Enum ) Available coding languages. Source code in notional/text.py class CodingLanguage ( str , Enum ): \"\"\"Available coding languages.\"\"\" ABAP = \"abap\" ARDUION = \"arduino\" BASH = \"bash\" BASIC = \"basic\" C = \"c\" CLOJURE = \"clojure\" COFFEESCRIPT = \"coffeescript\" CPP = \"c++\" CSHARP = \"c#\" CSS = \"css\" DART = \"dart\" DIFF = \"diff\" DOCKER = \"docker\" ELIXIR = \"elixir\" ELM = \"elm\" ERLANG = \"erlang\" FLOW = \"flow\" FORTRAN = \"fortran\" FSHARP = \"f#\" GHERKIN = \"gherkin\" GLSL = \"glsl\" GO = \"go\" GRAPHQL = \"graphql\" GROOVY = \"groovy\" HASKELL = \"haskell\" HTML = \"html\" JAVA = \"java\" JAVASCRIPT = \"javascript\" JSON = \"json\" JULIA = \"julia\" KOTLIN = \"kotlin\" LATEX = \"latex\" LESS = \"less\" LISP = \"lisp\" LIVESCRIPT = \"livescript\" LUA = \"lua\" MAKEFILE = \"makefile\" MARKDOWN = \"markdown\" MARKUP = \"markup\" MATLAB = \"matlab\" MERMAID = \"mermaid\" NIX = \"nix\" OBJECTIVE_C = \"objective-c\" OCAML = \"ocaml\" PASCAL = \"pascal\" PERL = \"perl\" PHP = \"php\" PLAIN_TEXT = \"plain text\" POWERSHELL = \"powershell\" PROLOG = \"prolog\" PROTOBUF = \"protobuf\" PYTHON = \"python\" R = \"r\" REASON = \"reason\" RUBY = \"ruby\" RUST = \"rust\" SASS = \"sass\" SCALA = \"scala\" SCHEME = \"scheme\" SCSS = \"scss\" SHELL = \"shell\" SQL = \"sql\" SWIFT = \"swift\" TYPESCRIPT = \"typescript\" VB_NET = \"vb.net\" VERILOG = \"verilog\" VHDL = \"vhdl\" VISUAL_BASIC = \"visual basic\" WEBASSEMBLY = \"webassembly\" XML = \"xml\" YAML = \"yaml\" MISC = \"java/c/c++/c#\" Color ( str , Enum ) Basic color values. Source code in notional/text.py class Color ( str , Enum ): \"\"\"Basic color values.\"\"\" DEFAULT = \"default\" GRAY = \"gray\" BROWN = \"brown\" ORANGE = \"orange\" YELLOW = \"yellow\" GREEN = \"green\" BLUE = \"blue\" PURPLE = \"purple\" PINK = \"pink\" RED = \"red\" FullColor ( str , Enum ) Extended color values, including backgounds. Source code in notional/text.py class FullColor ( str , Enum ): \"\"\"Extended color values, including backgounds.\"\"\" DEFAULT = \"default\" GRAY = \"gray\" BROWN = \"brown\" ORANGE = \"orange\" YELLOW = \"yellow\" GREEN = \"green\" BLUE = \"blue\" PURPLE = \"purple\" PINK = \"pink\" RED = \"red\" GRAY_BACKGROUND = \"gray_background\" BROWN_BACKGROUND = \"brown_background\" ORANGE_BACKGROUND = \"orange_background\" YELLOW_BACKGROUND = \"yellow_background\" GREEN_BACKGROUND = \"green_background\" BLUE_BACKGROUND = \"blue_background\" PURPLE_BACKGROUND = \"purple_background\" PINK_BACKGROUND = \"pink_background\" RED_BACKGROUND = \"red_background\" LinkObject ( DataObject ) pydantic-model Reference a URL. Source code in notional/text.py class LinkObject ( DataObject ): \"\"\"Reference a URL.\"\"\" type : str = \"url\" url : str = None RichTextObject ( TypedObject ) pydantic-model Base class for Notion rich text elements. Source code in notional/text.py class RichTextObject ( TypedObject ): \"\"\"Base class for Notion rich text elements.\"\"\" plain_text : str href : Optional [ str ] = None annotations : Optional [ Annotations ] = None def __str__ ( self ): \"\"\"Return a string representation of this object.\"\"\" if self . href is None : text = self . plain_text or \"\" elif self . plain_text is None or len ( self . plain_text ) == 0 : text = f \"( { self . href } )\" else : text = f \"[ { self . plain_text } ]( { self . href } )\" if self . annotations : if self . annotations . bold : text = f \"* { text } *\" if self . annotations . italic : text = f \"** { text } **\" if self . annotations . underline : text = f \"_ { text } _\" if self . annotations . strikethrough : text = f \"~ { text } ~\" if self . annotations . code : text = f \"` { text } `\" return text __str__ ( self ) special Return a string representation of this object. Source code in notional/text.py def __str__ ( self ): \"\"\"Return a string representation of this object.\"\"\" if self . href is None : text = self . plain_text or \"\" elif self . plain_text is None or len ( self . plain_text ) == 0 : text = f \"( { self . href } )\" else : text = f \"[ { self . plain_text } ]( { self . href } )\" if self . annotations : if self . annotations . bold : text = f \"* { text } *\" if self . annotations . italic : text = f \"** { text } **\" if self . annotations . underline : text = f \"_ { text } _\" if self . annotations . strikethrough : text = f \"~ { text } ~\" if self . annotations . code : text = f \"` { text } `\" return text TextObject ( RichTextObject ) pydantic-model Notion text element. Source code in notional/text.py class TextObject ( RichTextObject , type = \"text\" ): \"\"\"Notion text element.\"\"\" class _NestedData ( NestedObject ): content : str = None link : Optional [ LinkObject ] = None text : _NestedData = _NestedData () @classmethod def __compose__ ( cls , text , href = None , style = None ): \"\"\"Compose a TextObject from the given properties. :param text: the plain text of this object :param href: an optional link for this object :param style: an optional Annotations object for this text \"\"\" if text is None : return None # TODO convert markdown in text:str to RichText? link = LinkObject ( url = href ) if href else None nested = TextObject . _NestedData ( content = text , link = link ) style = deepcopy ( style ) return TextObject ( plain_text = text , text = nested , href = href , annotations = style , ) __compose__ ( text , href = None , style = None ) classmethod special Compose a TextObject from the given properties. :param text: the plain text of this object :param href: an optional link for this object :param style: an optional Annotations object for this text Source code in notional/text.py @classmethod def __compose__ ( cls , text , href = None , style = None ): \"\"\"Compose a TextObject from the given properties. :param text: the plain text of this object :param href: an optional link for this object :param style: an optional Annotations object for this text \"\"\" if text is None : return None # TODO convert markdown in text:str to RichText? link = LinkObject ( url = href ) if href else None nested = TextObject . _NestedData ( content = text , link = link ) style = deepcopy ( style ) return TextObject ( plain_text = text , text = nested , href = href , annotations = style , ) chunky ( text , length = 2000 ) Break the given text into chunks of at most length size. Source code in notional/text.py def chunky ( text , length = MAX_TEXT_OBJECT_SIZE ): \"\"\"Break the given `text` into chunks of at most `length` size.\"\"\" return ( text [ idx : idx + length ] for idx in range ( 0 , len ( text ), length )) lstrip ( * rtf ) Remove leading whitespace from each TextObject in the list. Source code in notional/text.py def lstrip ( * rtf ): \"\"\"Remove leading whitespace from each `TextObject` in the list.\"\"\" if rtf is None or len ( rtf ) < 1 : return for obj in rtf : if not isinstance ( obj , TextObject ): raise AttributeError ( \"invalid object in rtf\" ) if obj . text and obj . text . content : strip_text = obj . text . content . lstrip () obj . text . content = strip_text obj . plain_text = strip_text make_safe_python_name ( name ) Make the given string safe for use as a Python identifier. This will remove any leading characters that are not valid and change all invalid interior sequences to underscore. Source code in notional/text.py def make_safe_python_name ( name ): \"\"\"Make the given string safe for use as a Python identifier. This will remove any leading characters that are not valid and change all invalid interior sequences to underscore. \"\"\" s = re . sub ( r \"[^0-9a-zA-Z_]+\" , \"_\" , name ) s = re . sub ( r \"^[^a-zA-Z]+\" , \"\" , s ) # remove trailing underscores return s . rstrip ( \"_\" ) markdown ( * rtf ) Return text as markdown from the list of RichText objects. Source code in notional/text.py def markdown ( * rtf ): \"\"\"Return text as markdown from the list of RichText objects.\"\"\" return \"\" . join ( str ( text ) for text in rtf if text ) plain_text ( * rtf ) Return the combined plain text from the list of RichText objects. Source code in notional/text.py def plain_text ( * rtf ): \"\"\"Return the combined plain text from the list of RichText objects.\"\"\" return \"\" . join ( text . plain_text for text in rtf if text ) rstrip ( * rtf ) Remove trailing whitespace from each TextObject in the list. Source code in notional/text.py def rstrip ( * rtf ): \"\"\"Remove trailing whitespace from each `TextObject` in the list.\"\"\" if rtf is None or len ( rtf ) < 1 : return for obj in rtf : if not isinstance ( obj , TextObject ): raise AttributeError ( \"invalid object in rtf\" ) if obj . text and obj . text . content : strip_text = obj . text . content . rstrip () obj . text . content = strip_text obj . plain_text = strip_text strip ( * rtf ) Remove leading and trailing whitespace from each TextObject in the list. This is functionally equivalent to: lstrip ( * rtf ) rstrip ( * rtf ) :param rtf: a list of TextObject 's Source code in notional/text.py def strip ( * rtf ): \"\"\"Remove leading and trailing whitespace from each `TextObject` in the list. This is functionally equivalent to: ```python lstrip(*rtf) rstrip(*rtf) ``` :param rtf: a list of `TextObject`'s \"\"\" lstrip ( * rtf ) rstrip ( * rtf ) truncate ( text , length =- 1 , trail = '...' ) Truncate the given text, using a supplied tail as a placeholder. Source code in notional/text.py def truncate ( text , length =- 1 , trail = \"...\" ): \"\"\"Truncate the given text, using a supplied tail as a placeholder.\"\"\" if text is None : return None # repr() includes open and close quotes... literal = repr ( text )[ 1 : - 1 ] if 0 < length < len ( literal ): literal = literal [: length ] if trail is not None : literal += trail return literal types Wrapper for Notion API data types. Similar to other records, these object provide access to the primitive data structure used in the Notion API as well as higher-level methods. Checkbox ( NativeTypeMixin , PropertyValue ) pydantic-model Simple checkbox type; represented as a boolean. Source code in notional/types.py class Checkbox ( NativeTypeMixin , PropertyValue , type = \"checkbox\" ): \"\"\"Simple checkbox type; represented as a boolean.\"\"\" checkbox : Optional [ bool ] = None CreatedBy ( PropertyValue ) pydantic-model A Notion created-by property value. Source code in notional/types.py class CreatedBy ( PropertyValue , type = \"created_by\" ): \"\"\"A Notion created-by property value.\"\"\" created_by : User def __str__ ( self ): \"\"\"Return the contents of this property as a string.\"\"\" return str ( self . created_by ) __str__ ( self ) special Return the contents of this property as a string. Source code in notional/types.py def __str__ ( self ): \"\"\"Return the contents of this property as a string.\"\"\" return str ( self . created_by ) CreatedTime ( NativeTypeMixin , PropertyValue ) pydantic-model A Notion created-time property value. Source code in notional/types.py class CreatedTime ( NativeTypeMixin , PropertyValue , type = \"created_time\" ): \"\"\"A Notion created-time property value.\"\"\" created_time : datetime Date ( PropertyValue ) pydantic-model Notion complex date type - may include timestamp and/or be a date range. Source code in notional/types.py class Date ( PropertyValue , type = \"date\" ): \"\"\"Notion complex date type - may include timestamp and/or be a date range.\"\"\" date : Optional [ DateRange ] = None def __contains__ ( self , other ): \"\"\"Determine if the given date is in the range (inclusive) of this Date. Raises ValueError if the Date object is not a range - e.g. has no end date. \"\"\" if not self . IsRange : raise ValueError ( \"This date is not a range\" ) return self . Start <= other <= self . End def __str__ ( self ): \"\"\"Return a string representation of this property.\"\"\" return \"\" if self . date is None else str ( self . date ) @classmethod def __compose__ ( cls , start , end = None ): \"\"\"Create a new Date from the native values.\"\"\" return cls ( date = DateRange ( start = start , end = end )) @property def IsRange ( self ): \"\"\"Determine if this object represents a date range (versus a single date).\"\"\" if self . date is None : return False return self . date . end is not None @property def Start ( self ): \"\"\"Return the start date of this property.\"\"\" return None if self . date is None else self . date . start @property def End ( self ): \"\"\"Return the end date of this property.\"\"\" return None if self . date is None else self . date . end End property readonly Return the end date of this property. IsRange property readonly Determine if this object represents a date range (versus a single date). Start property readonly Return the start date of this property. __compose__ ( start , end = None ) classmethod special Create a new Date from the native values. Source code in notional/types.py @classmethod def __compose__ ( cls , start , end = None ): \"\"\"Create a new Date from the native values.\"\"\" return cls ( date = DateRange ( start = start , end = end )) __contains__ ( self , other ) special Determine if the given date is in the range (inclusive) of this Date. Raises ValueError if the Date object is not a range - e.g. has no end date. Source code in notional/types.py def __contains__ ( self , other ): \"\"\"Determine if the given date is in the range (inclusive) of this Date. Raises ValueError if the Date object is not a range - e.g. has no end date. \"\"\" if not self . IsRange : raise ValueError ( \"This date is not a range\" ) return self . Start <= other <= self . End __str__ ( self ) special Return a string representation of this property. Source code in notional/types.py def __str__ ( self ): \"\"\"Return a string representation of this property.\"\"\" return \"\" if self . date is None else str ( self . date ) DateFormula ( FormulaResult ) pydantic-model A Notion date formula result. Source code in notional/types.py class DateFormula ( FormulaResult , type = \"date\" ): \"\"\"A Notion date formula result.\"\"\" date : Optional [ DateRange ] = None @property def Result ( self ): \"\"\"Return the result of this DateFormula.\"\"\" return self . date Result property readonly Return the result of this DateFormula. DateRange ( DataObject ) pydantic-model A Notion date range, with an optional end date. Source code in notional/types.py class DateRange ( DataObject ): \"\"\"A Notion date range, with an optional end date.\"\"\" start : Union [ date , datetime ] end : Optional [ Union [ date , datetime ]] = None def __str__ ( self ): \"\"\"Return a string representation of this object.\"\"\" if self . end is None : return f \" { self . start } \" return f \" { self . start } :: { self . end } \" __str__ ( self ) special Return a string representation of this object. Source code in notional/types.py def __str__ ( self ): \"\"\"Return a string representation of this object.\"\"\" if self . end is None : return f \" { self . start } \" return f \" { self . start } :: { self . end } \" Email ( NativeTypeMixin , PropertyValue ) pydantic-model Notion email type. Source code in notional/types.py class Email ( NativeTypeMixin , PropertyValue , type = \"email\" ): \"\"\"Notion email type.\"\"\" email : Optional [ str ] = None EmojiObject ( TypedObject ) pydantic-model A Notion emoji object. Source code in notional/types.py class EmojiObject ( TypedObject , type = \"emoji\" ): \"\"\"A Notion emoji object.\"\"\" emoji : str def __str__ ( self ): \"\"\"Return this EmojiObject as a simple string.\"\"\" return self . emoji @classmethod def __compose__ ( cls , emoji ): \"\"\"Compose an EmojiObject from the given emjoi string.\"\"\" return EmojiObject ( emoji = emoji ) __compose__ ( emoji ) classmethod special Compose an EmojiObject from the given emjoi string. Source code in notional/types.py @classmethod def __compose__ ( cls , emoji ): \"\"\"Compose an EmojiObject from the given emjoi string.\"\"\" return EmojiObject ( emoji = emoji ) __str__ ( self ) special Return this EmojiObject as a simple string. Source code in notional/types.py def __str__ ( self ): \"\"\"Return this EmojiObject as a simple string.\"\"\" return self . emoji EquationObject ( RichTextObject ) pydantic-model Notion equation element. Source code in notional/types.py class EquationObject ( RichTextObject , type = \"equation\" ): \"\"\"Notion equation element.\"\"\" class _NestedData ( NestedObject ): expression : str equation : _NestedData def __str__ ( self ): \"\"\"Return a string representation of this object.\"\"\" if self . equation is None : return None return self . equation . expression ExternalFile ( FileObject ) pydantic-model An external file object. Source code in notional/types.py class ExternalFile ( FileObject , type = \"external\" ): \"\"\"An external file object.\"\"\" class _NestedData ( NestedObject ): url : str external : _NestedData def __str__ ( self ): \"\"\"Return a string representation of this object.\"\"\" name = self . name or \"__unknown__\" if self . external and self . external . url : return f \"![ { name } ]( { self . external . url } )\" return name @classmethod def __compose__ ( cls , url , name = None ): \"\"\"Create a new `ExternalFile` from the given URL.\"\"\" return cls ( name = name , external = cls . _NestedData ( url = url )) __compose__ ( url , name = None ) classmethod special Create a new ExternalFile from the given URL. Source code in notional/types.py @classmethod def __compose__ ( cls , url , name = None ): \"\"\"Create a new `ExternalFile` from the given URL.\"\"\" return cls ( name = name , external = cls . _NestedData ( url = url )) FileObject ( TypedObject ) pydantic-model A Notion file object. Depending on the context, a FileObject may require a name (such as in the Files property). This makes the object heirarchy difficult, so here we simply allow name to be optional. It is the responsibility of the caller to set name if required by the API. Source code in notional/types.py class FileObject ( TypedObject ): \"\"\"A Notion file object. Depending on the context, a FileObject may require a name (such as in the `Files` property). This makes the object heirarchy difficult, so here we simply allow `name` to be optional. It is the responsibility of the caller to set `name` if required by the API. \"\"\" name : Optional [ str ] = None def __str__ ( self ): \"\"\"Return a string representation of this object.\"\"\" return self . name or \"__unknown__\" __str__ ( self ) special Return a string representation of this object. Source code in notional/types.py def __str__ ( self ): \"\"\"Return a string representation of this object.\"\"\" return self . name or \"__unknown__\" Files ( PropertyValue ) pydantic-model Notion files type. Source code in notional/types.py class Files ( PropertyValue , type = \"files\" ): \"\"\"Notion files type.\"\"\" files : List [ FileObject ] = [] def __contains__ ( self , other ): \"\"\"Determine if the given FileObject or name is in the property.\"\"\" if self . files is None : return False for ref in self . files : if ref == other : return True if ref . name == other : return True return False def __str__ ( self ): \"\"\"Return a string representation of this property.\"\"\" return \"; \" . join ([ str ( file ) for file in self . files ]) def __iter__ ( self ): \"\"\"Iterate over the FileObject's in this property.\"\"\" if self . files is None : return None return iter ( self . files ) def __len__ ( self ): \"\"\"Return the number of Files in this property.\"\"\" return len ( self . files ) def __getitem__ ( self , name ): \"\"\"Return the FileObject with the given name.\"\"\" if self . files is None : return None for ref in self . files : if ref . name == name : return ref raise AttributeError ( \"No such file\" ) def __iadd__ ( self , obj ): \"\"\"Append the given `FileObject` in place.\"\"\" if obj in self : raise ValueError ( f \"Item exists: { obj } \" ) self . append ( obj ) return self def __isub__ ( self , obj ): \"\"\"Remove the given `FileObject` in place.\"\"\" if obj not in self : raise ValueError ( f \"No such item: { obj } \" ) self . remove ( obj ) return self def append ( self , obj ): \"\"\"Append the given file reference to this property. :param ref: the `FileObject` to be added \"\"\" log . debug ( \"append file - %s \" , obj ) self . files . append ( obj ) def remove ( self , obj ): \"\"\"Remove the given file reference from this property. :param ref: the `FileObject` to be removed \"\"\" log . debug ( \"remove file - %s \" , obj ) self . files . remove ( obj ) __contains__ ( self , other ) special Determine if the given FileObject or name is in the property. Source code in notional/types.py def __contains__ ( self , other ): \"\"\"Determine if the given FileObject or name is in the property.\"\"\" if self . files is None : return False for ref in self . files : if ref == other : return True if ref . name == other : return True return False __getitem__ ( self , name ) special Return the FileObject with the given name. Source code in notional/types.py def __getitem__ ( self , name ): \"\"\"Return the FileObject with the given name.\"\"\" if self . files is None : return None for ref in self . files : if ref . name == name : return ref raise AttributeError ( \"No such file\" ) __iadd__ ( self , obj ) special Append the given FileObject in place. Source code in notional/types.py def __iadd__ ( self , obj ): \"\"\"Append the given `FileObject` in place.\"\"\" if obj in self : raise ValueError ( f \"Item exists: { obj } \" ) self . append ( obj ) return self __isub__ ( self , obj ) special Remove the given FileObject in place. Source code in notional/types.py def __isub__ ( self , obj ): \"\"\"Remove the given `FileObject` in place.\"\"\" if obj not in self : raise ValueError ( f \"No such item: { obj } \" ) self . remove ( obj ) return self __iter__ ( self ) special Iterate over the FileObject's in this property. Source code in notional/types.py def __iter__ ( self ): \"\"\"Iterate over the FileObject's in this property.\"\"\" if self . files is None : return None return iter ( self . files ) __len__ ( self ) special Return the number of Files in this property. Source code in notional/types.py def __len__ ( self ): \"\"\"Return the number of Files in this property.\"\"\" return len ( self . files ) __str__ ( self ) special Return a string representation of this property. Source code in notional/types.py def __str__ ( self ): \"\"\"Return a string representation of this property.\"\"\" return \"; \" . join ([ str ( file ) for file in self . files ]) append ( self , obj ) Append the given file reference to this property. :param ref: the FileObject to be added Source code in notional/types.py def append ( self , obj ): \"\"\"Append the given file reference to this property. :param ref: the `FileObject` to be added \"\"\" log . debug ( \"append file - %s \" , obj ) self . files . append ( obj ) remove ( self , obj ) Remove the given file reference from this property. :param ref: the FileObject to be removed Source code in notional/types.py def remove ( self , obj ): \"\"\"Remove the given file reference from this property. :param ref: the `FileObject` to be removed \"\"\" log . debug ( \"remove file - %s \" , obj ) self . files . remove ( obj ) Formula ( PropertyValue ) pydantic-model A Notion formula property value. Source code in notional/types.py class Formula ( PropertyValue , type = \"formula\" ): \"\"\"A Notion formula property value.\"\"\" formula : Optional [ FormulaResult ] = None def __str__ ( self ): \"\"\"Return the result of this formula as a string.\"\"\" return str ( self . Result or \"\" ) @property def Result ( self ): \"\"\"Return the result of this Formula in its native type.\"\"\" if self . formula is None : return None return self . formula . Result Result property readonly Return the result of this Formula in its native type. __str__ ( self ) special Return the result of this formula as a string. Source code in notional/types.py def __str__ ( self ): \"\"\"Return the result of this formula as a string.\"\"\" return str ( self . Result or \"\" ) FormulaResult ( TypedObject ) pydantic-model A Notion formula result. This object contains the result of the expression in the database properties. Source code in notional/types.py class FormulaResult ( TypedObject ): \"\"\"A Notion formula result. This object contains the result of the expression in the database properties. \"\"\" def __str__ ( self ): \"\"\"Return the formula result as a string.\"\"\" return self . Result or \"\" @property def Result ( self ): \"\"\"Return the result of this FormulaResult.\"\"\" raise NotImplementedError ( \"Result unavailable\" ) Result property readonly Return the result of this FormulaResult. __str__ ( self ) special Return the formula result as a string. Source code in notional/types.py def __str__ ( self ): \"\"\"Return the formula result as a string.\"\"\" return self . Result or \"\" HostedFile ( FileObject ) pydantic-model A Notion file object. Source code in notional/types.py class HostedFile ( FileObject , type = \"file\" ): \"\"\"A Notion file object.\"\"\" class _NestedData ( NestedObject ): url : str expiry_time : Optional [ datetime ] = None file : _NestedData LastEditedBy ( PropertyValue ) pydantic-model A Notion last-edited-by property value. Source code in notional/types.py class LastEditedBy ( PropertyValue , type = \"last_edited_by\" ): \"\"\"A Notion last-edited-by property value.\"\"\" last_edited_by : User def __str__ ( self ): \"\"\"Return the contents of this property as a string.\"\"\" return str ( self . last_edited_by ) __str__ ( self ) special Return the contents of this property as a string. Source code in notional/types.py def __str__ ( self ): \"\"\"Return the contents of this property as a string.\"\"\" return str ( self . last_edited_by ) LastEditedTime ( NativeTypeMixin , PropertyValue ) pydantic-model A Notion last-edited-time property value. Source code in notional/types.py class LastEditedTime ( NativeTypeMixin , PropertyValue , type = \"last_edited_time\" ): \"\"\"A Notion last-edited-time property value.\"\"\" last_edited_time : datetime MentionData ( TypedObject ) pydantic-model Base class for typed Mention data objects. Source code in notional/types.py class MentionData ( TypedObject ): \"\"\"Base class for typed `Mention` data objects.\"\"\" MentionDatabase ( MentionData ) pydantic-model Nested database information for Mention properties. Source code in notional/types.py class MentionDatabase ( MentionData , type = \"database\" ): \"\"\"Nested database information for `Mention` properties.\"\"\" database : PageReference MentionDate ( MentionData ) pydantic-model Nested date data for Mention properties. Source code in notional/types.py class MentionDate ( MentionData , type = \"date\" ): \"\"\"Nested date data for `Mention` properties.\"\"\" date : DateRange MentionLink ( MentionData ) pydantic-model Nested url data for Mention properties. Source code in notional/types.py class MentionLink ( MentionData , type = \"link_preview\" ): \"\"\"Nested url data for `Mention` properties.\"\"\" url : str MentionObject ( RichTextObject ) pydantic-model Notion mention element. Source code in notional/types.py class MentionObject ( RichTextObject , type = \"mention\" ): \"\"\"Notion mention element.\"\"\" mention : MentionData MentionPage ( MentionData ) pydantic-model Nested page data for Mention properties. Source code in notional/types.py class MentionPage ( MentionData , type = \"page\" ): \"\"\"Nested page data for `Mention` properties.\"\"\" page : PageReference MentionTemplate ( MentionData ) pydantic-model Nested template data for Mention properties. Source code in notional/types.py class MentionTemplate ( MentionData , type = \"template_mention\" ): \"\"\"Nested template data for `Mention` properties.\"\"\" template_mention : MentionTemplateData MentionTemplateData ( TypedObject ) pydantic-model Nested template data for Mention properties. Source code in notional/types.py class MentionTemplateData ( TypedObject ): \"\"\"Nested template data for `Mention` properties.\"\"\" MentionTemplateDate ( MentionTemplateData ) pydantic-model Nested date template data for Mention properties. Source code in notional/types.py class MentionTemplateDate ( MentionTemplateData , type = \"template_mention_date\" ): \"\"\"Nested date template data for `Mention` properties.\"\"\" template_mention_date : str MentionTemplateUser ( MentionTemplateData ) pydantic-model Nested user template data for Mention properties. Source code in notional/types.py class MentionTemplateUser ( MentionTemplateData , type = \"template_mention_user\" ): \"\"\"Nested user template data for `Mention` properties.\"\"\" template_mention_user : str MentionUser ( MentionData ) pydantic-model Nested user data for Mention properties. Source code in notional/types.py class MentionUser ( MentionData , type = \"user\" ): \"\"\"Nested user data for `Mention` properties.\"\"\" user : User MultiSelect ( PropertyValue ) pydantic-model Notion multi-select type. Source code in notional/types.py class MultiSelect ( PropertyValue , type = \"multi_select\" ): \"\"\"Notion multi-select type.\"\"\" multi_select : List [ SelectValue ] = [] def __str__ ( self ): \"\"\"Return a string representation of this property.\"\"\" return \", \" . join ( self . Values ) def __len__ ( self ): \"\"\"Count the number of selected values.\"\"\" return len ( self . multi_select ) def __getitem__ ( self , index ): \"\"\"Return the SelectValue object at the given index.\"\"\" if self . multi_select is None : raise IndexError ( \"empty property\" ) if index > len ( self . multi_select ): raise IndexError ( \"index out of range\" ) return self . multi_select [ index ] def __iadd__ ( self , other ): \"\"\"Add the given option to this MultiSelect.\"\"\" if other in self : raise ValueError ( f \"Duplicate item: { other } \" ) self . append ( other ) return self def __isub__ ( self , other ): \"\"\"Remove the given value from this MultiSelect.\"\"\" if other not in self : raise ValueError ( f \"No such item: { other } \" ) self . remove ( other ) return self def __contains__ ( self , name ): \"\"\"Determine if the given name is in this MultiSelect. To avoid confusion, only names are considered for comparison, not ID's. \"\"\" for opt in self . multi_select : if opt . name == name : return True return False def __iter__ ( self ): \"\"\"Iterate over the SelectValue's in this property.\"\"\" if self . multi_select is None : return None return iter ( self . multi_select ) @classmethod def __compose__ ( cls , value ): \"\"\"Initialize a new MultiSelect from the given value.\"\"\" if isinstance ( value , list ): return cls . _compose_from_list ( * value ) return cls . _compose_from_list ( value ) def append ( self , * values ): \"\"\"Add selected values to this MultiSelect.\"\"\" for value in values : if value is None : raise ValueError ( \"'None' is an invalid value\" ) if value not in self : opt = SelectValue ( name = value ) self . multi_select . append ( opt ) def remove ( self , * values ): \"\"\"Remove selected values from this MultiSelect.\"\"\" self . multi_select = [ opt for opt in self . multi_select if opt . name not in values ] @property def Values ( self ): \"\"\"Return the names of each value in this MultiSelect as a list.\"\"\" if self . multi_select is None : return None return [ str ( val ) for val in self . multi_select if val . name is not None ] @classmethod def _compose_from_list ( cls , * values ): \"\"\"Create a Select block from a list of values. All values in the list will be automatically converted to strings. \"\"\" select = [] for value in values : if value is None : continue select . append ( SelectValue ( name = str ( value ))) return cls ( multi_select = select ) Values property readonly Return the names of each value in this MultiSelect as a list. __compose__ ( value ) classmethod special Initialize a new MultiSelect from the given value. Source code in notional/types.py @classmethod def __compose__ ( cls , value ): \"\"\"Initialize a new MultiSelect from the given value.\"\"\" if isinstance ( value , list ): return cls . _compose_from_list ( * value ) return cls . _compose_from_list ( value ) __contains__ ( self , name ) special Determine if the given name is in this MultiSelect. To avoid confusion, only names are considered for comparison, not ID's. Source code in notional/types.py def __contains__ ( self , name ): \"\"\"Determine if the given name is in this MultiSelect. To avoid confusion, only names are considered for comparison, not ID's. \"\"\" for opt in self . multi_select : if opt . name == name : return True return False __getitem__ ( self , index ) special Return the SelectValue object at the given index. Source code in notional/types.py def __getitem__ ( self , index ): \"\"\"Return the SelectValue object at the given index.\"\"\" if self . multi_select is None : raise IndexError ( \"empty property\" ) if index > len ( self . multi_select ): raise IndexError ( \"index out of range\" ) return self . multi_select [ index ] __iadd__ ( self , other ) special Add the given option to this MultiSelect. Source code in notional/types.py def __iadd__ ( self , other ): \"\"\"Add the given option to this MultiSelect.\"\"\" if other in self : raise ValueError ( f \"Duplicate item: { other } \" ) self . append ( other ) return self __isub__ ( self , other ) special Remove the given value from this MultiSelect. Source code in notional/types.py def __isub__ ( self , other ): \"\"\"Remove the given value from this MultiSelect.\"\"\" if other not in self : raise ValueError ( f \"No such item: { other } \" ) self . remove ( other ) return self __iter__ ( self ) special Iterate over the SelectValue's in this property. Source code in notional/types.py def __iter__ ( self ): \"\"\"Iterate over the SelectValue's in this property.\"\"\" if self . multi_select is None : return None return iter ( self . multi_select ) __len__ ( self ) special Count the number of selected values. Source code in notional/types.py def __len__ ( self ): \"\"\"Count the number of selected values.\"\"\" return len ( self . multi_select ) __str__ ( self ) special Return a string representation of this property. Source code in notional/types.py def __str__ ( self ): \"\"\"Return a string representation of this property.\"\"\" return \", \" . join ( self . Values ) append ( self , * values ) Add selected values to this MultiSelect. Source code in notional/types.py def append ( self , * values ): \"\"\"Add selected values to this MultiSelect.\"\"\" for value in values : if value is None : raise ValueError ( \"'None' is an invalid value\" ) if value not in self : opt = SelectValue ( name = value ) self . multi_select . append ( opt ) remove ( self , * values ) Remove selected values from this MultiSelect. Source code in notional/types.py def remove ( self , * values ): \"\"\"Remove selected values from this MultiSelect.\"\"\" self . multi_select = [ opt for opt in self . multi_select if opt . name not in values ] NativeTypeMixin Mixin class for properties that can be represented as native Python types. Source code in notional/types.py class NativeTypeMixin : \"\"\"Mixin class for properties that can be represented as native Python types.\"\"\" def __str__ ( self ): \"\"\"Return a string representation of this object.\"\"\" value = self . Value if value is None : return \"\" return str ( value ) def __eq__ ( self , other ): \"\"\"Determine if this property is equal to the given object.\"\"\" return self . Value == other def __ne__ ( self , other ): \"\"\"Determine if this property is not equal to the given object.\"\"\" return self . Value != other @classmethod def __compose__ ( cls , value ): \"\"\"Build the property value from the native Python value.\"\"\" # use type-name field to instantiate the class when possible if hasattr ( cls , \"type\" ): return cls ( ** { cls . type : value }) raise NotImplementedError () @property def Value ( self ): \"\"\"Get the current value of this property as a native Python type.\"\"\" cls = self . __class__ # check to see if the object has a field with the type-name # (this is assigned by TypedObject during subclass creation) if hasattr ( cls , \"type\" ) and hasattr ( self , cls . type ): return getattr ( self , cls . type ) raise NotImplementedError () Value property readonly Get the current value of this property as a native Python type. __compose__ ( value ) classmethod special Build the property value from the native Python value. Source code in notional/types.py @classmethod def __compose__ ( cls , value ): \"\"\"Build the property value from the native Python value.\"\"\" # use type-name field to instantiate the class when possible if hasattr ( cls , \"type\" ): return cls ( ** { cls . type : value }) raise NotImplementedError () __eq__ ( self , other ) special Determine if this property is equal to the given object. Source code in notional/types.py def __eq__ ( self , other ): \"\"\"Determine if this property is equal to the given object.\"\"\" return self . Value == other __ne__ ( self , other ) special Determine if this property is not equal to the given object. Source code in notional/types.py def __ne__ ( self , other ): \"\"\"Determine if this property is not equal to the given object.\"\"\" return self . Value != other __str__ ( self ) special Return a string representation of this object. Source code in notional/types.py def __str__ ( self ): \"\"\"Return a string representation of this object.\"\"\" value = self . Value if value is None : return \"\" return str ( value ) Number ( NativeTypeMixin , PropertyValue ) pydantic-model Simple number type. Source code in notional/types.py class Number ( NativeTypeMixin , PropertyValue , type = \"number\" ): \"\"\"Simple number type.\"\"\" number : Optional [ Union [ float , int ]] = None def __iadd__ ( self , other ): \"\"\"Add the given value to this Number.\"\"\" self . number += other return self def __isub__ ( self , other ): \"\"\"Subtract the given value from this Number.\"\"\" self . number -= other return self @property def Value ( self ): \"\"\"Get the current value of this property as a native Python number.\"\"\" if self . number is None : return None if self . number == int ( self . number ): return int ( self . number ) return self . number Value property readonly Get the current value of this property as a native Python number. __iadd__ ( self , other ) special Add the given value to this Number. Source code in notional/types.py def __iadd__ ( self , other ): \"\"\"Add the given value to this Number.\"\"\" self . number += other return self __isub__ ( self , other ) special Subtract the given value from this Number. Source code in notional/types.py def __isub__ ( self , other ): \"\"\"Subtract the given value from this Number.\"\"\" self . number -= other return self NumberFormula ( FormulaResult ) pydantic-model A Notion number formula result. Source code in notional/types.py class NumberFormula ( FormulaResult , type = \"number\" ): \"\"\"A Notion number formula result.\"\"\" number : Optional [ Union [ float , int ]] = None @property def Result ( self ): \"\"\"Return the result of this NumberFormula.\"\"\" return self . number Result property readonly Return the result of this NumberFormula. PageReference ( DataObject ) pydantic-model A page reference is an object with an id property. Source code in notional/types.py class PageReference ( DataObject ): \"\"\"A page reference is an object with an id property.\"\"\" id : UUID @classmethod def __compose__ ( cls , page ): \"\"\"Return the correct page reference based on the object type.\"\"\" if isinstance ( page , str ): return PageReference ( id = page ) if isinstance ( page , UUID ): return PageReference ( id = page ) if hasattr ( page , \"id\" ): return PageReference ( id = page . id ) raise ValueError ( \"Unrecognized 'page' attribute\" ) __compose__ ( page ) classmethod special Return the correct page reference based on the object type. Source code in notional/types.py @classmethod def __compose__ ( cls , page ): \"\"\"Return the correct page reference based on the object type.\"\"\" if isinstance ( page , str ): return PageReference ( id = page ) if isinstance ( page , UUID ): return PageReference ( id = page ) if hasattr ( page , \"id\" ): return PageReference ( id = page . id ) raise ValueError ( \"Unrecognized 'page' attribute\" ) People ( PropertyValue ) pydantic-model Notion people type. Source code in notional/types.py class People ( PropertyValue , type = \"people\" ): \"\"\"Notion people type.\"\"\" people : List [ User ] = [] def __iter__ ( self ): \"\"\"Iterate over the User's in this property.\"\"\" if self . people is None : return None return iter ( self . people ) def __contains__ ( self , other ): \"\"\"Determine if the given User or name is in this People. To avoid confusion, only names are considered for comparison (not ID's). \"\"\" for user in self . people : if user == other : return True if user . name == other : return True return False def __len__ ( self ): \"\"\"Return the number of People in this property.\"\"\" return len ( self . people ) def __getitem__ ( self , index ): \"\"\"Return the People object at the given index.\"\"\" if self . people is None : raise IndexError ( \"empty property\" ) if index > len ( self . people ): raise IndexError ( \"index out of range\" ) return self . people [ index ] def __str__ ( self ): \"\"\"Return a string representation of this property.\"\"\" return \", \" . join ([ str ( user ) for user in self . people ]) __contains__ ( self , other ) special Determine if the given User or name is in this People. To avoid confusion, only names are considered for comparison (not ID's). Source code in notional/types.py def __contains__ ( self , other ): \"\"\"Determine if the given User or name is in this People. To avoid confusion, only names are considered for comparison (not ID's). \"\"\" for user in self . people : if user == other : return True if user . name == other : return True return False __getitem__ ( self , index ) special Return the People object at the given index. Source code in notional/types.py def __getitem__ ( self , index ): \"\"\"Return the People object at the given index.\"\"\" if self . people is None : raise IndexError ( \"empty property\" ) if index > len ( self . people ): raise IndexError ( \"index out of range\" ) return self . people [ index ] __iter__ ( self ) special Iterate over the User's in this property. Source code in notional/types.py def __iter__ ( self ): \"\"\"Iterate over the User's in this property.\"\"\" if self . people is None : return None return iter ( self . people ) __len__ ( self ) special Return the number of People in this property. Source code in notional/types.py def __len__ ( self ): \"\"\"Return the number of People in this property.\"\"\" return len ( self . people ) __str__ ( self ) special Return a string representation of this property. Source code in notional/types.py def __str__ ( self ): \"\"\"Return a string representation of this property.\"\"\" return \", \" . join ([ str ( user ) for user in self . people ]) PhoneNumber ( NativeTypeMixin , PropertyValue ) pydantic-model Notion phone type. Source code in notional/types.py class PhoneNumber ( NativeTypeMixin , PropertyValue , type = \"phone_number\" ): \"\"\"Notion phone type.\"\"\" phone_number : Optional [ str ] = None PropertyValue ( TypedObject ) pydantic-model Base class for Notion property values. Source code in notional/types.py class PropertyValue ( TypedObject ): \"\"\"Base class for Notion property values.\"\"\" id : Optional [ str ] = None Relation ( PropertyValue ) pydantic-model A Notion relation property value. Source code in notional/types.py class Relation ( PropertyValue , type = \"relation\" ): \"\"\"A Notion relation property value.\"\"\" relation : List [ PageReference ] = [] @classmethod def __compose__ ( cls , pages ): \"\"\"Return a `Relation` property with the specified pages.\"\"\" if isinstance ( pages , list ): refs = [ PageReference [ page ] for page in pages ] else : refs = [ PageReference [ pages ]] return cls ( relation = refs ) def __contains__ ( self , page ): \"\"\"Determine if the given page is in this Relation.\"\"\" return PageReference [ page ] in self . relation def __iter__ ( self ): \"\"\"Iterate over the PageReference's in this property.\"\"\" if self . relation is None : return None return iter ( self . relation ) def __len__ ( self ): \"\"\"Return the number of PageReference's in this property.\"\"\" return len ( self . relation ) def __getitem__ ( self , index ): \"\"\"Return the PageReference object at the given index.\"\"\" if self . relation is None : raise IndexError ( \"empty property\" ) if index > len ( self . relation ): raise IndexError ( \"index out of range\" ) return self . relation [ index ] def __iadd__ ( self , page ): \"\"\"Add the given page to this Relation in place.\"\"\" ref = PageReference [ page ] if ref in self . relation : raise ValueError ( f \"Duplicate item: { ref . id } \" ) self . relation . append ( ref ) return self def __isub__ ( self , page ): \"\"\"Remove the given page from this Relation in place.\"\"\" ref = PageReference [ page ] if ref in self . relation : raise ValueError ( f \"No such item: { ref . id } \" ) self . relation . remove ( ref ) return self __compose__ ( pages ) classmethod special Return a Relation property with the specified pages. Source code in notional/types.py @classmethod def __compose__ ( cls , pages ): \"\"\"Return a `Relation` property with the specified pages.\"\"\" if isinstance ( pages , list ): refs = [ PageReference [ page ] for page in pages ] else : refs = [ PageReference [ pages ]] return cls ( relation = refs ) __contains__ ( self , page ) special Determine if the given page is in this Relation. Source code in notional/types.py def __contains__ ( self , page ): \"\"\"Determine if the given page is in this Relation.\"\"\" return PageReference [ page ] in self . relation __getitem__ ( self , index ) special Return the PageReference object at the given index. Source code in notional/types.py def __getitem__ ( self , index ): \"\"\"Return the PageReference object at the given index.\"\"\" if self . relation is None : raise IndexError ( \"empty property\" ) if index > len ( self . relation ): raise IndexError ( \"index out of range\" ) return self . relation [ index ] __iadd__ ( self , page ) special Add the given page to this Relation in place. Source code in notional/types.py def __iadd__ ( self , page ): \"\"\"Add the given page to this Relation in place.\"\"\" ref = PageReference [ page ] if ref in self . relation : raise ValueError ( f \"Duplicate item: { ref . id } \" ) self . relation . append ( ref ) return self __isub__ ( self , page ) special Remove the given page from this Relation in place. Source code in notional/types.py def __isub__ ( self , page ): \"\"\"Remove the given page from this Relation in place.\"\"\" ref = PageReference [ page ] if ref in self . relation : raise ValueError ( f \"No such item: { ref . id } \" ) self . relation . remove ( ref ) return self __iter__ ( self ) special Iterate over the PageReference's in this property. Source code in notional/types.py def __iter__ ( self ): \"\"\"Iterate over the PageReference's in this property.\"\"\" if self . relation is None : return None return iter ( self . relation ) __len__ ( self ) special Return the number of PageReference's in this property. Source code in notional/types.py def __len__ ( self ): \"\"\"Return the number of PageReference's in this property.\"\"\" return len ( self . relation ) RichText ( NativeTypeMixin , PropertyValue ) pydantic-model Notion rich text type. Source code in notional/types.py class RichText ( NativeTypeMixin , PropertyValue , type = \"rich_text\" ): \"\"\"Notion rich text type.\"\"\" rich_text : List [ RichTextObject ] = [] def __len__ ( self ): \"\"\"Return the number of object in the RichText object.\"\"\" return len ( self . rich_text ) @classmethod def __compose__ ( cls , text ): \"\"\"Create a new `RichText` property from the given strings.\"\"\" return cls ( rich_text = [ TextObject [ text ]]) @property def Value ( self ): \"\"\"Return the plain text from this RichText.\"\"\" if self . rich_text is None : return None return plain_text ( * self . rich_text ) Value property readonly Return the plain text from this RichText. __compose__ ( text ) classmethod special Create a new RichText property from the given strings. Source code in notional/types.py @classmethod def __compose__ ( cls , text ): \"\"\"Create a new `RichText` property from the given strings.\"\"\" return cls ( rich_text = [ TextObject [ text ]]) __len__ ( self ) special Return the number of object in the RichText object. Source code in notional/types.py def __len__ ( self ): \"\"\"Return the number of object in the RichText object.\"\"\" return len ( self . rich_text ) Rollup ( PropertyValue ) pydantic-model A Notion rollup property value. Source code in notional/types.py class Rollup ( PropertyValue , type = \"rollup\" ): \"\"\"A Notion rollup property value.\"\"\" rollup : Optional [ RollupObject ] = None def __str__ ( self ): \"\"\"Return a string representation of this Rollup property.\"\"\" if self . rollup is None : return \"\" value = self . rollup . Value if value is None : return \"\" return str ( value ) __str__ ( self ) special Return a string representation of this Rollup property. Source code in notional/types.py def __str__ ( self ): \"\"\"Return a string representation of this Rollup property.\"\"\" if self . rollup is None : return \"\" value = self . rollup . Value if value is None : return \"\" return str ( value ) RollupArray ( RollupObject ) pydantic-model A Notion rollup array property value. Source code in notional/types.py class RollupArray ( RollupObject , type = \"array\" ): \"\"\"A Notion rollup array property value.\"\"\" array : List [ PropertyValue ] @property def Value ( self ): \"\"\"Return the native representation of this Rollup object.\"\"\" return self . array Value property readonly Return the native representation of this Rollup object. RollupDate ( RollupObject ) pydantic-model A Notion rollup date property value. Source code in notional/types.py class RollupDate ( RollupObject , type = \"date\" ): \"\"\"A Notion rollup date property value.\"\"\" date : Optional [ DateRange ] = None @property def Value ( self ): \"\"\"Return the native representation of this Rollup object.\"\"\" return self . date Value property readonly Return the native representation of this Rollup object. RollupNumber ( RollupObject ) pydantic-model A Notion rollup number property value. Source code in notional/types.py class RollupNumber ( RollupObject , type = \"number\" ): \"\"\"A Notion rollup number property value.\"\"\" number : Optional [ Union [ float , int ]] = None @property def Value ( self ): \"\"\"Return the native representation of this Rollup object.\"\"\" return self . number Value property readonly Return the native representation of this Rollup object. RollupObject ( TypedObject , ABC ) pydantic-model A Notion rollup property value. Source code in notional/types.py class RollupObject ( TypedObject , ABC ): \"\"\"A Notion rollup property value.\"\"\" function : Optional [ Function ] = None @property @abstractmethod def Value ( self ): \"\"\"Return the native representation of this Rollup object.\"\"\" Value property readonly Return the native representation of this Rollup object. SelectOne ( NativeTypeMixin , PropertyValue ) pydantic-model Notion select type. Source code in notional/types.py class SelectOne ( NativeTypeMixin , PropertyValue , type = \"select\" ): \"\"\"Notion select type.\"\"\" select : Optional [ SelectValue ] = None def __str__ ( self ): \"\"\"Return a string representation of this property.\"\"\" return self . Value or \"\" def __eq__ ( self , other ): \"\"\"Determine if this property is equal to the given object. To avoid confusion, this method compares Select options by name. \"\"\" if self . select is None : return other is None return other == self . select . name @classmethod def __compose__ ( cls , value ): \"\"\"Create a `SelectOne` property from the given value. :param value: a string to use for this property \"\"\" if value is None : raise ValueError ( \"'name' cannot be None\" ) return cls ( select = SelectValue ( name = value )) @property def Value ( self ): \"\"\"Return the value of this property as a string.\"\"\" if self . select is None : return None return str ( self . select ) Value property readonly Return the value of this property as a string. __compose__ ( value ) classmethod special Create a SelectOne property from the given value. :param value: a string to use for this property Source code in notional/types.py @classmethod def __compose__ ( cls , value ): \"\"\"Create a `SelectOne` property from the given value. :param value: a string to use for this property \"\"\" if value is None : raise ValueError ( \"'name' cannot be None\" ) return cls ( select = SelectValue ( name = value )) __eq__ ( self , other ) special Determine if this property is equal to the given object. To avoid confusion, this method compares Select options by name. Source code in notional/types.py def __eq__ ( self , other ): \"\"\"Determine if this property is equal to the given object. To avoid confusion, this method compares Select options by name. \"\"\" if self . select is None : return other is None return other == self . select . name __str__ ( self ) special Return a string representation of this property. Source code in notional/types.py def __str__ ( self ): \"\"\"Return a string representation of this property.\"\"\" return self . Value or \"\" SelectValue ( DataObject ) pydantic-model Values for select & multi-select properties. Source code in notional/types.py class SelectValue ( DataObject ): \"\"\"Values for select & multi-select properties.\"\"\" name : str id : Optional [ Union [ UUID , str ]] = None color : Optional [ Color ] = None def __str__ ( self ): \"\"\"Return a string representation of this property.\"\"\" return self . name __str__ ( self ) special Return a string representation of this property. Source code in notional/types.py def __str__ ( self ): \"\"\"Return a string representation of this property.\"\"\" return self . name StringFormula ( FormulaResult ) pydantic-model A Notion string formula result. Source code in notional/types.py class StringFormula ( FormulaResult , type = \"string\" ): \"\"\"A Notion string formula result.\"\"\" string : Optional [ str ] = None @property def Result ( self ): \"\"\"Return the result of this StringFormula.\"\"\" return self . string Result property readonly Return the result of this StringFormula. Title ( NativeTypeMixin , PropertyValue ) pydantic-model Notion title type. Source code in notional/types.py class Title ( NativeTypeMixin , PropertyValue , type = \"title\" ): \"\"\"Notion title type.\"\"\" title : List [ RichTextObject ] = [] def __len__ ( self ): \"\"\"Return the number of object in the Title object.\"\"\" return len ( self . title ) @classmethod def __compose__ ( cls , text ): \"\"\"Create a new `Title` property from the given text.\"\"\" return cls ( title = [ TextObject [ text ]]) @property def Value ( self ): \"\"\"Return the plain text from this Title.\"\"\" if self . title is None : return None return plain_text ( * self . title ) Value property readonly Return the plain text from this Title. __compose__ ( text ) classmethod special Create a new Title property from the given text. Source code in notional/types.py @classmethod def __compose__ ( cls , text ): \"\"\"Create a new `Title` property from the given text.\"\"\" return cls ( title = [ TextObject [ text ]]) __len__ ( self ) special Return the number of object in the Title object. Source code in notional/types.py def __len__ ( self ): \"\"\"Return the number of object in the Title object.\"\"\" return len ( self . title ) URL ( NativeTypeMixin , PropertyValue ) pydantic-model Notion URL type. Source code in notional/types.py class URL ( NativeTypeMixin , PropertyValue , type = \"url\" ): \"\"\"Notion URL type.\"\"\" url : Optional [ str ] = None user Wrapper for Notion user objects. Bot ( User ) pydantic-model Represents a Bot in Notion. Source code in notional/user.py class Bot ( User ): \"\"\"Represents a Bot in Notion.\"\"\" class _NestedData ( NestedObject ): pass bot : _NestedData = None def __str__ ( self ): \"\"\"Return a string representation of this `Bot`.\"\"\" return f \"[% { self . name } ]\" __str__ ( self ) special Return a string representation of this Bot . Source code in notional/user.py def __str__ ( self ): \"\"\"Return a string representation of this `Bot`.\"\"\" return f \"[% { self . name } ]\" Person ( User ) pydantic-model Represents a Person in Notion. Source code in notional/user.py class Person ( User ): \"\"\"Represents a Person in Notion.\"\"\" class _NestedData ( NestedObject ): email : str person : _NestedData = None def __str__ ( self ): \"\"\"Return a string representation of this `Person`.\"\"\" return f \"[@ { self . name } ]\" __str__ ( self ) special Return a string representation of this Person . Source code in notional/user.py def __str__ ( self ): \"\"\"Return a string representation of this `Person`.\"\"\" return f \"[@ { self . name } ]\" User ( DataObject ) pydantic-model Represents a User in Notion. Source code in notional/user.py class User ( DataObject ): \"\"\"Represents a User in Notion.\"\"\" # XXX why isn't this a TypedObject ? id : UUID object : str = \"user\" type : Optional [ UserType ] = None name : Optional [ str ] = None avatar_url : Optional [ str ] = None @classmethod def parse_obj ( cls , obj ): \"\"\"Attempt to parse the given object data into the correct `User` type.\"\"\" if obj is None : return None if \"type\" in obj : if obj [ \"type\" ] == \"person\" : return Person ( ** obj ) if obj [ \"type\" ] == \"bot\" : return Bot ( ** obj ) return cls ( obj ) parse_obj ( obj ) classmethod Attempt to parse the given object data into the correct User type. Source code in notional/user.py @classmethod def parse_obj ( cls , obj ): \"\"\"Attempt to parse the given object data into the correct `User` type.\"\"\" if obj is None : return None if \"type\" in obj : if obj [ \"type\" ] == \"person\" : return Person ( ** obj ) if obj [ \"type\" ] == \"bot\" : return Bot ( ** obj ) return cls ( obj ) UserType ( str , Enum ) Available user types. Source code in notional/user.py class UserType ( str , Enum ): \"\"\"Available user types.\"\"\" PERSON = \"person\" BOT = \"bot\" version Consistent version information for notional.","title":"Overview"},{"location":"reference/#notional.connect","text":"Connect to Notion using the provided integration token. Source code in notional/__init__.py def connect ( ** kwargs ): \"\"\"Connect to Notion using the provided integration token.\"\"\" log . debug ( \"connecting to Notion...\" ) return Session ( ** kwargs )","title":"connect()"},{"location":"reference/#notional.__main__","text":"Main entry point for notional. At the moment, this simply prints the current version and exits.","title":"__main__"},{"location":"reference/#notional.blocks","text":"Wrapper for Notion API blocks. Blocks are specifc records that hold content. Similar to other records, these object provide access to the primitive data structure used in the Notion API as well as higher-level methods.","title":"blocks"},{"location":"reference/#notional.blocks.Block","text":"A standard block object in Notion. Calling the block will expose the nested data in the object. Source code in notional/blocks.py class Block ( Record , TypedObject , object = \"block\" ): \"\"\"A standard block object in Notion. Calling the block will expose the nested data in the object. \"\"\"","title":"Block"},{"location":"reference/#notional.blocks.Bookmark","text":"A bookmark block in Notion. Source code in notional/blocks.py class Bookmark ( Block , type = \"bookmark\" ): \"\"\"A bookmark block in Notion.\"\"\" class _NestedData ( NestedObject ): url : str = None caption : Optional [ List [ RichTextObject ]] = None bookmark : _NestedData = _NestedData () @classmethod def __compose__ ( cls , url ): \"\"\"Compoase a new `Bookmark` block from a specific URL.\"\"\" return Bookmark ( bookmark = Bookmark . _NestedData ( url = url )) @property def URL ( self ): \"\"\"Return the URL contained in this `Bookmark` block.\"\"\" return self . bookmark . url @property def Markdown ( self ): \"\"\"Return the contents of this block as markdown text.\"\"\" if self . bookmark and self . bookmark . url : return f \"< { self . bookmark . url } >\" return \"\"","title":"Bookmark"},{"location":"reference/#notional.blocks.Bookmark.Markdown","text":"Return the contents of this block as markdown text.","title":"Markdown"},{"location":"reference/#notional.blocks.Bookmark.URL","text":"Return the URL contained in this Bookmark block.","title":"URL"},{"location":"reference/#notional.blocks.Bookmark.__compose__","text":"Compoase a new Bookmark block from a specific URL. Source code in notional/blocks.py @classmethod def __compose__ ( cls , url ): \"\"\"Compoase a new `Bookmark` block from a specific URL.\"\"\" return Bookmark ( bookmark = Bookmark . _NestedData ( url = url ))","title":"__compose__()"},{"location":"reference/#notional.blocks.Breadcrumb","text":"A breadcrumb block in Notion. Source code in notional/blocks.py class Breadcrumb ( Block , type = \"breadcrumb\" ): \"\"\"A breadcrumb block in Notion.\"\"\" class _NestedData ( NestedObject ): pass breadcrumb : _NestedData = _NestedData ()","title":"Breadcrumb"},{"location":"reference/#notional.blocks.BulletedListItem","text":"A bulleted list item in Notion. Source code in notional/blocks.py class BulletedListItem ( TextBlock , WithChildrenMixin , type = \"bulleted_list_item\" ): \"\"\"A bulleted list item in Notion.\"\"\" class _NestedData ( NestedObject ): rich_text : List [ RichTextObject ] = [] children : Optional [ List [ Block ]] = None color : FullColor = FullColor . DEFAULT bulleted_list_item : _NestedData = _NestedData () @property def Markdown ( self ): \"\"\"Return the contents of this block as markdown text.\"\"\" if self . bulleted_list_item and self . bulleted_list_item . rich_text : return f \"- { markdown ( * self . bulleted_list_item . rich_text ) } \" return \"\"","title":"BulletedListItem"},{"location":"reference/#notional.blocks.BulletedListItem.Markdown","text":"Return the contents of this block as markdown text.","title":"Markdown"},{"location":"reference/#notional.blocks.Callout","text":"A callout block in Notion. Source code in notional/blocks.py class Callout ( TextBlock , WithChildrenMixin , type = \"callout\" ): \"\"\"A callout block in Notion.\"\"\" class _NestedData ( NestedObject ): rich_text : List [ RichTextObject ] = [] children : Optional [ List [ Block ]] = None icon : Optional [ Union [ FileObject , EmojiObject ]] = None color : FullColor = FullColor . DEFAULT callout : _NestedData = _NestedData ()","title":"Callout"},{"location":"reference/#notional.blocks.ChildDatabase","text":"A child database block in Notion. Source code in notional/blocks.py class ChildDatabase ( Block , type = \"child_database\" ): \"\"\"A child database block in Notion.\"\"\" class _NestedData ( NestedObject ): title : str = None child_database : _NestedData = _NestedData ()","title":"ChildDatabase"},{"location":"reference/#notional.blocks.ChildPage","text":"A child page block in Notion. Source code in notional/blocks.py class ChildPage ( Block , type = \"child_page\" ): \"\"\"A child page block in Notion.\"\"\" class _NestedData ( NestedObject ): title : str = None child_page : _NestedData = _NestedData ()","title":"ChildPage"},{"location":"reference/#notional.blocks.Code","text":"A code block in Notion. Source code in notional/blocks.py class Code ( TextBlock , type = \"code\" ): \"\"\"A code block in Notion.\"\"\" class _NestedData ( NestedObject ): rich_text : List [ RichTextObject ] = [] caption : List [ RichTextObject ] = [] language : CodingLanguage = CodingLanguage . PLAIN_TEXT code : _NestedData = _NestedData () @classmethod def __compose__ ( cls , text , lang = CodingLanguage . PLAIN_TEXT ): \"\"\"Compose a `Code` block from the given text and language.\"\"\" return Code ( code = Code . _NestedData ( rich_text = [ TextObject [ text ]], language = lang , ) ) @property def Markdown ( self ): \"\"\"Return the contents of this block as markdown text.\"\"\" lang = self . code . language if self . code and self . code . language else \"\" # FIXME this is not the standard way to represent code blocks in markdown... if self . code and self . code . rich_text : return f \"``` { lang } \\n { markdown ( * self . code . rich_text ) } \\n ```\" return \"\"","title":"Code"},{"location":"reference/#notional.blocks.Code.Markdown","text":"Return the contents of this block as markdown text.","title":"Markdown"},{"location":"reference/#notional.blocks.Code.__compose__","text":"Compose a Code block from the given text and language. Source code in notional/blocks.py @classmethod def __compose__ ( cls , text , lang = CodingLanguage . PLAIN_TEXT ): \"\"\"Compose a `Code` block from the given text and language.\"\"\" return Code ( code = Code . _NestedData ( rich_text = [ TextObject [ text ]], language = lang , ) )","title":"__compose__()"},{"location":"reference/#notional.blocks.Column","text":"A column block in Notion. Source code in notional/blocks.py class Column ( Block , type = \"column\" ): \"\"\"A column block in Notion.\"\"\" class _NestedData ( NestedObject ): pass column : _NestedData = _NestedData ()","title":"Column"},{"location":"reference/#notional.blocks.ColumnList","text":"A column list block in Notion. Source code in notional/blocks.py class ColumnList ( Block , type = \"column_list\" ): \"\"\"A column list block in Notion.\"\"\" class _NestedData ( NestedObject ): pass column_list : _NestedData = _NestedData ()","title":"ColumnList"},{"location":"reference/#notional.blocks.Divider","text":"A divider block in Notion. Source code in notional/blocks.py class Divider ( Block , type = \"divider\" ): \"\"\"A divider block in Notion.\"\"\" divider : Any = {} @property def Markdown ( self ): \"\"\"Return the contents of this block as markdown text.\"\"\" return \"---\"","title":"Divider"},{"location":"reference/#notional.blocks.Divider.Markdown","text":"Return the contents of this block as markdown text.","title":"Markdown"},{"location":"reference/#notional.blocks.Embed","text":"An embed block in Notion. Source code in notional/blocks.py class Embed ( Block , type = \"embed\" ): \"\"\"An embed block in Notion.\"\"\" class _NestedData ( NestedObject ): url : str = None embed : _NestedData = _NestedData () @classmethod def __compose__ ( cls , url ): \"\"\"Create a new `Embed` block from the given URL.\"\"\" return Embed ( embed = Embed . _NestedData ( url = url )) @property def URL ( self ): \"\"\"Return the URL contained in this `Embed` block.\"\"\" return self . embed . url @property def Markdown ( self ): \"\"\"Return the contents of this block as markdown text.\"\"\" if self . embed and self . embed . url : return f \"< { self . embed . url } >\" return \"\"","title":"Embed"},{"location":"reference/#notional.blocks.Embed.Markdown","text":"Return the contents of this block as markdown text.","title":"Markdown"},{"location":"reference/#notional.blocks.Embed.URL","text":"Return the URL contained in this Embed block.","title":"URL"},{"location":"reference/#notional.blocks.Embed.__compose__","text":"Create a new Embed block from the given URL. Source code in notional/blocks.py @classmethod def __compose__ ( cls , url ): \"\"\"Create a new `Embed` block from the given URL.\"\"\" return Embed ( embed = Embed . _NestedData ( url = url ))","title":"__compose__()"},{"location":"reference/#notional.blocks.File","text":"A file block in Notion. Source code in notional/blocks.py class File ( Block , type = \"file\" ): \"\"\"A file block in Notion.\"\"\" file : FileObject = None","title":"File"},{"location":"reference/#notional.blocks.Heading1","text":"A heading_1 block in Notion. Source code in notional/blocks.py class Heading1 ( TextBlock , type = \"heading_1\" ): \"\"\"A heading_1 block in Notion.\"\"\" class _NestedData ( NestedObject ): rich_text : List [ RichTextObject ] = [] color : FullColor = FullColor . DEFAULT heading_1 : _NestedData = _NestedData () @property def Markdown ( self ): \"\"\"Return the contents of this block as markdown text.\"\"\" if self . heading_1 and self . heading_1 . rich_text : return f \"# { markdown ( * self . heading_1 . rich_text ) } #\" return \"\"","title":"Heading1"},{"location":"reference/#notional.blocks.Heading1.Markdown","text":"Return the contents of this block as markdown text.","title":"Markdown"},{"location":"reference/#notional.blocks.Heading2","text":"A heading_2 block in Notion. Source code in notional/blocks.py class Heading2 ( TextBlock , type = \"heading_2\" ): \"\"\"A heading_2 block in Notion.\"\"\" class _NestedData ( NestedObject ): rich_text : List [ RichTextObject ] = [] color : FullColor = FullColor . DEFAULT heading_2 : _NestedData = _NestedData () @property def Markdown ( self ): \"\"\"Return the contents of this block as markdown text.\"\"\" if self . heading_2 and self . heading_2 . rich_text : return f \"## { markdown ( * self . heading_2 . rich_text ) } ##\" return \"\"","title":"Heading2"},{"location":"reference/#notional.blocks.Heading2.Markdown","text":"Return the contents of this block as markdown text.","title":"Markdown"},{"location":"reference/#notional.blocks.Heading3","text":"A heading_3 block in Notion. Source code in notional/blocks.py class Heading3 ( TextBlock , type = \"heading_3\" ): \"\"\"A heading_3 block in Notion.\"\"\" class _NestedData ( NestedObject ): rich_text : List [ RichTextObject ] = [] color : FullColor = FullColor . DEFAULT heading_3 : _NestedData = _NestedData () @property def Markdown ( self ): \"\"\"Return the contents of this block as markdown text.\"\"\" if self . heading_3 and self . heading_3 . rich_text : return f \"### { markdown ( * self . heading_3 . rich_text ) } ###\" return \"\"","title":"Heading3"},{"location":"reference/#notional.blocks.Heading3.Markdown","text":"Return the contents of this block as markdown text.","title":"Markdown"},{"location":"reference/#notional.blocks.Image","text":"An image block in Notion. Source code in notional/blocks.py class Image ( Block , type = \"image\" ): \"\"\"An image block in Notion.\"\"\" image : FileObject = None","title":"Image"},{"location":"reference/#notional.blocks.LinkPreview","text":"A link_preview block in Notion. Source code in notional/blocks.py class LinkPreview ( Block , type = \"link_preview\" ): \"\"\"A link_preview block in Notion.\"\"\" class _NestedData ( NestedObject ): url : str = None link_preview : _NestedData = _NestedData () @classmethod def __compose__ ( cls , url ): \"\"\"Create a new `LinkPreview` block from the given URL.\"\"\" return LinkPreview ( link_preview = LinkPreview . _NestedData ( url = url )) @property def URL ( self ): \"\"\"Return the URL contained in this `LinkPreview` block.\"\"\" return self . link_preview . url @property def Markdown ( self ): \"\"\"Return the contents of this block as markdown text.\"\"\" if self . link_preview and self . link_preview . url : return f \"< { self . link_preview . url } >\" return \"\"","title":"LinkPreview"},{"location":"reference/#notional.blocks.LinkPreview.Markdown","text":"Return the contents of this block as markdown text.","title":"Markdown"},{"location":"reference/#notional.blocks.LinkPreview.URL","text":"Return the URL contained in this LinkPreview block.","title":"URL"},{"location":"reference/#notional.blocks.LinkPreview.__compose__","text":"Create a new LinkPreview block from the given URL. Source code in notional/blocks.py @classmethod def __compose__ ( cls , url ): \"\"\"Create a new `LinkPreview` block from the given URL.\"\"\" return LinkPreview ( link_preview = LinkPreview . _NestedData ( url = url ))","title":"__compose__()"},{"location":"reference/#notional.blocks.LinkToPage","text":"A link_to_page block in Notion. Source code in notional/blocks.py class LinkToPage ( Block , type = \"link_to_page\" ): \"\"\"A link_to_page block in Notion.\"\"\" link_to_page : ParentRef","title":"LinkToPage"},{"location":"reference/#notional.blocks.NumberedListItem","text":"A numbered list item in Notion. Source code in notional/blocks.py class NumberedListItem ( TextBlock , WithChildrenMixin , type = \"numbered_list_item\" ): \"\"\"A numbered list item in Notion.\"\"\" class _NestedData ( NestedObject ): rich_text : List [ RichTextObject ] = [] children : Optional [ List [ Block ]] = None color : FullColor = FullColor . DEFAULT numbered_list_item : _NestedData = _NestedData () @property def Markdown ( self ): \"\"\"Return the contents of this block as markdown text.\"\"\" if self . numbered_list_item and self . numbered_list_item . rich_text : return f \"1. { markdown ( * self . numbered_list_item . rich_text ) } \" return \"\"","title":"NumberedListItem"},{"location":"reference/#notional.blocks.NumberedListItem.Markdown","text":"Return the contents of this block as markdown text.","title":"Markdown"},{"location":"reference/#notional.blocks.PDF","text":"A pdf block in Notion. Source code in notional/blocks.py class PDF ( Block , type = \"pdf\" ): \"\"\"A pdf block in Notion.\"\"\" pdf : FileObject = None","title":"PDF"},{"location":"reference/#notional.blocks.Paragraph","text":"A paragraph block in Notion. Source code in notional/blocks.py class Paragraph ( TextBlock , WithChildrenMixin , type = \"paragraph\" ): \"\"\"A paragraph block in Notion.\"\"\" class _NestedData ( NestedObject ): rich_text : List [ RichTextObject ] = [] children : Optional [ List [ Block ]] = None color : FullColor = FullColor . DEFAULT paragraph : _NestedData = _NestedData () @property def Markdown ( self ): \"\"\"Return the contents of this block as markdown text.\"\"\" if self . paragraph and self . paragraph . rich_text : return markdown ( * self . paragraph . rich_text ) return \"\"","title":"Paragraph"},{"location":"reference/#notional.blocks.Paragraph.Markdown","text":"Return the contents of this block as markdown text.","title":"Markdown"},{"location":"reference/#notional.blocks.Quote","text":"A quote block in Notion. Source code in notional/blocks.py class Quote ( TextBlock , WithChildrenMixin , type = \"quote\" ): \"\"\"A quote block in Notion.\"\"\" class _NestedData ( NestedObject ): rich_text : List [ RichTextObject ] = [] children : Optional [ List [ Block ]] = None color : FullColor = FullColor . DEFAULT quote : _NestedData = _NestedData () @property def Markdown ( self ): \"\"\"Return the contents of this block as markdown text.\"\"\" if self . quote and self . quote . rich_text : return \"> \" + markdown ( * self . quote . rich_text ) return \"\"","title":"Quote"},{"location":"reference/#notional.blocks.Quote.Markdown","text":"Return the contents of this block as markdown text.","title":"Markdown"},{"location":"reference/#notional.blocks.SyncedBlock","text":"A synced_block block in Notion - either original or synced. Source code in notional/blocks.py class SyncedBlock ( Block , WithChildrenMixin , type = \"synced_block\" ): \"\"\"A synced_block block in Notion - either original or synced.\"\"\" class _NestedData ( NestedObject ): synced_from : Optional [ BlockRef ] = None children : Optional [ List [ Block ]] = None synced_block : _NestedData = _NestedData () @property def IsOriginal ( self ): \"\"\"Determine if this block represents the original content. If this method returns `False`, the block represents the sync'ed block. \"\"\" return self . synced_block . synced_from is None","title":"SyncedBlock"},{"location":"reference/#notional.blocks.SyncedBlock.IsOriginal","text":"Determine if this block represents the original content. If this method returns False , the block represents the sync'ed block.","title":"IsOriginal"},{"location":"reference/#notional.blocks.Table","text":"A table block in Notion. Source code in notional/blocks.py class Table ( Block , WithChildrenMixin , type = \"table\" ): \"\"\"A table block in Notion.\"\"\" class _NestedData ( NestedObject ): table_width : int = 0 has_column_header : bool = False has_row_header : bool = False # note that children will not be populated when getting this block # https://developers.notion.com/reference/block#table-blocks children : Optional [ List [ TableRow ]] = [] table : _NestedData = _NestedData () def append ( self , block : TableRow ): \"\"\"Append the given row to this table. This method is only applicable when creating a new `Table` block. In order to add rows to an existing `Table`, use the `blocks.children.append()` endpoint. When adding a row, this method will rase an exception if the width does not match the expected number of cells for existing rows in the block. \"\"\" # XXX need to review whether this is applicable during update... may need # to raise an error if the block has already been created on the server if not isinstance ( block , TableRow ): raise ValueError ( \"Only TableRow may be appended to Table blocks.\" ) if self . Width == 0 : self . table . table_width = block . Width elif self . Width != block . Width : raise ValueError ( \"Number of cells in row must match table\" ) self . table . children . append ( block ) @property def Width ( self ): \"\"\"Return the current width of this table.\"\"\" return self . table . table_width","title":"Table"},{"location":"reference/#notional.blocks.Table.Width","text":"Return the current width of this table.","title":"Width"},{"location":"reference/#notional.blocks.Table.append","text":"Append the given row to this table. This method is only applicable when creating a new Table block. In order to add rows to an existing Table , use the blocks.children.append() endpoint. When adding a row, this method will rase an exception if the width does not match the expected number of cells for existing rows in the block. Source code in notional/blocks.py def append ( self , block : TableRow ): \"\"\"Append the given row to this table. This method is only applicable when creating a new `Table` block. In order to add rows to an existing `Table`, use the `blocks.children.append()` endpoint. When adding a row, this method will rase an exception if the width does not match the expected number of cells for existing rows in the block. \"\"\" # XXX need to review whether this is applicable during update... may need # to raise an error if the block has already been created on the server if not isinstance ( block , TableRow ): raise ValueError ( \"Only TableRow may be appended to Table blocks.\" ) if self . Width == 0 : self . table . table_width = block . Width elif self . Width != block . Width : raise ValueError ( \"Number of cells in row must match table\" ) self . table . children . append ( block )","title":"append()"},{"location":"reference/#notional.blocks.TableOfContents","text":"A table_of_contents block in Notion. Source code in notional/blocks.py class TableOfContents ( Block , type = \"table_of_contents\" ): \"\"\"A table_of_contents block in Notion.\"\"\" class _NestedData ( NestedObject ): color : FullColor = FullColor . DEFAULT table_of_contents : _NestedData = _NestedData ()","title":"TableOfContents"},{"location":"reference/#notional.blocks.TableRow","text":"A table_row block in Notion. Source code in notional/blocks.py class TableRow ( Block , type = \"table_row\" ): \"\"\"A table_row block in Notion.\"\"\" class _NestedData ( NestedObject ): cells : List [ List [ RichTextObject ]] = None table_row : _NestedData = _NestedData () def append ( self , text ): \"\"\"Append the given text as a new cell in this `TableRow`. `text` may be a string, `RichTextObject` or a list of `RichTextObject`'s. :param text: the text content to append \"\"\" if self . table_row . cells is None : self . table_row . cells = [] if isinstance ( text , list ): self . table_row . cells . append ( list ) elif isinstance ( text , RichTextObject ): self . table_row . cells . append ([ text ]) else : rtf = TextObject . from_value ( text ) self . table_row . cells . append ([ rtf ]) @property def Width ( self ): \"\"\"Return the width (number of cells) in this `TableRow`.\"\"\" return len ( self . table_row . cells ) if self . table_row . cells else 0","title":"TableRow"},{"location":"reference/#notional.blocks.TableRow.Width","text":"Return the width (number of cells) in this TableRow .","title":"Width"},{"location":"reference/#notional.blocks.TableRow.append","text":"Append the given text as a new cell in this TableRow . text may be a string, RichTextObject or a list of RichTextObject 's. :param text: the text content to append Source code in notional/blocks.py def append ( self , text ): \"\"\"Append the given text as a new cell in this `TableRow`. `text` may be a string, `RichTextObject` or a list of `RichTextObject`'s. :param text: the text content to append \"\"\" if self . table_row . cells is None : self . table_row . cells = [] if isinstance ( text , list ): self . table_row . cells . append ( list ) elif isinstance ( text , RichTextObject ): self . table_row . cells . append ([ text ]) else : rtf = TextObject . from_value ( text ) self . table_row . cells . append ([ rtf ])","title":"append()"},{"location":"reference/#notional.blocks.Template","text":"A template block in Notion. Source code in notional/blocks.py class Template ( Block , WithChildrenMixin , type = \"template\" ): \"\"\"A template block in Notion.\"\"\" class _NestedData ( NestedObject ): rich_text : Optional [ List [ RichTextObject ]] = None children : Optional [ List [ Block ]] = None template : _NestedData = _NestedData ()","title":"Template"},{"location":"reference/#notional.blocks.TextBlock","text":"A standard text block object in Notion. Source code in notional/blocks.py class TextBlock ( Block , ABC ): \"\"\"A standard text block object in Notion.\"\"\" # text blocks have a nested object with 'type' name and a 'text' child @property def __text__ ( self ): \"\"\"Provide short-hand access to the nested text content in this block.\"\"\" return self ( \"rich_text\" ) @classmethod def __compose__ ( cls , text ): \"\"\"Compose a `TextBlock` from the given text.\"\"\" if text is None : return None obj = cls () obj . concat ( text ) return obj def concat ( self , * text ): \"\"\"Concatenate text (either `RichTextObject` or `str` items) to this block.\"\"\" nested = self () if not hasattr ( nested , \"rich_text\" ): raise AttributeError ( \"nested data does not contain text\" ) if nested . rich_text is None : nested . rich_text = [] for obj in text : if obj is None : continue self . _append_object ( obj ) def _append_object ( self , obj ): \"\"\"Append the given object to the internal text of this TextObject.\"\"\" if isinstance ( obj , RichTextObject ): self . _append_rtf ( obj ) elif isinstance ( obj , str ): self . _append_text ( obj ) else : raise ValueError ( \"unsupported text object\" ) def _append_rtf ( self , rtf ): \"\"\"Append the given RichTextObject to this TextObject.\"\"\" nested = self () nested . rich_text . append ( rtf ) def _append_text ( self , text ): \"\"\"Append the given text to this TextObject. This text will be split into chunks in accordance with the Notion API. \"\"\" nested = self () # break up the text and compose new TextObject's from the pieces for chunk in chunky ( text ): obj = TextObject [ chunk ] nested . rich_text . append ( obj ) @property def PlainText ( self ): \"\"\"Return the contents of this Block as plain text.\"\"\" content = self . __text__ return None if content is None else plain_text ( * content )","title":"TextBlock"},{"location":"reference/#notional.blocks.TextBlock.PlainText","text":"Return the contents of this Block as plain text.","title":"PlainText"},{"location":"reference/#notional.blocks.TextBlock.__text__","text":"Provide short-hand access to the nested text content in this block.","title":"__text__"},{"location":"reference/#notional.blocks.TextBlock.__compose__","text":"Compose a TextBlock from the given text. Source code in notional/blocks.py @classmethod def __compose__ ( cls , text ): \"\"\"Compose a `TextBlock` from the given text.\"\"\" if text is None : return None obj = cls () obj . concat ( text ) return obj","title":"__compose__()"},{"location":"reference/#notional.blocks.TextBlock.concat","text":"Concatenate text (either RichTextObject or str items) to this block. Source code in notional/blocks.py def concat ( self , * text ): \"\"\"Concatenate text (either `RichTextObject` or `str` items) to this block.\"\"\" nested = self () if not hasattr ( nested , \"rich_text\" ): raise AttributeError ( \"nested data does not contain text\" ) if nested . rich_text is None : nested . rich_text = [] for obj in text : if obj is None : continue self . _append_object ( obj )","title":"concat()"},{"location":"reference/#notional.blocks.ToDo","text":"A todo list item in Notion. Source code in notional/blocks.py class ToDo ( TextBlock , WithChildrenMixin , type = \"to_do\" ): \"\"\"A todo list item in Notion.\"\"\" class _NestedData ( NestedObject ): rich_text : List [ RichTextObject ] = [] checked : bool = False children : Optional [ List [ Block ]] = None color : FullColor = FullColor . DEFAULT to_do : _NestedData = _NestedData () @classmethod def __compose__ ( cls , text , checked = False , href = None ): \"\"\"Compose a ToDo block from the given text and checked state.\"\"\" return ToDo ( to_do = ToDo . _NestedData ( rich_text = [ TextObject [ text , href ]], checked = checked , ) ) @property def IsChecked ( self ): \"\"\"Determine if this ToDo is marked as checked or not. If the block is empty (e.g. no nested data), this method returns `None`. \"\"\" return self . to_do . checked if self . to_do else None @property def Markdown ( self ): \"\"\"Return the contents of this block as markdown text.\"\"\" if self . to_do and self . to_do . rich_text : if self . to_do . checked : return f \"- [x] { markdown ( * self . to_do . rich_text ) } \" return f \"- [ ] { markdown ( * self . to_do . rich_text ) } \" return \"\"","title":"ToDo"},{"location":"reference/#notional.blocks.ToDo.IsChecked","text":"Determine if this ToDo is marked as checked or not. If the block is empty (e.g. no nested data), this method returns None .","title":"IsChecked"},{"location":"reference/#notional.blocks.ToDo.Markdown","text":"Return the contents of this block as markdown text.","title":"Markdown"},{"location":"reference/#notional.blocks.ToDo.__compose__","text":"Compose a ToDo block from the given text and checked state. Source code in notional/blocks.py @classmethod def __compose__ ( cls , text , checked = False , href = None ): \"\"\"Compose a ToDo block from the given text and checked state.\"\"\" return ToDo ( to_do = ToDo . _NestedData ( rich_text = [ TextObject [ text , href ]], checked = checked , ) )","title":"__compose__()"},{"location":"reference/#notional.blocks.Toggle","text":"A toggle list item in Notion. Source code in notional/blocks.py class Toggle ( TextBlock , WithChildrenMixin , type = \"toggle\" ): \"\"\"A toggle list item in Notion.\"\"\" class _NestedData ( NestedObject ): rich_text : List [ RichTextObject ] = [] children : Optional [ List [ Block ]] = None color : FullColor = FullColor . DEFAULT toggle : _NestedData = _NestedData ()","title":"Toggle"},{"location":"reference/#notional.blocks.UnsupportedBlock","text":"A placeholder for unsupported blocks in the API. Source code in notional/blocks.py class UnsupportedBlock ( Block , type = \"unsupported\" ): \"\"\"A placeholder for unsupported blocks in the API.\"\"\" class _NestedData ( NestedObject ): pass unsupported : Optional [ _NestedData ] = None","title":"UnsupportedBlock"},{"location":"reference/#notional.blocks.Video","text":"A video block in Notion. Source code in notional/blocks.py class Video ( Block , type = \"video\" ): \"\"\"A video block in Notion.\"\"\" video : FileObject = None","title":"Video"},{"location":"reference/#notional.blocks.WithChildrenMixin","text":"Mixin for blocks that support children blocks. Source code in notional/blocks.py class WithChildrenMixin : \"\"\"Mixin for blocks that support children blocks.\"\"\" @property def __children__ ( self ): \"\"\"Provide short-hand access to the children in this block.\"\"\" return self ( \"children\" ) def __iadd__ ( self , block ): \"\"\"Append the given block to the children of this parent in place.\"\"\" self . append ( block ) return self def append ( self , block ): \"\"\"Append the given block to the children of this parent.\"\"\" if block is None : raise ValueError ( \"block cannot be None\" ) nested = self () if not hasattr ( nested , \"children\" ): raise TypeError ( \"nested data does not contain children\" ) if nested . children is None : nested . children = [] nested . children . append ( block ) self . has_children = True","title":"WithChildrenMixin"},{"location":"reference/#notional.blocks.WithChildrenMixin.__children__","text":"Provide short-hand access to the children in this block.","title":"__children__"},{"location":"reference/#notional.blocks.WithChildrenMixin.__iadd__","text":"Append the given block to the children of this parent in place. Source code in notional/blocks.py def __iadd__ ( self , block ): \"\"\"Append the given block to the children of this parent in place.\"\"\" self . append ( block ) return self","title":"__iadd__()"},{"location":"reference/#notional.blocks.WithChildrenMixin.append","text":"Append the given block to the children of this parent. Source code in notional/blocks.py def append ( self , block ): \"\"\"Append the given block to the children of this parent.\"\"\" if block is None : raise ValueError ( \"block cannot be None\" ) nested = self () if not hasattr ( nested , \"children\" ): raise TypeError ( \"nested data does not contain children\" ) if nested . children is None : nested . children = [] nested . children . append ( block ) self . has_children = True","title":"append()"},{"location":"reference/#notional.core","text":"Base classes for working with the Notion API.","title":"core"},{"location":"reference/#notional.core.ComposableObject","text":"Presents a meta class that composes objects using simple values. This is primarily to allow easy definition of data objects without disrupting the BaseModel constructor. e.g. rather than requiring a caller to understand how nested data works in the data objects, they can compose objects from simple values. Compare the following code for declaring a Paragraph: # using nested data objects: text = \"hello world\" nested = TextObject . _NestedData ( content = text ) rtf = text . TextObject ( text = nested , plain_text = text ) content = blocks . Paragraph . _NestedData ( text = [ rtf ]) para = blocks . Paragraph ( paragraph = content ) # using a composable object: para = blocks . Paragraph [ \"hello world\" ] Classes that support composition in this way must define and implement the internal __compose__ method. This method takes an arbitrary number of parameters, based on the needs of the implementation. It is up to the implementing class to ensure that the parameters are specificied correctly. Source code in notional/core.py class ComposableObject ( ModelMetaclass ): \"\"\"Presents a meta class that composes objects using simple values. This is primarily to allow easy definition of data objects without disrupting the `BaseModel` constructor. e.g. rather than requiring a caller to understand how nested data works in the data objects, they can compose objects from simple values. Compare the following code for declaring a Paragraph: ```python # using nested data objects: text = \"hello world\" nested = TextObject._NestedData(content=text) rtf = text.TextObject(text=nested, plain_text=text) content = blocks.Paragraph._NestedData(text=[rtf]) para = blocks.Paragraph(paragraph=content) # using a composable object: para = blocks.Paragraph[\"hello world\"] ``` Classes that support composition in this way must define and implement the internal `__compose__` method. This method takes an arbitrary number of parameters, based on the needs of the implementation. It is up to the implementing class to ensure that the parameters are specificied correctly. \"\"\" def __getitem__ ( self , params ): \"\"\"Return the requested class by composing using the given param. Types found in `params` will be compared to expected types in the `__compose__` method. If the requested class does not expose the `__compose__` method, this will raise an exception. \"\"\" if not hasattr ( self , \"__compose__\" ): raise NotImplementedError ( f \" { self } does not support object composition\" ) # XXX if params is empty / None, consider calling the default constructor compose = self . __compose__ if type ( params ) is tuple : return compose ( * params ) return compose ( params )","title":"ComposableObject"},{"location":"reference/#notional.core.ComposableObject.__getitem__","text":"Return the requested class by composing using the given param. Types found in params will be compared to expected types in the __compose__ method. If the requested class does not expose the __compose__ method, this will raise an exception. Source code in notional/core.py def __getitem__ ( self , params ): \"\"\"Return the requested class by composing using the given param. Types found in `params` will be compared to expected types in the `__compose__` method. If the requested class does not expose the `__compose__` method, this will raise an exception. \"\"\" if not hasattr ( self , \"__compose__\" ): raise NotImplementedError ( f \" { self } does not support object composition\" ) # XXX if params is empty / None, consider calling the default constructor compose = self . __compose__ if type ( params ) is tuple : return compose ( * params ) return compose ( params )","title":"__getitem__()"},{"location":"reference/#notional.core.DataObject","text":"The base for all API objects. Source code in notional/core.py class DataObject ( BaseModel , metaclass = ComposableObject ): \"\"\"The base for all API objects.\"\"\" def __setattr__ ( self , name , value ): \"\"\"Set the attribute of this object to a given value. The implementation of `BaseModel.__setattr__` does not allow for properties. See https://github.com/samuelcolvin/pydantic/issues/1577 \"\"\" try : super () . __setattr__ ( name , value ) except ValueError as err : setters = inspect . getmembers ( self . __class__ , predicate = lambda x : isinstance ( x , property ) and x . fset is not None , ) for setter_name , _ in setters : if setter_name == name : object . __setattr__ ( self , name , value ) break else : raise err @classmethod def _modify_field_ ( cls , name , default = None ): \"\"\"Modify the `BaseModel` field information for a specific class instance. This is necessary in particular for sublcasses that change the default values of a model when defined. Notable examples are `TypedObject` and `NamedObject`. :param name: the named attribute in the class :param default: the new default for the named field \"\"\" setattr ( cls , name , default ) cls . __fields__ [ name ] . default = default cls . __fields__ [ name ] . required = default is None # https://github.com/samuelcolvin/pydantic/discussions/3139 def refresh ( __pydantic_self__ , ** data ): \"\"\"Refresh the internal attributes with new data.\"\"\" values , fields , error = validate_model ( __pydantic_self__ . __class__ , data ) if error : raise error for name in fields : value = values [ name ] log . debug ( \"set object data -- %s => %s \" , name , value ) setattr ( __pydantic_self__ , name , value ) return __pydantic_self__ def to_api ( self ): \"\"\"Convert to a suitable representation for the Notion API.\"\"\" # the API doesn't like \"undefined\" values... data = self . dict ( exclude_none = True , by_alias = True ) # we need to convert \"special\" types to string forms to help the JSON encoder. # there are efforts underway in pydantic to make this easier, but for now... return make_api_safe ( data )","title":"DataObject"},{"location":"reference/#notional.core.DataObject.__setattr__","text":"Set the attribute of this object to a given value. The implementation of BaseModel.__setattr__ does not allow for properties. See https://github.com/samuelcolvin/pydantic/issues/1577 Source code in notional/core.py def __setattr__ ( self , name , value ): \"\"\"Set the attribute of this object to a given value. The implementation of `BaseModel.__setattr__` does not allow for properties. See https://github.com/samuelcolvin/pydantic/issues/1577 \"\"\" try : super () . __setattr__ ( name , value ) except ValueError as err : setters = inspect . getmembers ( self . __class__ , predicate = lambda x : isinstance ( x , property ) and x . fset is not None , ) for setter_name , _ in setters : if setter_name == name : object . __setattr__ ( self , name , value ) break else : raise err","title":"__setattr__()"},{"location":"reference/#notional.core.DataObject.refresh","text":"Refresh the internal attributes with new data. Source code in notional/core.py def refresh ( __pydantic_self__ , ** data ): \"\"\"Refresh the internal attributes with new data.\"\"\" values , fields , error = validate_model ( __pydantic_self__ . __class__ , data ) if error : raise error for name in fields : value = values [ name ] log . debug ( \"set object data -- %s => %s \" , name , value ) setattr ( __pydantic_self__ , name , value ) return __pydantic_self__","title":"refresh()"},{"location":"reference/#notional.core.DataObject.to_api","text":"Convert to a suitable representation for the Notion API. Source code in notional/core.py def to_api ( self ): \"\"\"Convert to a suitable representation for the Notion API.\"\"\" # the API doesn't like \"undefined\" values... data = self . dict ( exclude_none = True , by_alias = True ) # we need to convert \"special\" types to string forms to help the JSON encoder. # there are efforts underway in pydantic to make this easier, but for now... return make_api_safe ( data )","title":"to_api()"},{"location":"reference/#notional.core.NamedObject","text":"A Notion API object. Source code in notional/core.py class NamedObject ( DataObject ): \"\"\"A Notion API object.\"\"\" # XXX should NamedObject have the same typing ability as TypedObject? object : str def __init_subclass__ ( cls , object = None , ** kwargs ): \"\"\"Update `DataObject` defaults for the named object.\"\"\" super () . __init_subclass__ ( ** kwargs ) if object is not None : cls . _modify_field_ ( \"object\" , default = object )","title":"NamedObject"},{"location":"reference/#notional.core.NamedObject.__init_subclass__","text":"Update DataObject defaults for the named object. Source code in notional/core.py def __init_subclass__ ( cls , object = None , ** kwargs ): \"\"\"Update `DataObject` defaults for the named object.\"\"\" super () . __init_subclass__ ( ** kwargs ) if object is not None : cls . _modify_field_ ( \"object\" , default = object )","title":"__init_subclass__()"},{"location":"reference/#notional.core.NestedObject","text":"Represents an API object with nested data. These objects require a 'type' property and a matching property of the same name, which holds additional data. For example, this contains a nested 'text' object: data = { type: \"text\", ... !!! text \"{\" ... } } Currently, this is a convenience class for clarity - it does not provide additional functionality at this time. Source code in notional/core.py class NestedObject ( DataObject ): \"\"\"Represents an API object with nested data. These objects require a 'type' property and a matching property of the same name, which holds additional data. For example, this contains a nested 'text' object: data = { type: \"text\", ... text: { ... } } Currently, this is a convenience class for clarity - it does not provide additional functionality at this time. \"\"\"","title":"NestedObject"},{"location":"reference/#notional.core.TypedObject","text":"A type-referenced object. Many objects in the Notion API follow a generic->specific pattern with a 'type' parameter followed by additional data. These objects must specify a type attribute to ensure that the correct object is created. Calling the object provides direct access to the data stored in {type} . Source code in notional/core.py class TypedObject ( DataObject ): \"\"\"A type-referenced object. Many objects in the Notion API follow a generic->specific pattern with a 'type' parameter followed by additional data. These objects must specify a `type` attribute to ensure that the correct object is created. Calling the object provides direct access to the data stored in `{type}`. \"\"\" type : str # modified from the methods described in this discussion: # - https://github.com/samuelcolvin/pydantic/discussions/3091 def __init_subclass__ ( cls , type = None , ** kwargs ): \"\"\"Register the subtypes of the TypedObject subclass.\"\"\" super () . __init_subclass__ ( ** kwargs ) if type is not None : sub_type = type elif hasattr ( cls , \"__type__\" ): sub_type = cls . __type__ else : sub_type = cls . __name__ cls . _modify_field_ ( \"type\" , default = sub_type ) # initialize a __typemap__ map for each direct child of TypedObject # this allows different class trees to have the same 'type' name # but point to a different object (e.g. the 'date' type may have # different implementations depending where it is used in the API) # also, due to the order in which typed classes are defined, once # the map is defined for a subclass of TypedObject, any further # descendants of that class will have the new map via inheritance if TypedObject in cls . __bases__ and not hasattr ( cls , \"__typemap__\" ): cls . __typemap__ = {} if sub_type in cls . __typemap__ : raise ValueError ( f \"Duplicate subtype for class - { sub_type } :: { cls } \" ) log . debug ( \"registered new subtype: %s => %s \" , sub_type , cls ) cls . __typemap__ [ sub_type ] = cls def __call__ ( self , field = None ): \"\"\"Return nested data from this Block. If a field is provided, the contents of that field in the NestedData will be returned. Otherwise, the full contents of the NestedData will be returned. \"\"\" type = getattr ( self , \"type\" , None ) if type is None : raise AttributeError ( \"type not specified\" ) nested = getattr ( self , type ) if field is not None : nested = getattr ( nested , field ) return nested @classmethod def __get_validators__ ( cls ): \"\"\"Provide `BaseModel` with the means to convert `TypedObject`'s.\"\"\" yield cls . _convert_to_real_type_ @classmethod def parse_obj ( cls , obj ): \"\"\"Parse the structured object data into an instance of `TypedObject`. This method overrides `BaseModel.parse_obj()`. \"\"\" return cls . _convert_to_real_type_ ( obj ) @classmethod def _convert_to_real_type_ ( cls , data ): \"\"\"Instantiate the correct object based on the 'type' field.\"\"\" if isinstance ( data , cls ): return data if not isinstance ( data , dict ): raise ValueError ( \"Invalid 'data' object\" ) data_type = data . get ( \"type\" ) if data_type is None : raise ValueError ( \"Missing 'type' in TypedObject\" ) if not hasattr ( cls , \"__typemap__\" ): raise TypeError ( f \"Invalid TypedObject: { cls } - missing __typemap__\" ) sub = cls . __typemap__ . get ( data_type ) if sub is None : raise TypeError ( f \"Unsupport sub-type: { data_type } \" ) log . debug ( \"initializing typed object %s :: %s => %s -- %s \" , cls , data_type , sub , data ) return sub ( ** data )","title":"TypedObject"},{"location":"reference/#notional.core.TypedObject.__call__","text":"Return nested data from this Block. If a field is provided, the contents of that field in the NestedData will be returned. Otherwise, the full contents of the NestedData will be returned. Source code in notional/core.py def __call__ ( self , field = None ): \"\"\"Return nested data from this Block. If a field is provided, the contents of that field in the NestedData will be returned. Otherwise, the full contents of the NestedData will be returned. \"\"\" type = getattr ( self , \"type\" , None ) if type is None : raise AttributeError ( \"type not specified\" ) nested = getattr ( self , type ) if field is not None : nested = getattr ( nested , field ) return nested","title":"__call__()"},{"location":"reference/#notional.core.TypedObject.__get_validators__","text":"Provide BaseModel with the means to convert TypedObject 's. Source code in notional/core.py @classmethod def __get_validators__ ( cls ): \"\"\"Provide `BaseModel` with the means to convert `TypedObject`'s.\"\"\" yield cls . _convert_to_real_type_","title":"__get_validators__()"},{"location":"reference/#notional.core.TypedObject.__init_subclass__","text":"Register the subtypes of the TypedObject subclass. Source code in notional/core.py def __init_subclass__ ( cls , type = None , ** kwargs ): \"\"\"Register the subtypes of the TypedObject subclass.\"\"\" super () . __init_subclass__ ( ** kwargs ) if type is not None : sub_type = type elif hasattr ( cls , \"__type__\" ): sub_type = cls . __type__ else : sub_type = cls . __name__ cls . _modify_field_ ( \"type\" , default = sub_type ) # initialize a __typemap__ map for each direct child of TypedObject # this allows different class trees to have the same 'type' name # but point to a different object (e.g. the 'date' type may have # different implementations depending where it is used in the API) # also, due to the order in which typed classes are defined, once # the map is defined for a subclass of TypedObject, any further # descendants of that class will have the new map via inheritance if TypedObject in cls . __bases__ and not hasattr ( cls , \"__typemap__\" ): cls . __typemap__ = {} if sub_type in cls . __typemap__ : raise ValueError ( f \"Duplicate subtype for class - { sub_type } :: { cls } \" ) log . debug ( \"registered new subtype: %s => %s \" , sub_type , cls ) cls . __typemap__ [ sub_type ] = cls","title":"__init_subclass__()"},{"location":"reference/#notional.core.TypedObject.parse_obj","text":"Parse the structured object data into an instance of TypedObject . This method overrides BaseModel.parse_obj() . Source code in notional/core.py @classmethod def parse_obj ( cls , obj ): \"\"\"Parse the structured object data into an instance of `TypedObject`. This method overrides `BaseModel.parse_obj()`. \"\"\" return cls . _convert_to_real_type_ ( obj )","title":"parse_obj()"},{"location":"reference/#notional.core.make_api_safe","text":"Recursively convert the given data to an API-safe form. This is mostly to handle data types that will not directly serialize to JSON. Source code in notional/core.py def make_api_safe ( data ): \"\"\"Recursively convert the given data to an API-safe form. This is mostly to handle data types that will not directly serialize to JSON. \"\"\" # https://github.com/samuelcolvin/pydantic/issues/1409#issuecomment-877175194 if isinstance ( data , ( date , datetime )): return data . isoformat () if isinstance ( data , UUID ): return str ( data ) if isinstance ( data , Enum ): return data . value if isinstance ( data , dict ): return { name : make_api_safe ( value ) for name , value in data . items ()} if isinstance ( data , list ): return [ make_api_safe ( value ) for value in data ] if isinstance ( data , tuple ): return [ make_api_safe ( value ) for value in data ] return data","title":"make_api_safe()"},{"location":"reference/#notional.iterator","text":"Iterator classes for notional.","title":"iterator"},{"location":"reference/#notional.iterator.ContentIterator","text":"Base class to handle pagination over arbitrary content. Source code in notional/iterator.py class ContentIterator ( ABC ): \"\"\"Base class to handle pagination over arbitrary content.\"\"\" def __init__ ( self ): \"\"\"Initialzie the iterator.\"\"\" self . log = log . getChild ( \"ContentIterator\" ) self . page = None self . page_index = - 1 self . page_num = 0 self . n_items = 0 def __iter__ ( self ): \"\"\"Initialize the iterator.\"\"\" self . log . debug ( \"initializing content iterator\" ) return self def __next__ ( self ): \"\"\"Return the next item from the result set or raise StopIteration.\"\"\" # load a new page if needed if self . page is None or self . page_index >= len ( self . page ): self . page_index = 0 self . page = self . load_next_page () self . page_num += 1 # if we have run out of results... if self . page is None or len ( self . page ) == 0 : raise StopIteration # pull the next item from the current page item = self . page [ self . page_index ] # setup for the next call self . page_index += 1 self . n_items += 1 return item @property def page_number ( self ): \"\"\"Return the current page number of results in this iterator.\"\"\" return self . page_num @property def total_items ( self ): \"\"\"Return the total number of items returns by this iterator.\"\"\" return self . n_items @abstractmethod def load_next_page ( self ): \"\"\"Retrieve the next page of data as a list of items.\"\"\"","title":"ContentIterator"},{"location":"reference/#notional.iterator.ContentIterator.page_number","text":"Return the current page number of results in this iterator.","title":"page_number"},{"location":"reference/#notional.iterator.ContentIterator.total_items","text":"Return the total number of items returns by this iterator.","title":"total_items"},{"location":"reference/#notional.iterator.ContentIterator.__init__","text":"Initialzie the iterator. Source code in notional/iterator.py def __init__ ( self ): \"\"\"Initialzie the iterator.\"\"\" self . log = log . getChild ( \"ContentIterator\" ) self . page = None self . page_index = - 1 self . page_num = 0 self . n_items = 0","title":"__init__()"},{"location":"reference/#notional.iterator.ContentIterator.__iter__","text":"Initialize the iterator. Source code in notional/iterator.py def __iter__ ( self ): \"\"\"Initialize the iterator.\"\"\" self . log . debug ( \"initializing content iterator\" ) return self","title":"__iter__()"},{"location":"reference/#notional.iterator.ContentIterator.__next__","text":"Return the next item from the result set or raise StopIteration. Source code in notional/iterator.py def __next__ ( self ): \"\"\"Return the next item from the result set or raise StopIteration.\"\"\" # load a new page if needed if self . page is None or self . page_index >= len ( self . page ): self . page_index = 0 self . page = self . load_next_page () self . page_num += 1 # if we have run out of results... if self . page is None or len ( self . page ) == 0 : raise StopIteration # pull the next item from the current page item = self . page [ self . page_index ] # setup for the next call self . page_index += 1 self . n_items += 1 return item","title":"__next__()"},{"location":"reference/#notional.iterator.ContentIterator.load_next_page","text":"Retrieve the next page of data as a list of items. Source code in notional/iterator.py @abstractmethod def load_next_page ( self ): \"\"\"Retrieve the next page of data as a list of items.\"\"\"","title":"load_next_page()"},{"location":"reference/#notional.iterator.EndpointIterator","text":"Base class for iterating over results from an API endpoint. Source code in notional/iterator.py class EndpointIterator ( ResultSetIterator ): \"\"\"Base class for iterating over results from an API endpoint.\"\"\" def __init__ ( self , endpoint , ** params ): \"\"\"Initialize the `EndpointIterator` for a specific API endpoint. :param endpoint: the concrete endpoint to use for this iterator :param params: parameters sent to the endpoint when called \"\"\" super () . __init__ () self . endpoint = endpoint self . params = params or {} self . log = log . getChild ( \"EndpointIterator\" ) def __setitem__ ( self , name , value ): \"\"\"Set the parameter in this `EndpointIterator`.\"\"\" self . params [ name ] = value def load_page_data ( self , params ): \"\"\"Return the next page with given parameters.\"\"\" params . update ( self . params ) return self . endpoint ( ** params )","title":"EndpointIterator"},{"location":"reference/#notional.iterator.EndpointIterator.__init__","text":"Initialize the EndpointIterator for a specific API endpoint. :param endpoint: the concrete endpoint to use for this iterator :param params: parameters sent to the endpoint when called Source code in notional/iterator.py def __init__ ( self , endpoint , ** params ): \"\"\"Initialize the `EndpointIterator` for a specific API endpoint. :param endpoint: the concrete endpoint to use for this iterator :param params: parameters sent to the endpoint when called \"\"\" super () . __init__ () self . endpoint = endpoint self . params = params or {} self . log = log . getChild ( \"EndpointIterator\" )","title":"__init__()"},{"location":"reference/#notional.iterator.EndpointIterator.__setitem__","text":"Set the parameter in this EndpointIterator . Source code in notional/iterator.py def __setitem__ ( self , name , value ): \"\"\"Set the parameter in this `EndpointIterator`.\"\"\" self . params [ name ] = value","title":"__setitem__()"},{"location":"reference/#notional.iterator.EndpointIterator.load_page_data","text":"Return the next page with given parameters. Source code in notional/iterator.py def load_page_data ( self , params ): \"\"\"Return the next page with given parameters.\"\"\" params . update ( self . params ) return self . endpoint ( ** params )","title":"load_page_data()"},{"location":"reference/#notional.iterator.PageIterator","text":"Base class to handle pagination by page number. Source code in notional/iterator.py class PageIterator ( ContentIterator , ABC ): \"\"\"Base class to handle pagination by page number.\"\"\" def load_next_page ( self ): \"\"\"Retrieve the next page of data as a list of items.\"\"\" return self . get_page_content ( self . page_num + 1 ) @abstractmethod def get_page_content ( self , page_num ): \"\"\"Retrieve the page of data with the given number.\"\"\"","title":"PageIterator"},{"location":"reference/#notional.iterator.PageIterator.get_page_content","text":"Retrieve the page of data with the given number. Source code in notional/iterator.py @abstractmethod def get_page_content ( self , page_num ): \"\"\"Retrieve the page of data with the given number.\"\"\"","title":"get_page_content()"},{"location":"reference/#notional.iterator.PageIterator.load_next_page","text":"Retrieve the next page of data as a list of items. Source code in notional/iterator.py def load_next_page ( self ): \"\"\"Retrieve the next page of data as a list of items.\"\"\" return self . get_page_content ( self . page_num + 1 )","title":"load_next_page()"},{"location":"reference/#notional.iterator.PositionalIterator","text":"Base class to handle pagination by positional cursor. Source code in notional/iterator.py class PositionalIterator ( ContentIterator , ABC ): \"\"\"Base class to handle pagination by positional cursor.\"\"\" def __init__ ( self ): \"\"\"Initialize the iterator.\"\"\" super () . __init__ () self . cursor = None self . first_pass = True def load_next_page ( self ): \"\"\"Load the next page of data from this iterator.\"\"\" if not self . first_pass and not self . cursor : return None results = self . get_page_data ( self . cursor ) self . cursor = results . next_cursor self . first_pass = False return results . items @abstractmethod def get_page_data ( self , cursor ): \"\"\"Retrieve the page of data starting at the given cursor.\"\"\" class PageData ( BaseModel ): \"\"\"Represents a page of data from the Notion API.\"\"\" this_cursor : Optional [ Any ] = None next_cursor : Optional [ Any ] = None items : Optional [ List [ Any ]] = None @property def page_size ( self ): \"\"\"Return the page size for this data set.\"\"\" return - 1 if self . items is None else len ( self . items )","title":"PositionalIterator"},{"location":"reference/#notional.iterator.PositionalIterator.PageData","text":"Represents a page of data from the Notion API. Source code in notional/iterator.py class PageData ( BaseModel ): \"\"\"Represents a page of data from the Notion API.\"\"\" this_cursor : Optional [ Any ] = None next_cursor : Optional [ Any ] = None items : Optional [ List [ Any ]] = None @property def page_size ( self ): \"\"\"Return the page size for this data set.\"\"\" return - 1 if self . items is None else len ( self . items )","title":"PageData"},{"location":"reference/#notional.iterator.PositionalIterator.PageData.page_size","text":"Return the page size for this data set.","title":"page_size"},{"location":"reference/#notional.iterator.PositionalIterator.__init__","text":"Initialize the iterator. Source code in notional/iterator.py def __init__ ( self ): \"\"\"Initialize the iterator.\"\"\" super () . __init__ () self . cursor = None self . first_pass = True","title":"__init__()"},{"location":"reference/#notional.iterator.PositionalIterator.get_page_data","text":"Retrieve the page of data starting at the given cursor. Source code in notional/iterator.py @abstractmethod def get_page_data ( self , cursor ): \"\"\"Retrieve the page of data starting at the given cursor.\"\"\"","title":"get_page_data()"},{"location":"reference/#notional.iterator.PositionalIterator.load_next_page","text":"Load the next page of data from this iterator. Source code in notional/iterator.py def load_next_page ( self ): \"\"\"Load the next page of data from this iterator.\"\"\" if not self . first_pass and not self . cursor : return None results = self . get_page_data ( self . cursor ) self . cursor = results . next_cursor self . first_pass = False return results . items","title":"load_next_page()"},{"location":"reference/#notional.iterator.ResultSetIterator","text":"Base class for iterating over Notion API result sets. Source code in notional/iterator.py class ResultSetIterator ( PositionalIterator , ABC ): \"\"\"Base class for iterating over Notion API result sets.\"\"\" def get_page_data ( self , cursor ): \"\"\"Retrieve the page of data starting at the given cursor.\"\"\" params = { \"page_size\" : CONTENT_PAGE_SIZE } if cursor : params [ \"start_cursor\" ] = cursor self . log . debug ( \"loading next page - start cursor: %s \" , cursor ) # TODO error checking on result data = self . load_page_data ( params ) results = PositionalIterator . PageData ( this_cursor = cursor , next_cursor = data [ \"next_cursor\" ] if data [ \"has_more\" ] else None , items = data [ \"results\" ] if \"results\" in data else None , ) self . log . debug ( \"loaded %d results; next cursor: %s \" , results . page_size , results . next_cursor ) return results @property def last_page ( self ): \"\"\"Return true if this is the last page of results.\"\"\" return not self . first_pass and self . cursor is None @abstractmethod def load_page_data ( self , params ): \"\"\"Load the page of data defined by the given params.\"\"\"","title":"ResultSetIterator"},{"location":"reference/#notional.iterator.ResultSetIterator.last_page","text":"Return true if this is the last page of results.","title":"last_page"},{"location":"reference/#notional.iterator.ResultSetIterator.get_page_data","text":"Retrieve the page of data starting at the given cursor. Source code in notional/iterator.py def get_page_data ( self , cursor ): \"\"\"Retrieve the page of data starting at the given cursor.\"\"\" params = { \"page_size\" : CONTENT_PAGE_SIZE } if cursor : params [ \"start_cursor\" ] = cursor self . log . debug ( \"loading next page - start cursor: %s \" , cursor ) # TODO error checking on result data = self . load_page_data ( params ) results = PositionalIterator . PageData ( this_cursor = cursor , next_cursor = data [ \"next_cursor\" ] if data [ \"has_more\" ] else None , items = data [ \"results\" ] if \"results\" in data else None , ) self . log . debug ( \"loaded %d results; next cursor: %s \" , results . page_size , results . next_cursor ) return results","title":"get_page_data()"},{"location":"reference/#notional.iterator.ResultSetIterator.load_page_data","text":"Load the page of data defined by the given params. Source code in notional/iterator.py @abstractmethod def load_page_data ( self , params ): \"\"\"Load the page of data defined by the given params.\"\"\"","title":"load_page_data()"},{"location":"reference/#notional.orm","text":"Utilities for working with Notion as an ORM. There are two primary constructs in this module that enable custom type definitions in Notional: Property() and connected_page() .","title":"orm"},{"location":"reference/#notional.orm.ConnectedPage","text":"Base class for \"live\" pages via the Notion API. All changes are committed in real time. Source code in notional/orm.py class ConnectedPage : \"\"\"Base class for \"live\" pages via the Notion API. All changes are committed in real time. \"\"\" def __init__ ( self , ** data ): \"\"\"Construct a page from the given data dictionary.\"\"\" self . _notional__page = Page ( ** data ) if data else None def __init_subclass__ ( cls , database = None , ** kwargs ): \"\"\"Register new subclasses of a ConnectedPage.\"\"\" super ( cls ) . __init_subclass__ ( ** kwargs ) if database is not None : cls . _notional__database = database elif hasattr ( cls , \"__database__\" ): cls . _notional__database = cls . __database__ @property def id ( self ): \"\"\"Return the ID of this page (if available).\"\"\" return self . _notional__page . id if self . _notional__page else None @property def children ( self ): \"\"\"Return an iterator for all child blocks of this Page.\"\"\" if self . _notional__page is None : return [] return self . _notional__session . blocks . children . list ( parent = self . _notional__page ) @property def cover ( self ): \"\"\"Return the cover for the Page.\"\"\" return self . _notional__page . cover @cover . setter def cover ( self , file ): \"\"\"Set the cover for the Page.\"\"\" self . _notional__session . pages . set ( self . _notional__page , cover = file ) @property def icon ( self ): \"\"\"Return the icon for the Page.\"\"\" return self . _notional__page . icon @icon . setter def icon ( self , emoji ): \"\"\"Set the icon for the Page. :param emoji: may be either a single emoji string or an `EmojiObject` \"\"\" if isinstance ( emoji , str ): emoji = EmojiObject [ emoji ] elif not isinstance ( emoji , EmojiObject ): raise ValueError ( \"Invalid emoji; unsupported type\" ) self . _notional__session . pages . set ( self . _notional__page , icon = emoji ) def __iadd__ ( self , block ): \"\"\"Append the given block to this page. This operation takes place on the Notion server, causing the page to save immediately. \"\"\" self . append ( block ) return self def append ( self , * blocks ): \"\"\"Append the given blocks as children of this ConnectedPage. This operation takes place on the Notion server, causing the page to update immediately. \"\"\" if self . _notional__page is None : raise ValueError ( \"Cannot append blocks; missing page\" ) if self . _notional__session is None : raise ValueError ( \"Cannot append blocks; invalid session\" ) log . debug ( \"appending %d blocks to page :: %s \" , len ( blocks ), self . _notional__page . id ) self . _notional__session . blocks . children . append ( self . _notional__page , * blocks ) @classmethod def bind ( cls , to_session ): \"\"\"Attach this ConnectedPage to the given session. Setting this to None will detach the page. \"\"\" cls . _notional__session = to_session @classmethod def query ( cls ): \"\"\"Return a `QueryBuilder` for the custom type.\"\"\" if cls . _notional__session is None : raise ValueError ( \"Unable to query; invalid session\" ) if cls . _notional__database is None : raise ValueError ( \"Unable to query; invalid database\" ) return cls . _notional__session . databases . query ( cls ) @classmethod def create ( cls , ** kwargs ): \"\"\"Create a new instance of the ConnectedPage type. Any properties that support object composition may defined in `kwargs`. This operation takes place on the Notion server, creating the page immediately. :param properties: the properties to initialize for this object as a `dict()` with format `name: value` where `name` is the attribute in the custom type and `value` is a supported type for composing \"\"\" if cls . _notional__session is None : raise ValueError ( \"Cannot create Page; invalid session\" ) if cls . _notional__database is None : raise ValueError ( \"Cannot create Page; invalid database\" ) log . debug ( \"creating new %s :: %s \" , cls , cls . _notional__database ) parent = DatabaseRef ( database_id = cls . _notional__database ) connected = cls () connected . _notional__page = cls . _notional__session . pages . create ( parent = parent ) # FIXME it would be better to convert properties to a dict and pass to the API, # rather than setting them individually here... for name , value in kwargs . items (): setattr ( connected , name , value ) return connected @classmethod def parse_obj ( cls , data ): \"\"\"Invoke the class constructor using the structured data. Similar to `BaseModel.parse_obj(data)`. \"\"\" return cls ( ** data )","title":"ConnectedPage"},{"location":"reference/#notional.orm.ConnectedPage.children","text":"Return an iterator for all child blocks of this Page.","title":"children"},{"location":"reference/#notional.orm.ConnectedPage.cover","text":"Return the cover for the Page.","title":"cover"},{"location":"reference/#notional.orm.ConnectedPage.icon","text":"Return the icon for the Page.","title":"icon"},{"location":"reference/#notional.orm.ConnectedPage.id","text":"Return the ID of this page (if available).","title":"id"},{"location":"reference/#notional.orm.ConnectedPage.__iadd__","text":"Append the given block to this page. This operation takes place on the Notion server, causing the page to save immediately. Source code in notional/orm.py def __iadd__ ( self , block ): \"\"\"Append the given block to this page. This operation takes place on the Notion server, causing the page to save immediately. \"\"\" self . append ( block ) return self","title":"__iadd__()"},{"location":"reference/#notional.orm.ConnectedPage.__init__","text":"Construct a page from the given data dictionary. Source code in notional/orm.py def __init__ ( self , ** data ): \"\"\"Construct a page from the given data dictionary.\"\"\" self . _notional__page = Page ( ** data ) if data else None","title":"__init__()"},{"location":"reference/#notional.orm.ConnectedPage.__init_subclass__","text":"Register new subclasses of a ConnectedPage. Source code in notional/orm.py def __init_subclass__ ( cls , database = None , ** kwargs ): \"\"\"Register new subclasses of a ConnectedPage.\"\"\" super ( cls ) . __init_subclass__ ( ** kwargs ) if database is not None : cls . _notional__database = database elif hasattr ( cls , \"__database__\" ): cls . _notional__database = cls . __database__","title":"__init_subclass__()"},{"location":"reference/#notional.orm.ConnectedPage.append","text":"Append the given blocks as children of this ConnectedPage. This operation takes place on the Notion server, causing the page to update immediately. Source code in notional/orm.py def append ( self , * blocks ): \"\"\"Append the given blocks as children of this ConnectedPage. This operation takes place on the Notion server, causing the page to update immediately. \"\"\" if self . _notional__page is None : raise ValueError ( \"Cannot append blocks; missing page\" ) if self . _notional__session is None : raise ValueError ( \"Cannot append blocks; invalid session\" ) log . debug ( \"appending %d blocks to page :: %s \" , len ( blocks ), self . _notional__page . id ) self . _notional__session . blocks . children . append ( self . _notional__page , * blocks )","title":"append()"},{"location":"reference/#notional.orm.ConnectedPage.bind","text":"Attach this ConnectedPage to the given session. Setting this to None will detach the page. Source code in notional/orm.py @classmethod def bind ( cls , to_session ): \"\"\"Attach this ConnectedPage to the given session. Setting this to None will detach the page. \"\"\" cls . _notional__session = to_session","title":"bind()"},{"location":"reference/#notional.orm.ConnectedPage.create","text":"Create a new instance of the ConnectedPage type. Any properties that support object composition may defined in kwargs . This operation takes place on the Notion server, creating the page immediately. :param properties: the properties to initialize for this object as a dict() with format name: value where name is the attribute in the custom type and value is a supported type for composing Source code in notional/orm.py @classmethod def create ( cls , ** kwargs ): \"\"\"Create a new instance of the ConnectedPage type. Any properties that support object composition may defined in `kwargs`. This operation takes place on the Notion server, creating the page immediately. :param properties: the properties to initialize for this object as a `dict()` with format `name: value` where `name` is the attribute in the custom type and `value` is a supported type for composing \"\"\" if cls . _notional__session is None : raise ValueError ( \"Cannot create Page; invalid session\" ) if cls . _notional__database is None : raise ValueError ( \"Cannot create Page; invalid database\" ) log . debug ( \"creating new %s :: %s \" , cls , cls . _notional__database ) parent = DatabaseRef ( database_id = cls . _notional__database ) connected = cls () connected . _notional__page = cls . _notional__session . pages . create ( parent = parent ) # FIXME it would be better to convert properties to a dict and pass to the API, # rather than setting them individually here... for name , value in kwargs . items (): setattr ( connected , name , value ) return connected","title":"create()"},{"location":"reference/#notional.orm.ConnectedPage.parse_obj","text":"Invoke the class constructor using the structured data. Similar to BaseModel.parse_obj(data) . Source code in notional/orm.py @classmethod def parse_obj ( cls , data ): \"\"\"Invoke the class constructor using the structured data. Similar to `BaseModel.parse_obj(data)`. \"\"\" return cls ( ** data )","title":"parse_obj()"},{"location":"reference/#notional.orm.ConnectedPage.query","text":"Return a QueryBuilder for the custom type. Source code in notional/orm.py @classmethod def query ( cls ): \"\"\"Return a `QueryBuilder` for the custom type.\"\"\" if cls . _notional__session is None : raise ValueError ( \"Unable to query; invalid session\" ) if cls . _notional__database is None : raise ValueError ( \"Unable to query; invalid database\" ) return cls . _notional__session . databases . query ( cls )","title":"query()"},{"location":"reference/#notional.orm.ConnectedPageFactory","text":"A factory that builds custom types for ConnectedPage classes. Typically, these generated classes will be extended to form a custom type. Source code in notional/orm.py class ConnectedPageFactory : \"\"\"A factory that builds custom types for `ConnectedPage` classes. Typically, these generated classes will be extended to form a custom type. \"\"\" # TODO consider making this more general purpose (e.g. extend other base objects) def __init__ ( self , name = \"CustomBase\" , base = None , metaclass = None , ): \"\"\"Initialze the `ConnectedPageFactory` with the given parameters. :param name: the name of the class generated by this factory; defaults to \"CustomPage\" :param base: the class (or tuple of classes) used as the base class for types generated by this factory; defaults to `None` :param metaclass: the callable metaclass to use for generating new types; defaults to `type` \"\"\" self . name = name if base is None : self . bases = ( ConnectedPage ,) elif isinstance ( base , tuple ): self . bases = base else : self . bases = ( base ,) if metaclass is None : self . metaclass = type else : self . metaclass = metaclass def __call__ ( self , session , database , schema = None ): \"\"\"Return a new type from this factory with the given configuration.\"\"\" attrs = { \"_notional__session\" : session , \"_notional__database\" : database , } if schema is not None : for name , obj in schema . items (): safe_name = make_safe_python_name ( name ) prop = Property ( name , obj ) attrs [ safe_name ] = prop return self . metaclass ( self . name , self . bases , attrs )","title":"ConnectedPageFactory"},{"location":"reference/#notional.orm.ConnectedPageFactory.__call__","text":"Return a new type from this factory with the given configuration. Source code in notional/orm.py def __call__ ( self , session , database , schema = None ): \"\"\"Return a new type from this factory with the given configuration.\"\"\" attrs = { \"_notional__session\" : session , \"_notional__database\" : database , } if schema is not None : for name , obj in schema . items (): safe_name = make_safe_python_name ( name ) prop = Property ( name , obj ) attrs [ safe_name ] = prop return self . metaclass ( self . name , self . bases , attrs )","title":"__call__()"},{"location":"reference/#notional.orm.ConnectedPageFactory.__init__","text":"Initialze the ConnectedPageFactory with the given parameters. :param name: the name of the class generated by this factory; defaults to \"CustomPage\" :param base: the class (or tuple of classes) used as the base class for types generated by this factory; defaults to None :param metaclass: the callable metaclass to use for generating new types; defaults to type Source code in notional/orm.py def __init__ ( self , name = \"CustomBase\" , base = None , metaclass = None , ): \"\"\"Initialze the `ConnectedPageFactory` with the given parameters. :param name: the name of the class generated by this factory; defaults to \"CustomPage\" :param base: the class (or tuple of classes) used as the base class for types generated by this factory; defaults to `None` :param metaclass: the callable metaclass to use for generating new types; defaults to `type` \"\"\" self . name = name if base is None : self . bases = ( ConnectedPage ,) elif isinstance ( base , tuple ): self . bases = base else : self . bases = ( base ,) if metaclass is None : self . metaclass = type else : self . metaclass = metaclass","title":"__init__()"},{"location":"reference/#notional.orm.ConnectedProperty","text":"Contains the information and methods needed for a connected property. When created, this object does not have a reference to its parent object. Before this property is accessed for the first time, callers must use bind() to set the containing object at runtime. Source code in notional/orm.py class ConnectedProperty : \"\"\"Contains the information and methods needed for a connected property. When created, this object does not have a reference to its parent object. Before this property is accessed for the first time, callers must use `bind()` to set the containing object at runtime. \"\"\" def __init__ ( self , name , schema , default =... ): \"\"\"Initialize the property wrapper. :param name: the name of this property as it appears on Notional :param schema: the PropertyObject that defines the type of this property :param default: an optional parameter that will return a default value if one is not provided by the API \"\"\" if name is None or len ( name ) == 0 : raise ValueError ( \"Must provide a valid property name\" ) if schema is None : raise ValueError ( \"Invalid schema; cannot be None\" ) self . name = name self . default = default self . schema = schema self . data_type = type ( schema ) if not hasattr ( self . data_type , \"type\" ) or self . data_type . type is None : raise ValueError ( \"Invalid schema; undefined type\" ) self . type_name = self . data_type . type # this is kind of an ugly way to grab the value type from the schema type... # mostly b/c we are using internal knowledge of TypedObject.__typemap__ if self . type_name not in PropertyValue . __typemap__ : raise TypeError ( f \"Invalid schema; missing value type ' { self . type_name } '\" ) self . value_type = PropertyValue . __typemap__ [ self . type_name ] def bind ( self , obj ): \"\"\"Binds this property to the given object.\"\"\" if not isinstance ( obj , ConnectedPage ): raise TypeError ( \"Properties must be used in a ConnectedPage object\" ) # XXX should we do any additional error checking on the object? self . parent = obj self . page_data = self . parent . _notional__page self . session = self . parent . _notional__session def get ( self ): \"\"\"Return the current value of the property as a python object.\"\"\" log . debug ( \"fget :: %s [ %s ]\" , self . type_name , self . name ) # TODO raise instead? if self . page_data is None : return None try : prop = self . page_data [ self . name ] except AttributeError : if self . default == ... : raise AttributeError ( f \"Missing property: ' { self . name } '\" ) return self . default if not isinstance ( prop , self . value_type ): raise TypeError ( \"Type mismatch\" ) if hasattr ( prop , \"Value\" ): return prop . Value return prop def set ( self , value ): \"\"\"Set the property to the given value.\"\"\" log . debug ( \"fset :: %s [ %s ] => %s \" , self . type_name , self . name , type ( value )) # TODO raise instead? if self . page_data is None : return if isinstance ( value , self . value_type ): prop = value elif hasattr ( self . value_type , \"__compose__\" ): prop = self . value_type . __compose__ ( value ) else : raise TypeError ( f \"Unsupported value type for ' { self . type_name } '\" ) # update the property on the server (which will refresh the local data) self . session . pages . update ( self . page_data , ** { self . name : prop }) def delete ( self ): \"\"\"Delete the value assotiated with this property.\"\"\" # TODO raise instead? if self . page_data is None : return empty = self . value_type () self . session . pages . update ( self . page_data , ** { self . name : empty })","title":"ConnectedProperty"},{"location":"reference/#notional.orm.ConnectedProperty.__init__","text":"Initialize the property wrapper. :param name: the name of this property as it appears on Notional :param schema: the PropertyObject that defines the type of this property :param default: an optional parameter that will return a default value if one is not provided by the API Source code in notional/orm.py def __init__ ( self , name , schema , default =... ): \"\"\"Initialize the property wrapper. :param name: the name of this property as it appears on Notional :param schema: the PropertyObject that defines the type of this property :param default: an optional parameter that will return a default value if one is not provided by the API \"\"\" if name is None or len ( name ) == 0 : raise ValueError ( \"Must provide a valid property name\" ) if schema is None : raise ValueError ( \"Invalid schema; cannot be None\" ) self . name = name self . default = default self . schema = schema self . data_type = type ( schema ) if not hasattr ( self . data_type , \"type\" ) or self . data_type . type is None : raise ValueError ( \"Invalid schema; undefined type\" ) self . type_name = self . data_type . type # this is kind of an ugly way to grab the value type from the schema type... # mostly b/c we are using internal knowledge of TypedObject.__typemap__ if self . type_name not in PropertyValue . __typemap__ : raise TypeError ( f \"Invalid schema; missing value type ' { self . type_name } '\" ) self . value_type = PropertyValue . __typemap__ [ self . type_name ]","title":"__init__()"},{"location":"reference/#notional.orm.ConnectedProperty.bind","text":"Binds this property to the given object. Source code in notional/orm.py def bind ( self , obj ): \"\"\"Binds this property to the given object.\"\"\" if not isinstance ( obj , ConnectedPage ): raise TypeError ( \"Properties must be used in a ConnectedPage object\" ) # XXX should we do any additional error checking on the object? self . parent = obj self . page_data = self . parent . _notional__page self . session = self . parent . _notional__session","title":"bind()"},{"location":"reference/#notional.orm.ConnectedProperty.delete","text":"Delete the value assotiated with this property. Source code in notional/orm.py def delete ( self ): \"\"\"Delete the value assotiated with this property.\"\"\" # TODO raise instead? if self . page_data is None : return empty = self . value_type () self . session . pages . update ( self . page_data , ** { self . name : empty })","title":"delete()"},{"location":"reference/#notional.orm.ConnectedProperty.get","text":"Return the current value of the property as a python object. Source code in notional/orm.py def get ( self ): \"\"\"Return the current value of the property as a python object.\"\"\" log . debug ( \"fget :: %s [ %s ]\" , self . type_name , self . name ) # TODO raise instead? if self . page_data is None : return None try : prop = self . page_data [ self . name ] except AttributeError : if self . default == ... : raise AttributeError ( f \"Missing property: ' { self . name } '\" ) return self . default if not isinstance ( prop , self . value_type ): raise TypeError ( \"Type mismatch\" ) if hasattr ( prop , \"Value\" ): return prop . Value return prop","title":"get()"},{"location":"reference/#notional.orm.ConnectedProperty.set","text":"Set the property to the given value. Source code in notional/orm.py def set ( self , value ): \"\"\"Set the property to the given value.\"\"\" log . debug ( \"fset :: %s [ %s ] => %s \" , self . type_name , self . name , type ( value )) # TODO raise instead? if self . page_data is None : return if isinstance ( value , self . value_type ): prop = value elif hasattr ( self . value_type , \"__compose__\" ): prop = self . value_type . __compose__ ( value ) else : raise TypeError ( f \"Unsupported value type for ' { self . type_name } '\" ) # update the property on the server (which will refresh the local data) self . session . pages . update ( self . page_data , ** { self . name : prop })","title":"set()"},{"location":"reference/#notional.orm.Property","text":"Define a property for a Notion Page object. Internally, this method uses a custom wrapper to manage the property methods. :param name: the Notion table property name :param data_type: the schema that defines this property (default = RichText) :param default: a default value when creating new objects Source code in notional/orm.py def Property ( name , schema = None , default =... ): \"\"\"Define a property for a Notion Page object. Internally, this method uses a custom wrapper to manage the property methods. :param name: the Notion table property name :param data_type: the schema that defines this property (default = RichText) :param default: a default value when creating new objects \"\"\" log . debug ( \"creating new Property: %s \" , name ) if schema is None : schema = RichText () elif not isinstance ( schema , PropertyObject ): raise TypeError ( \"Invalid data_type; not a PropertyObject\" ) cprop = ConnectedProperty ( name = name , schema = schema , default = default , ) def fget ( self ): \"\"\"Return the current value of the property as a python object.\"\"\" cprop . bind ( self ) return cprop . get () def fset ( self , value ): \"\"\"Set the property to the given value.\"\"\" cprop . bind ( self ) cprop . set ( value ) def fdel ( self ): \"\"\"Delete the value for this property.\"\"\" cprop . bind ( self ) cprop . delete () return property ( fget , fset , fdel )","title":"Property()"},{"location":"reference/#notional.orm.connected_page","text":"Return a base class for \"connected\" pages through the Notion API. Subclasses may then inherit from the returned class to define custom ORM types. :param session: an active Notional session where the database is hosted :param source_db: if provided, the returned class will use the ID and schema of this object to initialize the connected page :param schema: if provided, the returned class will contain properties according to the schema provided; defaults to None :param cls: the returned class will inherit from the given class, which must be a sublass of ConnectedPage ; defaults to ConnectedPage Source code in notional/orm.py def connected_page ( session = None , source_db = None , schema = None , cls = None ): \"\"\"Return a base class for \"connected\" pages through the Notion API. Subclasses may then inherit from the returned class to define custom ORM types. :param session: an active Notional session where the database is hosted :param source_db: if provided, the returned class will use the ID and schema of this object to initialize the connected page :param schema: if provided, the returned class will contain properties according to the schema provided; defaults to `None` :param cls: the returned class will inherit from the given class, which must be a sublass of `ConnectedPage`; defaults to `ConnectedPage` \"\"\" if cls is None : cls = ConnectedPage elif not issubclass ( cls , ConnectedPage ): raise ValueError ( \"'cls' must subclass ConnectedPage\" ) if source_db is None : dbid = None elif not isinstance ( source_db , Database ): raise ValueError ( \"'source_db' must be a Database\" ) else : if schema is None : schema = source_db . properties dbid = source_db . id factory = ConnectedPageFactory ( base = cls ) return factory ( session = session , database = dbid , schema = schema , )","title":"connected_page()"},{"location":"reference/#notional.parser","text":"Utilities for parsing other document types in Notion. These parsers provide an alternative to the \"Import\" cabilities of the Notion client and Notion Web Clipper. Perhaps that capability will be exposed to the API in the future, which would effectively render these parsers unnecessary.","title":"parser"},{"location":"reference/#notional.parser.CsvParser","text":"A standard CSV parser. Contents of this parser are available as a list of page properties according to the determined schema. Specifically, this content follows the format: ``` [ { column_1_name: entry_1_column_1_data, column_2_name: entry_1_column_2_data, column_3_name: entry_1_column_3_data, ... }, { column_1_name: entry_2_column_1_data, column_2_name: entry_2_column_2_data, column_3_name: entry_2_column_3_data, ... }, ... ] ``` Source code in notional/parser.py class CsvParser ( DocumentParser ): \"\"\"A standard CSV parser. Contents of this parser are available as a list of page properties according to the determined schema. Specifically, this content follows the format: ``` [ { column_1_name: entry_1_column_1_data, column_2_name: entry_1_column_2_data, column_3_name: entry_1_column_3_data, ... }, { column_1_name: entry_2_column_1_data, column_2_name: entry_2_column_2_data, column_3_name: entry_2_column_3_data, ... }, ... ] ``` \"\"\" schema : dict def __init__ ( self , header_row = True , title_column = 0 ): \"\"\"Initialize a new `CsvParser`. :param header_row: indicates that data will have a header row (for the schema) :param title_column: set the column in data to use for page titles \"\"\" super () . __init__ () self . _has_header = header_row self . _title_index = title_column self . schema = {} self . _field_names = [] def parse ( self , data ): \"\"\"Parse the given CSV data. Upon return, the following properties will be available in the parser: `schema`: a computed schema for the supplied data `title`: the name of the CSV file being parsed (if available) `content`: a list of page properties with the tabular data \"\"\" super () . parse ( data ) if isinstance ( data , str ): data = io . StringIO ( data , newline = \"\" ) reader = csv . reader ( data ) self . _process ( reader ) def _process ( self , reader ): # build the schema based on the first row try : header = next ( reader ) except StopIteration : raise ValueError ( \"Invalid CSV: empty data\" ) if self . _has_header : self . _build_schema ( * header ) else : cols = [ str ( num ) for num in range ( len ( header ))] self . _build_schema ( * cols ) self . _build_record ( * header ) # process remaining entries for entry in reader : self . _build_record ( * entry ) def _build_schema ( self , * fields ): if fields is None or len ( fields ) < 1 : raise ValueError ( \"Invalid CSV: empty header\" ) column = 0 for field in fields : field = field . strip () while field in self . _field_names : field = f \" { field } _ { column } \" if column == self . _title_index : self . schema [ field ] = schema . Title () else : self . schema [ field ] = schema . RichText () self . _field_names . append ( field ) column += 1 def _build_record ( self , * fields ): if len ( fields ) != len ( self . _field_names ): raise ValueError ( \"Invalid CSV: incorrect number of fields in data\" ) record = {} column = 0 for col in self . _field_names : value = fields [ column ] if column == self . _title_index : record [ col ] = types . Title [ value ] else : record [ col ] = types . RichText [ value ] column += 1 self . content . append ( record )","title":"CsvParser"},{"location":"reference/#notional.parser.CsvParser.__init__","text":"Initialize a new CsvParser . :param header_row: indicates that data will have a header row (for the schema) :param title_column: set the column in data to use for page titles Source code in notional/parser.py def __init__ ( self , header_row = True , title_column = 0 ): \"\"\"Initialize a new `CsvParser`. :param header_row: indicates that data will have a header row (for the schema) :param title_column: set the column in data to use for page titles \"\"\" super () . __init__ () self . _has_header = header_row self . _title_index = title_column self . schema = {} self . _field_names = []","title":"__init__()"},{"location":"reference/#notional.parser.CsvParser.parse","text":"Parse the given CSV data. Upon return, the following properties will be available in the parser: schema : a computed schema for the supplied data title : the name of the CSV file being parsed (if available) content : a list of page properties with the tabular data Source code in notional/parser.py def parse ( self , data ): \"\"\"Parse the given CSV data. Upon return, the following properties will be available in the parser: `schema`: a computed schema for the supplied data `title`: the name of the CSV file being parsed (if available) `content`: a list of page properties with the tabular data \"\"\" super () . parse ( data ) if isinstance ( data , str ): data = io . StringIO ( data , newline = \"\" ) reader = csv . reader ( data ) self . _process ( reader )","title":"parse()"},{"location":"reference/#notional.parser.DocumentParser","text":"Base class for document parsers. Source code in notional/parser.py class DocumentParser ( ABC ): \"\"\"Base class for document parsers.\"\"\" title : str content : list def __init__ ( self ): \"\"\"Initlize the document parser.\"\"\" self . title = None self . content = [] @abstractmethod def parse ( self , data ): \"\"\"Parse the given data. This method will attempt to determine a default name for the document from the data source. Subclasses should call this method when implemting `parse()` locally. \"\"\" if hasattr ( data , \"name\" ): self . title = basename ( data . name )","title":"DocumentParser"},{"location":"reference/#notional.parser.DocumentParser.__init__","text":"Initlize the document parser. Source code in notional/parser.py def __init__ ( self ): \"\"\"Initlize the document parser.\"\"\" self . title = None self . content = []","title":"__init__()"},{"location":"reference/#notional.parser.DocumentParser.parse","text":"Parse the given data. This method will attempt to determine a default name for the document from the data source. Subclasses should call this method when implemting parse() locally. Source code in notional/parser.py @abstractmethod def parse ( self , data ): \"\"\"Parse the given data. This method will attempt to determine a default name for the document from the data source. Subclasses should call this method when implemting `parse()` locally. \"\"\" if hasattr ( data , \"name\" ): self . title = basename ( data . name )","title":"parse()"},{"location":"reference/#notional.parser.HtmlParser","text":"An HTML parser that leverages the WHATWG HTML spec. Source code in notional/parser.py class HtmlParser ( DocumentParser ): \"\"\"An HTML parser that leverages the WHATWG HTML spec.\"\"\" meta : dict def __init__ ( self , base = None ): \"\"\"Initialize an empty `HtmlParser`. :param base: the base URL for resolving relative paths \"\"\" super () . __init__ () self . _base_url = base self . meta = {} self . _current_href = None self . _current_text_style = Annotations () def parse ( self , data ): \"\"\"Parse the given HTML data. Upon return, the following properties will be available in the parser: `title`: contents of the `<title>` element if found `content`: a list of blocks containing rendered content from the HTML data `meta`: a dictionary of any `<meta>` tags that were found \"\"\" super () . parse ( data ) doc = html5lib . parse ( data , namespaceHTMLElements = False ) self . _render ( doc ) def _render ( self , elem , parent = None ): \"\"\"Render the given element as a child of `parent`. This method will look for an appropriate `render_*` method to handle the given tag name. If there is not an available method, the element will be ignored. :param elem: the ElementTree object to render :param parent: the parent block for the rendered content or `None` \"\"\" log . debug ( \"rendering element - %s :: %s \" , elem . tag , type ( parent )) if parent is None : parent = self . content if hasattr ( self , f \"_render_ { elem . tag } \" ): log . debug ( \"handler func -- _render_ %s \" , elem . tag ) pfunc = getattr ( self , f \"_render_ { elem . tag } \" ) pfunc ( elem , parent ) log . debug ( \"block complete; %d total block(s)\" , len ( self . content )) def _render_a ( self , elem , parent ): self . _current_href = elem . get ( \"href\" ) self . _process_contents ( elem , parent = parent ) self . _current_href = None def _render_b ( self , elem , parent ): self . _current_text_style . bold = True self . _process_contents ( elem , parent = parent ) self . _current_text_style . bold = False def _render_base ( self , elem , parent ): base = elem . get ( \"href\" ) if base is not None : self . _base_url = base def _render_blockquote ( self , elem , parent ): block = blocks . Quote () self . _process_contents ( elem , parent = block ) parent . append ( block ) def _render_body ( self , elem , parent ): self . _process_contents ( elem , parent = parent ) def _render_br ( self , elem , parent ): if isinstance ( parent , blocks . TextBlock ): parent . concat ( \" \\n \" ) def _render_code ( self , elem , parent ): self . _current_text_style . code = True self . _process_contents ( elem , parent = parent ) self . _current_text_style . code = False def _render_dd ( self , elem , parent ): self . _process_contents ( elem , parent = parent ) def _render_del ( self , elem , parent ): self . _current_text_style . strikethrough = True self . _process_contents ( elem , parent = parent ) self . _current_text_style . strikethrough = False def _render_div ( self , elem , parent ): self . _process_contents ( elem , parent ) def _render_dl ( self , elem , parent ): dl = blocks . Paragraph () self . _process_contents ( elem , parent = dl ) parent . append ( dl ) def _render_dt ( self , elem , parent ): self . _process_contents ( elem , parent = parent ) def _render_em ( self , elem , parent ): self . _render_i ( elem , parent ) def _render_h1 ( self , elem , parent ): h1 = blocks . Heading1 () self . _process_contents ( elem , parent = h1 ) parent . append ( h1 ) def _render_h2 ( self , elem , parent ): h2 = blocks . Heading2 () self . _process_contents ( elem , parent = h2 ) parent . append ( h2 ) def _render_h3 ( self , elem , parent ): h3 = blocks . Heading3 () self . _process_contents ( elem , parent = h3 ) parent . append ( h3 ) def _render_h4 ( self , elem , parent ): self . _render_h3 ( elem , parent ) def _render_h5 ( self , elem , parent ): self . _render_h3 ( elem , parent ) def _render_h6 ( self , elem , parent ): self . _render_h3 ( elem , parent ) def _render_head ( self , elem , parent ): self . _process_contents ( elem , parent = parent ) def _render_hgroup ( self , elem , parent ): self . _process_contents ( elem , parent = parent ) def _render_hr ( self , elem , parent ): parent . append ( blocks . Divider ()) def _render_html ( self , elem , parent ): self . _process_contents ( elem , parent = parent ) def _render_i ( self , elem , parent ): self . _current_text_style . italic = True self . _process_contents ( elem , parent = parent ) self . _current_text_style . italic = False def _render_iframe ( self , elem , parent ): src = elem . get ( \"src\" ) if src is not None : block = blocks . Embed [ src ] parent . append ( block ) def _render_img ( self , elem , parent ): src = elem . get ( \"src\" ) # TODO use self._base_url for relative paths # TODO support embedded images (data:image) as HostedFile... if src is not None : file = types . ExternalFile [ src ] img = blocks . Image ( image = file ) parent . append ( img ) def _render_ins ( self , elem , parent ): self . _render_u ( elem , parent ) def _render_kbd ( self , elem , parent ): self . _render_code ( elem , parent ) def _render_li ( self , elem , parent ): self . _process_contents ( elem , parent ) def _render_menu ( self , elem , parent ): self . _render_ul ( elem , parent ) def _render_meta ( self , elem , parent ): name = elem . get ( \"name\" ) value = elem . get ( \"content\" ) if name and value : self . meta [ name ] = value def _render_object ( self , elem , parent ): # XXX support 'data' attribute as an embed or upload? self . _process_contents ( elem , parent = parent ) def _render_ol ( self , elem , parent ): self . _process_list ( elem , parent , blocks . NumberedListItem ) def _render_p ( self , elem , parent ): para = blocks . Paragraph () self . _process_contents ( elem , parent = para ) parent . append ( para ) def _render_pre ( self , elem , parent ): block = blocks . Code () self . _process_contents ( elem , parent = block ) parent . append ( block ) def _render_s ( self , elem , parent ): self . _render_del ( elem , parent ) def _render_samp ( self , elem , parent ): self . _render_code ( elem , parent ) def _render_span ( self , elem , parent ): self . _process_contents ( elem , parent = parent ) def _render_strike ( self , elem , parent ): self . _render_del ( elem , parent ) def _render_strong ( self , elem , parent ): self . _render_b ( elem , parent ) def _render_table ( self , elem , parent ): table = blocks . Table () self . _process_contents ( elem , parent = table ) if table . Width > 0 : parent . append ( table ) def _render_tbody ( self , elem , parent ): self . _process_contents ( elem , parent ) def _render_td ( self , elem , parent ): if not isinstance ( parent , blocks . TableRow ): raise TypeError ( \"Invalid parent for <td>\" ) if elem_has_text ( elem ): self . _process_contents ( elem , parent = parent ) else : self . _append_text ( \"\" , parent ) def _render_tfoot ( self , elem , parent ): self . _process_contents ( elem , parent = parent ) def _render_th ( self , elem , parent ): self . _render_td ( elem , parent = parent ) def _render_thead ( self , elem , parent ): if not isinstance ( parent , blocks . Table ): raise TypeError ( \"Invalid parent for <thead>\" ) parent . table . has_column_header = True self . _process_contents ( elem , parent = parent ) def _render_title ( self , elem , parent ): self . title = gather_text ( elem ) def _render_tr ( self , elem , parent ): if not isinstance ( parent , blocks . Table ): raise TypeError ( \"Invalid parent for <tr>\" ) row = blocks . TableRow () for td in elem . findall ( \"td\" ): self . _render ( td , parent = row ) parent . append ( row ) def _render_tt ( self , elem , parent ): self . _render_pre ( elem , parent = parent ) def _render_u ( self , elem , parent ): self . _current_text_style . underline = True self . _process_contents ( elem , parent = parent ) self . _current_text_style . underline = False def _render_ul ( self , elem , parent ): self . _process_list ( elem , parent , blocks . BulletedListItem ) def _render_var ( self , elem , parent ): self . _render_code ( elem , parent = parent ) def _append_text ( self , text , parent ): \"\"\"Append text to the given parent using current style and link information. If the parent does not support text children, the text will be ignored. When appropriate, whitespace in the text will be removed. \"\"\" log . debug ( \"appending text :: %s => ' %s '\" , parent . type , truncate ( text , 10 )) if not isinstance ( parent , blocks . Code ): text = condense_text ( text ) obj = TextObject [ text , self . _current_href , self . _current_text_style ] if isinstance ( parent , blocks . TextBlock ): if obj is not None : parent . concat ( obj ) elif isinstance ( parent , blocks . TableRow ): parent . append ( obj ) def _process_contents ( self , elem , parent ): \"\"\"Process the contents of the given element as children of `parent`. This will process all children of the element, including text and nodes. \"\"\" log . debug ( \"processing contents :: %s %s \" , elem . tag , type ( parent )) # empty elements don't need text processing... if not elem_has_text ( elem , with_children = False ): has_text = False # TextBlock's can hold text directly... elif isinstance ( parent , blocks . TextBlock ): has_text = True # so can TableRow's... elif isinstance ( parent , blocks . TableRow ): has_text = True # otherwise, we need a new parent to hold text... else : has_text = True new_parent = blocks . Paragraph () parent . append ( new_parent ) parent = new_parent if has_text : self . _append_text ( elem . text , parent ) for child in elem : self . _render ( child , parent ) if has_text : self . _append_text ( child . tail , parent ) if isinstance ( parent , blocks . TextBlock ): strip_text_block ( parent ) def _process_list ( self , elem , parent , kind ): \"\"\"Process contents of the given element as a list. :param elem: the element to process :param parent: the parent for list items and nested lists :param kind: a class used to render `<li>` tags \"\"\" list_parent = parent for child in elem : if child . tag == \"li\" : list_parent = kind () self . _render ( child , parent = list_parent ) parent . append ( list_parent ) else : self . _render ( child , list_parent ) def _process_img_data ( self , elem ): import base64 import tempfile log . debug ( \"processing image\" ) # TODO this probably needs more error handling and better flow img_src = elem [ \"src\" ] m = img_data_re . match ( img_src ) if m is None : raise ValueError ( \"Image data missing\" ) img_type = m . groups ()[ 0 ] img_data_enc = m . groups ()[ 1 ] img_data_str = m . groups ()[ 2 ] log . debug ( \"decoding embedded image: %s [ %s ]\" , img_type , img_data_enc ) if img_data_enc == \"base64\" : log . debug ( \"decoding base64 image: %d bytes\" , len ( img_data_str )) img_data_b64 = img_data_str . encode ( \"ascii\" ) img_data = base64 . b64decode ( img_data_b64 ) else : raise ValueError ( f \"Unsupported img encoding: { img_data_enc } \" ) log . debug ( \"preparing %d bytes for image upload\" , len ( img_data )) with tempfile . NamedTemporaryFile ( suffix = f \". { img_type } \" ) as fp : log . debug ( \"using temporary file: %s \" , fp . name ) fp . write ( img_data ) # TODO upload the image to Notion","title":"HtmlParser"},{"location":"reference/#notional.parser.HtmlParser.__init__","text":"Initialize an empty HtmlParser . :param base: the base URL for resolving relative paths Source code in notional/parser.py def __init__ ( self , base = None ): \"\"\"Initialize an empty `HtmlParser`. :param base: the base URL for resolving relative paths \"\"\" super () . __init__ () self . _base_url = base self . meta = {} self . _current_href = None self . _current_text_style = Annotations ()","title":"__init__()"},{"location":"reference/#notional.parser.HtmlParser.parse","text":"Parse the given HTML data. Upon return, the following properties will be available in the parser: title : contents of the <title> element if found content : a list of blocks containing rendered content from the HTML data meta : a dictionary of any <meta> tags that were found Source code in notional/parser.py def parse ( self , data ): \"\"\"Parse the given HTML data. Upon return, the following properties will be available in the parser: `title`: contents of the `<title>` element if found `content`: a list of blocks containing rendered content from the HTML data `meta`: a dictionary of any `<meta>` tags that were found \"\"\" super () . parse ( data ) doc = html5lib . parse ( data , namespaceHTMLElements = False ) self . _render ( doc )","title":"parse()"},{"location":"reference/#notional.parser.condense_text","text":"Collapse contiguous whitespace from the given text. Source code in notional/parser.py def condense_text ( text ): \"\"\"Collapse contiguous whitespace from the given text.\"\"\" if text is None : return None return re . sub ( r \"\\s+\" , \" \" , text , flags = re . MULTILINE )","title":"condense_text()"},{"location":"reference/#notional.parser.elem_has_text","text":"Determine if the element has any visible text. :param elem: the element to examine :param with_children: whether to include children nodes in the search Source code in notional/parser.py def elem_has_text ( elem , with_children = True ): \"\"\"Determine if the element has any visible text. :param elem: the element to examine :param with_children: whether to include children nodes in the search \"\"\" # first, check the direct text of the element... if elem . text is not None and not elem . text . isspace (): return True # now, we need to check the tail of each child... for child in elem : if with_children and elem_has_text ( child ): return True if child . tail is None : continue if not child . tail . isspace (): return True return False","title":"elem_has_text()"},{"location":"reference/#notional.parser.gather_text","text":"Return all text from the element and children. Source code in notional/parser.py def gather_text ( elem ): \"\"\"Return all text from the element and children.\"\"\" text = \"\" . join ( elem . itertext ()) return normalize_text ( text )","title":"gather_text()"},{"location":"reference/#notional.parser.normalize_text","text":"Remove extra whitespace from the given text. Source code in notional/parser.py def normalize_text ( text ): \"\"\"Remove extra whitespace from the given text.\"\"\" if text is None : return None text = text . strip () return condense_text ( text )","title":"normalize_text()"},{"location":"reference/#notional.parser.strip_text_block","text":"Remove leading and trailing whitespace from text in the given block. Source code in notional/parser.py def strip_text_block ( block ): \"\"\"Remove leading and trailing whitespace from text in the given block.\"\"\" if not isinstance ( block , blocks . TextBlock ): return if isinstance ( block , blocks . Code ): return block_text = block . __text__ if block_text is not None and len ( block_text ) > 0 : lstrip ( block_text [ 0 ]) rstrip ( block_text [ - 1 ])","title":"strip_text_block()"},{"location":"reference/#notional.query","text":"Provides an interactive query builder for Notion databases.","title":"query"},{"location":"reference/#notional.query.CheckboxCondition","text":"Represents checkbox criteria in Notion. Source code in notional/query.py class CheckboxCondition ( DataObject ): \"\"\"Represents checkbox criteria in Notion.\"\"\" equals : Optional [ bool ] = None does_not_equal : Optional [ bool ] = None","title":"CheckboxCondition"},{"location":"reference/#notional.query.CompoundFilter","text":"Represents a compound filter in Notion. Source code in notional/query.py class CompoundFilter ( QueryFilter ): \"\"\"Represents a compound filter in Notion.\"\"\" class Config : \"\"\"Pydantic configuration class to support keyword fields.\"\"\" allow_population_by_field_name = True and_ : Optional [ List [ QueryFilter ]] = Field ( None , alias = \"and\" ) or_ : Optional [ List [ QueryFilter ]] = Field ( None , alias = \"or\" )","title":"CompoundFilter"},{"location":"reference/#notional.query.CompoundFilter.Config","text":"Pydantic configuration class to support keyword fields. Source code in notional/query.py class Config : \"\"\"Pydantic configuration class to support keyword fields.\"\"\" allow_population_by_field_name = True","title":"Config"},{"location":"reference/#notional.query.CreatedTimeFilter","text":"Represents a created_time filter in Notion. Source code in notional/query.py class CreatedTimeFilter ( TimestampFilter ): \"\"\"Represents a created_time filter in Notion.\"\"\" timestamp : TimestampKind = TimestampKind . CREATED_TIME created_time : DateCondition @classmethod def create ( cls , constraint ): \"\"\"Create a new `CreatedTimeFilter` using the given constraint.\"\"\" return CreatedTimeFilter ( created_time = constraint )","title":"CreatedTimeFilter"},{"location":"reference/#notional.query.CreatedTimeFilter.create","text":"Create a new CreatedTimeFilter using the given constraint. Source code in notional/query.py @classmethod def create ( cls , constraint ): \"\"\"Create a new `CreatedTimeFilter` using the given constraint.\"\"\" return CreatedTimeFilter ( created_time = constraint )","title":"create()"},{"location":"reference/#notional.query.DateCondition","text":"Represents date criteria in Notion. Source code in notional/query.py class DateCondition ( DataObject ): \"\"\"Represents date criteria in Notion.\"\"\" equals : Optional [ Union [ date , datetime ]] = None before : Optional [ Union [ date , datetime ]] = None after : Optional [ Union [ date , datetime ]] = None on_or_before : Optional [ Union [ date , datetime ]] = None on_or_after : Optional [ Union [ date , datetime ]] = None is_empty : Optional [ bool ] = None is_not_empty : Optional [ bool ] = None past_week : Optional [ Any ] = None past_month : Optional [ Any ] = None past_year : Optional [ Any ] = None next_week : Optional [ Any ] = None next_month : Optional [ Any ] = None next_year : Optional [ Any ] = None","title":"DateCondition"},{"location":"reference/#notional.query.FilesCondition","text":"Represents files criteria in Notion. Source code in notional/query.py class FilesCondition ( DataObject ): \"\"\"Represents files criteria in Notion.\"\"\" is_empty : Optional [ bool ] = None is_not_empty : Optional [ bool ] = None","title":"FilesCondition"},{"location":"reference/#notional.query.FormulaCondition","text":"Represents formula criteria in Notion. Source code in notional/query.py class FormulaCondition ( DataObject ): \"\"\"Represents formula criteria in Notion.\"\"\" text : Optional [ TextCondition ] = None checkbox : Optional [ CheckboxCondition ] = None number : Optional [ NumberCondition ] = None date : Optional [ DateCondition ] = None","title":"FormulaCondition"},{"location":"reference/#notional.query.LastEditedTimeFilter","text":"Represents a last_edited_time filter in Notion. Source code in notional/query.py class LastEditedTimeFilter ( TimestampFilter ): \"\"\"Represents a last_edited_time filter in Notion.\"\"\" timestamp : TimestampKind = TimestampKind . LAST_EDITED_TIME last_edited_time : DateCondition @classmethod def create ( cls , constraint ): \"\"\"Create a new `LastEditedTimeFilter` using the given constraint.\"\"\" return LastEditedTimeFilter ( last_edited_time = constraint )","title":"LastEditedTimeFilter"},{"location":"reference/#notional.query.LastEditedTimeFilter.create","text":"Create a new LastEditedTimeFilter using the given constraint. Source code in notional/query.py @classmethod def create ( cls , constraint ): \"\"\"Create a new `LastEditedTimeFilter` using the given constraint.\"\"\" return LastEditedTimeFilter ( last_edited_time = constraint )","title":"create()"},{"location":"reference/#notional.query.MultiSelectCondition","text":"Represents a multi_select criteria in Notion. Source code in notional/query.py class MultiSelectCondition ( DataObject ): \"\"\"Represents a multi_select criteria in Notion.\"\"\" contains : Optional [ str ] = None does_not_contains : Optional [ str ] = None is_empty : Optional [ bool ] = None is_not_empty : Optional [ bool ] = None","title":"MultiSelectCondition"},{"location":"reference/#notional.query.NumberCondition","text":"Represents number criteria in Notion. Source code in notional/query.py class NumberCondition ( DataObject ): \"\"\"Represents number criteria in Notion.\"\"\" equals : Optional [ Union [ float , int ]] = None does_not_equal : Optional [ Union [ float , int ]] = None greater_than : Optional [ Union [ float , int ]] = None less_than : Optional [ Union [ float , int ]] = None greater_than_or_equal_to : Optional [ Union [ float , int ]] = None less_than_or_equal_to : Optional [ Union [ float , int ]] = None is_empty : Optional [ bool ] = None is_not_empty : Optional [ bool ] = None","title":"NumberCondition"},{"location":"reference/#notional.query.PeopleCondition","text":"Represents people criteria in Notion. Source code in notional/query.py class PeopleCondition ( DataObject ): \"\"\"Represents people criteria in Notion.\"\"\" contains : Optional [ UUID ] = None does_not_contain : Optional [ UUID ] = None is_empty : Optional [ bool ] = None is_not_empty : Optional [ bool ] = None","title":"PeopleCondition"},{"location":"reference/#notional.query.PropertyFilter","text":"Represents a database property filter in Notion. Source code in notional/query.py class PropertyFilter ( QueryFilter ): \"\"\"Represents a database property filter in Notion.\"\"\" property : str rich_text : Optional [ TextCondition ] = None phone_number : Optional [ TextCondition ] = None number : Optional [ NumberCondition ] = None checkbox : Optional [ CheckboxCondition ] = None select : Optional [ SelectCondition ] = None multi_select : Optional [ MultiSelectCondition ] = None date : Optional [ DateCondition ] = None people : Optional [ PeopleCondition ] = None files : Optional [ FilesCondition ] = None relation : Optional [ RelationCondition ] = None formula : Optional [ FormulaCondition ] = None","title":"PropertyFilter"},{"location":"reference/#notional.query.PropertySort","text":"Represents a sort instruction in Notion. Source code in notional/query.py class PropertySort ( DataObject ): \"\"\"Represents a sort instruction in Notion.\"\"\" property : Optional [ str ] = None timestamp : Optional [ TimestampKind ] = None direction : Optional [ SortDirection ] = None","title":"PropertySort"},{"location":"reference/#notional.query.Query","text":"Represents a query object in Notion. Source code in notional/query.py class Query ( DataObject ): \"\"\"Represents a query object in Notion.\"\"\" sorts : Optional [ List [ PropertySort ]] = None filter : Optional [ QueryFilter ] = None start_cursor : Optional [ UUID ] = None page_size : int = 100 @validator ( \"page_size\" ) def valid_page_size ( cls , value ): \"\"\"Validate that the given page size meets the Notion API requirements.\"\"\" assert value > 0 , \"size must be greater than zero\" assert value <= 100 , \"size must be less than or equal to 100\" return value","title":"Query"},{"location":"reference/#notional.query.Query.valid_page_size","text":"Validate that the given page size meets the Notion API requirements. Source code in notional/query.py @validator ( \"page_size\" ) def valid_page_size ( cls , value ): \"\"\"Validate that the given page size meets the Notion API requirements.\"\"\" assert value > 0 , \"size must be greater than zero\" assert value <= 100 , \"size must be less than or equal to 100\" return value","title":"valid_page_size()"},{"location":"reference/#notional.query.QueryBuilder","text":"A query builder for the Notion API. :param endpoint: the session endpoint used to execute the query :param cls: an optional DataObject class for parsing results :param params: optional params that will be passed to the query Source code in notional/query.py class QueryBuilder : \"\"\"A query builder for the Notion API. :param endpoint: the session endpoint used to execute the query :param cls: an optional DataObject class for parsing results :param params: optional params that will be passed to the query \"\"\" def __init__ ( self , endpoint , cls = None , ** params ): \"\"\"Initialize a new `QueryBuilder` for the given endpoint.\"\"\" self . endpoint = endpoint self . params = params self . cls = cls self . query = Query () def filter ( self , filter = None , ** kwargs ): \"\"\"Add the given filter to the query.\"\"\" if filter is None : if \"property\" in kwargs : filter = PropertyFilter . parse_obj ( kwargs ) elif \"timestamp\" in kwargs and kwargs [ \"timestamp\" ] == \"created_time\" : filter = CreatedTimeFilter . parse_obj ( kwargs ) elif \"timestamp\" in kwargs and kwargs [ \"timestamp\" ] == \"last_edited_time\" : filter = LastEditedTimeFilter . parse_obj ( kwargs ) else : raise ValueError ( \"unrecognized filter\" ) elif not isinstance ( filter , QueryFilter ): raise ValueError ( \"filter must be of type QueryFilter\" ) # use CompoundFilter when necessary... if self . query . filter is None : self . query . filter = filter elif isinstance ( self . query . filter , CompoundFilter ): self . query . filter . and_ . append ( filter ) else : old_filter = self . query . filter self . query . filter = CompoundFilter ( and_ = [ old_filter , filter ]) return self def sort ( self , sort = None , ** kwargs ): \"\"\"Add the given sort elements to the query.\"\"\" # XXX should this support ORM properties also? # e.g. - query.sort(property=Task.Title) # but users won't always use ORM for queries... if sort is None : sort = PropertySort ( ** kwargs ) elif not isinstance ( filter , PropertySort ): raise ValueError ( \"sort must be of type PropertySort\" ) # use multiple sorts when necessary if self . query . sorts is None : self . query . sorts = [ sort ] else : self . query . sorts . append ( sort ) return self def start_at ( self , page_id ): \"\"\"Set the start cursor to a specific page ID.\"\"\" self . query . start_cursor = page_id return self def limit ( self , page_size ): \"\"\"Limit the number of results to the given page size.\"\"\" self . query . page_size = page_size return self def execute ( self ): \"\"\"Execute the current query and return an iterator for the results.\"\"\" if self . endpoint is None : raise ValueError ( \"cannot execute query; no endpoint provided\" ) log . debug ( \"executing query - %s \" , self . query ) query = self . query . to_api () if self . params : query . update ( self . params ) exec = EndpointIterator ( endpoint = self . endpoint , ** query ) return ResultSet ( exec = exec , cls = self . cls ) def first ( self ): \"\"\"Execute the current query and return the first result only.\"\"\" try : return next ( self . execute ()) except StopIteration : log . debug ( \"iterator returned empty result set\" ) return None","title":"QueryBuilder"},{"location":"reference/#notional.query.QueryBuilder.__init__","text":"Initialize a new QueryBuilder for the given endpoint. Source code in notional/query.py def __init__ ( self , endpoint , cls = None , ** params ): \"\"\"Initialize a new `QueryBuilder` for the given endpoint.\"\"\" self . endpoint = endpoint self . params = params self . cls = cls self . query = Query ()","title":"__init__()"},{"location":"reference/#notional.query.QueryBuilder.execute","text":"Execute the current query and return an iterator for the results. Source code in notional/query.py def execute ( self ): \"\"\"Execute the current query and return an iterator for the results.\"\"\" if self . endpoint is None : raise ValueError ( \"cannot execute query; no endpoint provided\" ) log . debug ( \"executing query - %s \" , self . query ) query = self . query . to_api () if self . params : query . update ( self . params ) exec = EndpointIterator ( endpoint = self . endpoint , ** query ) return ResultSet ( exec = exec , cls = self . cls )","title":"execute()"},{"location":"reference/#notional.query.QueryBuilder.filter","text":"Add the given filter to the query. Source code in notional/query.py def filter ( self , filter = None , ** kwargs ): \"\"\"Add the given filter to the query.\"\"\" if filter is None : if \"property\" in kwargs : filter = PropertyFilter . parse_obj ( kwargs ) elif \"timestamp\" in kwargs and kwargs [ \"timestamp\" ] == \"created_time\" : filter = CreatedTimeFilter . parse_obj ( kwargs ) elif \"timestamp\" in kwargs and kwargs [ \"timestamp\" ] == \"last_edited_time\" : filter = LastEditedTimeFilter . parse_obj ( kwargs ) else : raise ValueError ( \"unrecognized filter\" ) elif not isinstance ( filter , QueryFilter ): raise ValueError ( \"filter must be of type QueryFilter\" ) # use CompoundFilter when necessary... if self . query . filter is None : self . query . filter = filter elif isinstance ( self . query . filter , CompoundFilter ): self . query . filter . and_ . append ( filter ) else : old_filter = self . query . filter self . query . filter = CompoundFilter ( and_ = [ old_filter , filter ]) return self","title":"filter()"},{"location":"reference/#notional.query.QueryBuilder.first","text":"Execute the current query and return the first result only. Source code in notional/query.py def first ( self ): \"\"\"Execute the current query and return the first result only.\"\"\" try : return next ( self . execute ()) except StopIteration : log . debug ( \"iterator returned empty result set\" ) return None","title":"first()"},{"location":"reference/#notional.query.QueryBuilder.limit","text":"Limit the number of results to the given page size. Source code in notional/query.py def limit ( self , page_size ): \"\"\"Limit the number of results to the given page size.\"\"\" self . query . page_size = page_size return self","title":"limit()"},{"location":"reference/#notional.query.QueryBuilder.sort","text":"Add the given sort elements to the query. Source code in notional/query.py def sort ( self , sort = None , ** kwargs ): \"\"\"Add the given sort elements to the query.\"\"\" # XXX should this support ORM properties also? # e.g. - query.sort(property=Task.Title) # but users won't always use ORM for queries... if sort is None : sort = PropertySort ( ** kwargs ) elif not isinstance ( filter , PropertySort ): raise ValueError ( \"sort must be of type PropertySort\" ) # use multiple sorts when necessary if self . query . sorts is None : self . query . sorts = [ sort ] else : self . query . sorts . append ( sort ) return self","title":"sort()"},{"location":"reference/#notional.query.QueryBuilder.start_at","text":"Set the start cursor to a specific page ID. Source code in notional/query.py def start_at ( self , page_id ): \"\"\"Set the start cursor to a specific page ID.\"\"\" self . query . start_cursor = page_id return self","title":"start_at()"},{"location":"reference/#notional.query.QueryFilter","text":"Base class for query filters. Source code in notional/query.py class QueryFilter ( DataObject ): \"\"\"Base class for query filters.\"\"\"","title":"QueryFilter"},{"location":"reference/#notional.query.RelationCondition","text":"Represents relation criteria in Notion. Source code in notional/query.py class RelationCondition ( DataObject ): \"\"\"Represents relation criteria in Notion.\"\"\" contains : Optional [ UUID ] = None does_not_contain : Optional [ UUID ] = None is_empty : Optional [ bool ] = None is_not_empty : Optional [ bool ] = None","title":"RelationCondition"},{"location":"reference/#notional.query.ResultSet","text":"A result for a specific query. Source code in notional/query.py class ResultSet : \"\"\"A result for a specific query.\"\"\" def __init__ ( self , exec , cls = None ): \"\"\"Initialize a new `ResultSet`.\"\"\" self . source = exec self . cls = cls def __iter__ ( self ): \"\"\"Return an iterator for this `ResultSet`.\"\"\" return self def __next__ ( self ): \"\"\"Return the next item from this `ResultSet`.\"\"\" item = next ( self . source ) if self . cls is not None : item = self . cls . parse_obj ( item ) elif \"object\" in item : if item [ \"object\" ] == \"page\" : item = Page . parse_obj ( item ) elif item [ \"object\" ] == \"database\" : item = Database . parse_obj ( item ) elif item [ \"object\" ] == \"block\" : item = Block . parse_obj ( item ) else : item = Record . parse_obj ( item ) return item","title":"ResultSet"},{"location":"reference/#notional.query.ResultSet.__init__","text":"Initialize a new ResultSet . Source code in notional/query.py def __init__ ( self , exec , cls = None ): \"\"\"Initialize a new `ResultSet`.\"\"\" self . source = exec self . cls = cls","title":"__init__()"},{"location":"reference/#notional.query.ResultSet.__iter__","text":"Return an iterator for this ResultSet . Source code in notional/query.py def __iter__ ( self ): \"\"\"Return an iterator for this `ResultSet`.\"\"\" return self","title":"__iter__()"},{"location":"reference/#notional.query.ResultSet.__next__","text":"Return the next item from this ResultSet . Source code in notional/query.py def __next__ ( self ): \"\"\"Return the next item from this `ResultSet`.\"\"\" item = next ( self . source ) if self . cls is not None : item = self . cls . parse_obj ( item ) elif \"object\" in item : if item [ \"object\" ] == \"page\" : item = Page . parse_obj ( item ) elif item [ \"object\" ] == \"database\" : item = Database . parse_obj ( item ) elif item [ \"object\" ] == \"block\" : item = Block . parse_obj ( item ) else : item = Record . parse_obj ( item ) return item","title":"__next__()"},{"location":"reference/#notional.query.SelectCondition","text":"Represents select criteria in Notion. Source code in notional/query.py class SelectCondition ( DataObject ): \"\"\"Represents select criteria in Notion.\"\"\" equals : Optional [ str ] = None does_not_equal : Optional [ str ] = None is_empty : Optional [ bool ] = None is_not_empty : Optional [ bool ] = None","title":"SelectCondition"},{"location":"reference/#notional.query.SortDirection","text":"Sort direction options. Source code in notional/query.py class SortDirection ( str , Enum ): \"\"\"Sort direction options.\"\"\" ASCENDING = \"ascending\" DESCENDING = \"descending\"","title":"SortDirection"},{"location":"reference/#notional.query.TextCondition","text":"Represents text criteria in Notion. Source code in notional/query.py class TextCondition ( DataObject ): \"\"\"Represents text criteria in Notion.\"\"\" equals : Optional [ str ] = None does_not_equal : Optional [ str ] = None contains : Optional [ str ] = None does_not_contain : Optional [ str ] = None starts_with : Optional [ str ] = None ends_with : Optional [ str ] = None is_empty : Optional [ bool ] = None is_not_empty : Optional [ bool ] = None","title":"TextCondition"},{"location":"reference/#notional.query.TimestampFilter","text":"Represents a timestamp filter in Notion. Source code in notional/query.py class TimestampFilter ( QueryFilter ): \"\"\"Represents a timestamp filter in Notion.\"\"\" timestamp : TimestampKind @classmethod def create ( cls , kind , constraint ): \"\"\"Create a new `TimeStampFilter` using the given constraint.\"\"\" if kind == TimestampKind . CREATED_TIME : return CreatedTimeFilter . create ( constraint ) if kind == TimestampKind . LAST_EDITED_TIME : return LastEditedTimeFilter . create ( constraint ) raise ValueError ( \"Unsupported kind for timestamp\" )","title":"TimestampFilter"},{"location":"reference/#notional.query.TimestampFilter.create","text":"Create a new TimeStampFilter using the given constraint. Source code in notional/query.py @classmethod def create ( cls , kind , constraint ): \"\"\"Create a new `TimeStampFilter` using the given constraint.\"\"\" if kind == TimestampKind . CREATED_TIME : return CreatedTimeFilter . create ( constraint ) if kind == TimestampKind . LAST_EDITED_TIME : return LastEditedTimeFilter . create ( constraint ) raise ValueError ( \"Unsupported kind for timestamp\" )","title":"create()"},{"location":"reference/#notional.query.TimestampKind","text":"Possible timestamp types. Source code in notional/query.py class TimestampKind ( str , Enum ): \"\"\"Possible timestamp types.\"\"\" CREATED_TIME = \"created_time\" LAST_EDITED_TIME = \"last_edited_time\"","title":"TimestampKind"},{"location":"reference/#notional.query.get_target_id","text":"Examine the given target and returns the appropriate ID as a string. Source code in notional/query.py def get_target_id ( target ): \"\"\"Examine the given target and returns the appropriate ID as a string.\"\"\" if isinstance ( target , str ): return target if isinstance ( target , UUID ): return target . hex if isinstance ( target , Record ): return target . id . hex if isinstance ( target , ParentRef ): return target () . hex if isclass ( target ) and issubclass ( target , ConnectedPage ): return target . _notional__database raise ValueError ( \"unsupported query target\" )","title":"get_target_id()"},{"location":"reference/#notional.records","text":"Wrapper for Notion API data types. These objects provide both access to the primitive data structure returned by the API as well as higher-level access methods. In general, attributes in lower case represent the primitive data structure, where capitalized attributes provide higher-level access.","title":"records"},{"location":"reference/#notional.records.BlockRef","text":"Reference a block. Source code in notional/records.py class BlockRef ( ParentRef , type = \"block_id\" ): \"\"\"Reference a block.\"\"\" block_id : UUID","title":"BlockRef"},{"location":"reference/#notional.records.Database","text":"A database record type. Source code in notional/records.py class Database ( Record , object = \"database\" ): \"\"\"A database record type.\"\"\" title : List [ RichTextObject ] = None url : str = None parent : ParentRef = None icon : Optional [ Union [ FileObject , EmojiObject ]] = None cover : Optional [ FileObject ] = None properties : Dict [ str , PropertyObject ] = {} @property def Title ( self ): \"\"\"Return the title of this database as plain text.\"\"\" if self . title is None or len ( self . title ) == 0 : return None return plain_text ( * self . title )","title":"Database"},{"location":"reference/#notional.records.Database.Title","text":"Return the title of this database as plain text.","title":"Title"},{"location":"reference/#notional.records.DatabaseRef","text":"Reference a database. Source code in notional/records.py class DatabaseRef ( ParentRef , type = \"database_id\" ): \"\"\"Reference a database.\"\"\" database_id : UUID","title":"DatabaseRef"},{"location":"reference/#notional.records.Page","text":"A standard Notion page object. Source code in notional/records.py class Page ( Record , object = \"page\" ): \"\"\"A standard Notion page object.\"\"\" url : str = None parent : ParentRef = None icon : Optional [ Union [ FileObject , EmojiObject ]] = None cover : Optional [ FileObject ] = None properties : Dict [ str , PropertyValue ] = {} def __getitem__ ( self , name ): \"\"\"Indexer for the given property name. :param name: the name of the property to get from the internal properties \"\"\" log . debug ( \"get property :: { %s } [ %s ]\" , self . id , name ) if self . properties is None : raise AttributeError ( \"No properties in Page\" ) prop = self . properties . get ( name ) if prop is None : raise AttributeError ( f \"No such property: { name } \" ) return prop def __setitem__ ( self , name , value ): \"\"\"Set the object data for the given property. If `value` is `None`, the property data will be deleted from the page. This does not affect the schema of the page, only the contents of the property. :param name: the name of the property to set in the internal properties :param prop: the PropertyValue for the named property :param value: the new value for the given property \"\"\" log . debug ( \"set property :: { %s } [ %s ] => %s \" , self . id , name , value ) if value is None : self . properties . pop ( name , None ) elif not isinstance ( value , PropertyValue ): raise ValueError ( f \"Unable to set { name } :: unsupported value type\" ) else : self . properties [ name ] = value @property def Title ( self ): \"\"\"Return the title of this page as a string. The title of a page is stored in its properties. This method will examine the page properties, looking for the appropriate `title` entry and return as a string. \"\"\" if self . properties is None or len ( self . properties ) == 0 : return None for prop in self . properties . values (): if prop . id == \"title\" : return prop . Value or None return None","title":"Page"},{"location":"reference/#notional.records.Page.Title","text":"Return the title of this page as a string. The title of a page is stored in its properties. This method will examine the page properties, looking for the appropriate title entry and return as a string.","title":"Title"},{"location":"reference/#notional.records.Page.__getitem__","text":"Indexer for the given property name. :param name: the name of the property to get from the internal properties Source code in notional/records.py def __getitem__ ( self , name ): \"\"\"Indexer for the given property name. :param name: the name of the property to get from the internal properties \"\"\" log . debug ( \"get property :: { %s } [ %s ]\" , self . id , name ) if self . properties is None : raise AttributeError ( \"No properties in Page\" ) prop = self . properties . get ( name ) if prop is None : raise AttributeError ( f \"No such property: { name } \" ) return prop","title":"__getitem__()"},{"location":"reference/#notional.records.Page.__setitem__","text":"Set the object data for the given property. If value is None , the property data will be deleted from the page. This does not affect the schema of the page, only the contents of the property. :param name: the name of the property to set in the internal properties :param prop: the PropertyValue for the named property :param value: the new value for the given property Source code in notional/records.py def __setitem__ ( self , name , value ): \"\"\"Set the object data for the given property. If `value` is `None`, the property data will be deleted from the page. This does not affect the schema of the page, only the contents of the property. :param name: the name of the property to set in the internal properties :param prop: the PropertyValue for the named property :param value: the new value for the given property \"\"\" log . debug ( \"set property :: { %s } [ %s ] => %s \" , self . id , name , value ) if value is None : self . properties . pop ( name , None ) elif not isinstance ( value , PropertyValue ): raise ValueError ( f \"Unable to set { name } :: unsupported value type\" ) else : self . properties [ name ] = value","title":"__setitem__()"},{"location":"reference/#notional.records.PageRef","text":"Reference a page. Source code in notional/records.py class PageRef ( ParentRef , type = \"page_id\" ): \"\"\"Reference a page.\"\"\" page_id : UUID","title":"PageRef"},{"location":"reference/#notional.records.ParentRef","text":"Reference another block. Source code in notional/records.py class ParentRef ( TypedObject ): \"\"\"Reference another block.\"\"\" # XXX Notion does not handle parent references consistently in the API... # in some cases, the `type` is accepted and in others it is not. eventually # these should all by TypedObject's with the appropriate fields @classmethod def __compose__ ( cls , record ): \"\"\"Return the correct parent ID based on the object type.\"\"\" if isinstance ( record , ParentRef ): return record if isinstance ( record , Page ): return PageRef ( page_id = record . id ) if isinstance ( record , Database ): return DatabaseRef ( database_id = record . id ) raise ValueError ( \"Unrecognized 'parent' attribute\" )","title":"ParentRef"},{"location":"reference/#notional.records.ParentRef.__compose__","text":"Return the correct parent ID based on the object type. Source code in notional/records.py @classmethod def __compose__ ( cls , record ): \"\"\"Return the correct parent ID based on the object type.\"\"\" if isinstance ( record , ParentRef ): return record if isinstance ( record , Page ): return PageRef ( page_id = record . id ) if isinstance ( record , Database ): return DatabaseRef ( database_id = record . id ) raise ValueError ( \"Unrecognized 'parent' attribute\" )","title":"__compose__()"},{"location":"reference/#notional.records.Record","text":"The base type for Notion API records. Source code in notional/records.py class Record ( NamedObject ): \"\"\"The base type for Notion API records.\"\"\" id : UUID = None created_time : datetime = None last_edited_time : datetime = None has_children : bool = False archived : bool = False","title":"Record"},{"location":"reference/#notional.records.WorkspaceParent","text":"Reference the workspace. Source code in notional/records.py class WorkspaceParent ( ParentRef , type = \"workspace\" ): \"\"\"Reference the workspace.\"\"\" workspace : bool = True","title":"WorkspaceParent"},{"location":"reference/#notional.schema","text":"Objects representing a database schema.","title":"schema"},{"location":"reference/#notional.schema.Checkbox","text":"Defines the checkbox configuration for a database property. Source code in notional/schema.py class Checkbox ( PropertyObject , type = \"checkbox\" ): \"\"\"Defines the checkbox configuration for a database property.\"\"\" checkbox : Any = {}","title":"Checkbox"},{"location":"reference/#notional.schema.CreatedBy","text":"Defines the created-by configuration for a database property. Source code in notional/schema.py class CreatedBy ( PropertyObject , type = \"created_by\" ): \"\"\"Defines the created-by configuration for a database property.\"\"\" created_by : Any = {}","title":"CreatedBy"},{"location":"reference/#notional.schema.CreatedTime","text":"Defines the created-time configuration for a database property. Source code in notional/schema.py class CreatedTime ( PropertyObject , type = \"created_time\" ): \"\"\"Defines the created-time configuration for a database property.\"\"\" created_time : Any = {}","title":"CreatedTime"},{"location":"reference/#notional.schema.Date","text":"Defines the date configuration for a database property. Source code in notional/schema.py class Date ( PropertyObject , type = \"date\" ): \"\"\"Defines the date configuration for a database property.\"\"\" date : Any = {}","title":"Date"},{"location":"reference/#notional.schema.Email","text":"Defines the email configuration for a database property. Source code in notional/schema.py class Email ( PropertyObject , type = \"email\" ): \"\"\"Defines the email configuration for a database property.\"\"\" email : Any = {}","title":"Email"},{"location":"reference/#notional.schema.Files","text":"Defines the files configuration for a database property. Source code in notional/schema.py class Files ( PropertyObject , type = \"files\" ): \"\"\"Defines the files configuration for a database property.\"\"\" files : Any = {}","title":"Files"},{"location":"reference/#notional.schema.Formula","text":"Defines the formula configuration for a database property. Source code in notional/schema.py class Formula ( PropertyObject , type = \"formula\" ): \"\"\"Defines the formula configuration for a database property.\"\"\" class _NestedData ( NestedObject ): expression : str = None formula : _NestedData = _NestedData ()","title":"Formula"},{"location":"reference/#notional.schema.Function","text":"Standard aggregation functions. Source code in notional/schema.py class Function ( str , Enum ): \"\"\"Standard aggregation functions.\"\"\" COUNT_ALL = \"count_all\" COUNT_VALUES = \"count_values\" COUNT_UNIQUE_VALUES = \"count_unique_values\" COUNT_EMPTY = \"count_empty\" COUNT_NOT_EMPTY = \"count_not_empty\" PERCENT_EMPTY = \"percent_empty\" PERCENT_NOT_EMPTY = \"percent_not_empty\" AVERAGE = \"average\" MIN = \"min\" MAX = \"max\" MEDIAN = \"median\" RANGE = \"range\" SUM = \"sum\" EARLIEST_DATE = \"earliest_date\" LATEST_DATE = \"latest_date\" SHOW_ORIGINAL = \"show_original\"","title":"Function"},{"location":"reference/#notional.schema.LastEditedBy","text":"Defines the last-edited-by configuration for a database property. Source code in notional/schema.py class LastEditedBy ( PropertyObject , type = \"last_edited_by\" ): \"\"\"Defines the last-edited-by configuration for a database property.\"\"\" last_edited_by : Any = {}","title":"LastEditedBy"},{"location":"reference/#notional.schema.LastEditedTime","text":"Defines the last-edited-time configuration for a database property. Source code in notional/schema.py class LastEditedTime ( PropertyObject , type = \"last_edited_time\" ): \"\"\"Defines the last-edited-time configuration for a database property.\"\"\" last_edited_time : Any = {}","title":"LastEditedTime"},{"location":"reference/#notional.schema.MultiSelect","text":"Defines the multi-select configuration for a database property. Source code in notional/schema.py class MultiSelect ( PropertyObject , type = \"multi_select\" ): \"\"\"Defines the multi-select configuration for a database property.\"\"\" class _NestedData ( NestedObject ): options : List [ SelectOption ] = [] multi_select : _NestedData = _NestedData ()","title":"MultiSelect"},{"location":"reference/#notional.schema.Number","text":"Defines the number configuration for a database property. Source code in notional/schema.py class Number ( PropertyObject , type = \"number\" ): \"\"\"Defines the number configuration for a database property.\"\"\" class _NestedData ( NestedObject ): format : NumberFormat = NumberFormat . NUMBER number : _NestedData = _NestedData () @classmethod def __compose__ ( cls , format ): \"\"\"Create a `Number` object with the expected format.\"\"\" return cls ( number = cls . _NestedData ( format = format ))","title":"Number"},{"location":"reference/#notional.schema.Number.__compose__","text":"Create a Number object with the expected format. Source code in notional/schema.py @classmethod def __compose__ ( cls , format ): \"\"\"Create a `Number` object with the expected format.\"\"\" return cls ( number = cls . _NestedData ( format = format ))","title":"__compose__()"},{"location":"reference/#notional.schema.NumberFormat","text":"Available number formats in Notion. Source code in notional/schema.py class NumberFormat ( str , Enum ): \"\"\"Available number formats in Notion.\"\"\" NUMBER = \"number\" NUMBER_WITH_COMMAS = \"number_with_commas\" PERCENT = \"percent\" DOLLAR = \"dollar\" CANADIAN_DOLLAR = \"canadian_dollar\" EURO = \"euro\" POUND = \"pound\" YEN = \"yen\" RUBLE = \"ruble\" RUPEE = \"rupee\" WON = \"won\" YUAN = \"yuan\" REAL = \"real\" LIRA = \"lira\" RUPIAH = \"rupiah\" FRANC = \"franc\" HONG_KONG_DOLLAR = \"hong_kong_dollar\" NEW_ZEALAND_DOLLAR = \"new_zealand_dollar\" KRONA = \"krona\" NORWEGIAN_KRONE = \"norwegian_krone\" MEXICAN_PESO = \"mexican_peso\" RAND = \"rand\" NEW_TAIWAN_DOLLAR = \"new_taiwan_dollar\" DANISH_KRONE = \"danish_krone\" ZLOTY = \"zloty\" BAHT = \"baht\" FORINT = \"forint\" KORUNA = \"koruna\" SHEKEL = \"shekel\" CHILEAN_PESO = \"chilean_peso\" PHILIPPINE_PESO = \"philippine_peso\" DIRHAM = \"dirham\" COLOMBIAN_PESO = \"colombian_peso\" RIYAL = \"riyal\" RINGGIT = \"ringgit\" LEU = \"leu\"","title":"NumberFormat"},{"location":"reference/#notional.schema.People","text":"Defines the people configuration for a database property. Source code in notional/schema.py class People ( PropertyObject , type = \"people\" ): \"\"\"Defines the people configuration for a database property.\"\"\" people : Any = {}","title":"People"},{"location":"reference/#notional.schema.PhoneNumber","text":"Defines the phone number configuration for a database property. Source code in notional/schema.py class PhoneNumber ( PropertyObject , type = \"phone_number\" ): \"\"\"Defines the phone number configuration for a database property.\"\"\" phone_number : Any = {}","title":"PhoneNumber"},{"location":"reference/#notional.schema.PropertyObject","text":"Base class for Notion property objects. Source code in notional/schema.py class PropertyObject ( TypedObject ): \"\"\"Base class for Notion property objects.\"\"\" id : Optional [ str ] = None name : Optional [ str ] = None","title":"PropertyObject"},{"location":"reference/#notional.schema.Relation","text":"Defines the relation configuration for a database property. Source code in notional/schema.py class Relation ( PropertyObject , type = \"relation\" ): \"\"\"Defines the relation configuration for a database property.\"\"\" class _NestedData ( NestedObject ): database_id : UUID = None relation : _NestedData = _NestedData () @classmethod def __compose__ ( cls , database_id ): \"\"\"Create a `Relation` property using the target database ID.\"\"\" return cls ( relation = cls . _NestedData ( database_id = database_id ))","title":"Relation"},{"location":"reference/#notional.schema.Relation.__compose__","text":"Create a Relation property using the target database ID. Source code in notional/schema.py @classmethod def __compose__ ( cls , database_id ): \"\"\"Create a `Relation` property using the target database ID.\"\"\" return cls ( relation = cls . _NestedData ( database_id = database_id ))","title":"__compose__()"},{"location":"reference/#notional.schema.RichText","text":"Defines the rich text configuration for a database property. Source code in notional/schema.py class RichText ( PropertyObject , type = \"rich_text\" ): \"\"\"Defines the rich text configuration for a database property.\"\"\" rich_text : Any = {}","title":"RichText"},{"location":"reference/#notional.schema.Rollup","text":"Defines the rollup configuration for a database property. Source code in notional/schema.py class Rollup ( PropertyObject , type = \"rollup\" ): \"\"\"Defines the rollup configuration for a database property.\"\"\" class _NestedData ( NestedObject ): function : Function = Function . COUNT_ALL relation_property_name : Optional [ str ] = None relation_property_id : Optional [ str ] = None rollup_property_name : Optional [ str ] = None rollup_property_id : Optional [ str ] = None rollup : _NestedData = _NestedData ()","title":"Rollup"},{"location":"reference/#notional.schema.Select","text":"Defines the select configuration for a database property. Source code in notional/schema.py class Select ( PropertyObject , type = \"select\" ): \"\"\"Defines the select configuration for a database property.\"\"\" class _NestedData ( NestedObject ): options : List [ SelectOption ] = [] select : _NestedData = _NestedData () @classmethod def __compose__ ( cls , options ): \"\"\"Create a `Select` object from the list of `SelectOption`'s.\"\"\" return cls ( select = cls . _NestedData ( options = options ))","title":"Select"},{"location":"reference/#notional.schema.Select.__compose__","text":"Create a Select object from the list of SelectOption 's. Source code in notional/schema.py @classmethod def __compose__ ( cls , options ): \"\"\"Create a `Select` object from the list of `SelectOption`'s.\"\"\" return cls ( select = cls . _NestedData ( options = options ))","title":"__compose__()"},{"location":"reference/#notional.schema.SelectOption","text":"Options for select & multi-select objects. Source code in notional/schema.py class SelectOption ( DataObject ): \"\"\"Options for select & multi-select objects.\"\"\" name : str id : str = None color : str = Color . DEFAULT @classmethod def __compose__ ( cls , name , color = Color . DEFAULT ): \"\"\"Create a `SelectOption` object from the given name and color.\"\"\" return cls ( name = name , color = color )","title":"SelectOption"},{"location":"reference/#notional.schema.SelectOption.__compose__","text":"Create a SelectOption object from the given name and color. Source code in notional/schema.py @classmethod def __compose__ ( cls , name , color = Color . DEFAULT ): \"\"\"Create a `SelectOption` object from the given name and color.\"\"\" return cls ( name = name , color = color )","title":"__compose__()"},{"location":"reference/#notional.schema.Title","text":"Defines the title configuration for a database property. Source code in notional/schema.py class Title ( PropertyObject , type = \"title\" ): \"\"\"Defines the title configuration for a database property.\"\"\" title : Any = {}","title":"Title"},{"location":"reference/#notional.schema.URL","text":"Defines the URL configuration for a database property. Source code in notional/schema.py class URL ( PropertyObject , type = \"url\" ): \"\"\"Defines the URL configuration for a database property.\"\"\" url : Any = {}","title":"URL"},{"location":"reference/#notional.session","text":"Provides direct access to the Notion API.","title":"session"},{"location":"reference/#notional.session.BlocksEndpoint","text":"Notional interface to the API 'blocks' endpoint. Source code in notional/session.py class BlocksEndpoint ( Endpoint ): \"\"\"Notional interface to the API 'blocks' endpoint.\"\"\" class ChildrenEndpoint ( Endpoint ): \"\"\"Notional interface to the API 'blocks/children' endpoint.\"\"\" def __call__ ( self ): \"\"\"Return the underlying endpoint in the Notion SDK.\"\"\" return self . session . client . blocks . children # https://developers.notion.com/reference/patch-block-children def append ( self , parent , * blocks ): \"\"\"Add the given blocks as children of the specified parent. The blocks info will be refreshed based on returned data. \"\"\" parent_id = get_target_id ( parent ) children = [ block . to_api () for block in blocks if block is not None ] log . info ( \"Appending %d blocks to %s ...\" , len ( children ), parent_id ) data = self () . append ( block_id = parent_id , children = children ) if \"results\" in data : if len ( blocks ) == len ( data [ \"results\" ]): for idx in range ( len ( blocks )): block = blocks [ idx ] result = data [ \"results\" ][ idx ] block . refresh ( ** result ) else : log . warning ( \"Unable to refresh results; size mismatch\" ) else : log . warning ( \"Unable to refresh results; not provided\" ) return parent # https://developers.notion.com/reference/get-block-children def list ( self , parent ): \"\"\"Return all Blocks contained by the specified parent.\"\"\" parent_id = get_target_id ( parent ) blocks = EndpointIterator ( endpoint = self () . list , block_id = parent_id ) log . info ( \"Listing blocks for %s ...\" , parent_id ) return ResultSet ( exec = blocks , cls = Block ) def __init__ ( self , * args , ** kwargs ): \"\"\"Initialize the `blocks` endpoint for the Notion API.\"\"\" super () . __init__ ( * args , ** kwargs ) self . children = BlocksEndpoint . ChildrenEndpoint ( * args , ** kwargs ) def __call__ ( self ): \"\"\"Return the underlying endpoint in the Notion SDK.\"\"\" return self . session . client . blocks # https://developers.notion.com/reference/delete-a-block def delete ( self , block ): \"\"\"Delete (archive) the specified Block.\"\"\" log . info ( \"Deleting block :: %s \" , block . id ) data = self () . delete ( block . id . hex ) return block . refresh ( ** data ) def restore ( self , block ): \"\"\"Restore (unarchive) the specified Block.\"\"\" log . info ( \"Restoring block :: %s \" , block . id ) data = self () . update ( block . id . hex , archived = False ) return block . refresh ( ** data ) # https://developers.notion.com/reference/retrieve-a-block def retrieve ( self , block_id ): \"\"\"Return the Block with the given ID.\"\"\" log . info ( \"Retrieving block :: %s \" , block_id ) data = self () . retrieve ( block_id ) return Block . parse_obj ( data ) # https://developers.notion.com/reference/update-a-block def update ( self , block ): \"\"\"Update the block content on the server. The block info will be refreshed to the latest version from the server. \"\"\" log . info ( \"Updating block :: %s \" , block . id ) data = self () . update ( block . id . hex , ** block . to_api ()) return block . refresh ( ** data )","title":"BlocksEndpoint"},{"location":"reference/#notional.session.BlocksEndpoint.ChildrenEndpoint","text":"Notional interface to the API 'blocks/children' endpoint. Source code in notional/session.py class ChildrenEndpoint ( Endpoint ): \"\"\"Notional interface to the API 'blocks/children' endpoint.\"\"\" def __call__ ( self ): \"\"\"Return the underlying endpoint in the Notion SDK.\"\"\" return self . session . client . blocks . children # https://developers.notion.com/reference/patch-block-children def append ( self , parent , * blocks ): \"\"\"Add the given blocks as children of the specified parent. The blocks info will be refreshed based on returned data. \"\"\" parent_id = get_target_id ( parent ) children = [ block . to_api () for block in blocks if block is not None ] log . info ( \"Appending %d blocks to %s ...\" , len ( children ), parent_id ) data = self () . append ( block_id = parent_id , children = children ) if \"results\" in data : if len ( blocks ) == len ( data [ \"results\" ]): for idx in range ( len ( blocks )): block = blocks [ idx ] result = data [ \"results\" ][ idx ] block . refresh ( ** result ) else : log . warning ( \"Unable to refresh results; size mismatch\" ) else : log . warning ( \"Unable to refresh results; not provided\" ) return parent # https://developers.notion.com/reference/get-block-children def list ( self , parent ): \"\"\"Return all Blocks contained by the specified parent.\"\"\" parent_id = get_target_id ( parent ) blocks = EndpointIterator ( endpoint = self () . list , block_id = parent_id ) log . info ( \"Listing blocks for %s ...\" , parent_id ) return ResultSet ( exec = blocks , cls = Block )","title":"ChildrenEndpoint"},{"location":"reference/#notional.session.BlocksEndpoint.ChildrenEndpoint.__call__","text":"Return the underlying endpoint in the Notion SDK. Source code in notional/session.py def __call__ ( self ): \"\"\"Return the underlying endpoint in the Notion SDK.\"\"\" return self . session . client . blocks . children","title":"__call__()"},{"location":"reference/#notional.session.BlocksEndpoint.ChildrenEndpoint.append","text":"Add the given blocks as children of the specified parent. The blocks info will be refreshed based on returned data. Source code in notional/session.py def append ( self , parent , * blocks ): \"\"\"Add the given blocks as children of the specified parent. The blocks info will be refreshed based on returned data. \"\"\" parent_id = get_target_id ( parent ) children = [ block . to_api () for block in blocks if block is not None ] log . info ( \"Appending %d blocks to %s ...\" , len ( children ), parent_id ) data = self () . append ( block_id = parent_id , children = children ) if \"results\" in data : if len ( blocks ) == len ( data [ \"results\" ]): for idx in range ( len ( blocks )): block = blocks [ idx ] result = data [ \"results\" ][ idx ] block . refresh ( ** result ) else : log . warning ( \"Unable to refresh results; size mismatch\" ) else : log . warning ( \"Unable to refresh results; not provided\" ) return parent","title":"append()"},{"location":"reference/#notional.session.BlocksEndpoint.ChildrenEndpoint.list","text":"Return all Blocks contained by the specified parent. Source code in notional/session.py def list ( self , parent ): \"\"\"Return all Blocks contained by the specified parent.\"\"\" parent_id = get_target_id ( parent ) blocks = EndpointIterator ( endpoint = self () . list , block_id = parent_id ) log . info ( \"Listing blocks for %s ...\" , parent_id ) return ResultSet ( exec = blocks , cls = Block )","title":"list()"},{"location":"reference/#notional.session.BlocksEndpoint.__call__","text":"Return the underlying endpoint in the Notion SDK. Source code in notional/session.py def __call__ ( self ): \"\"\"Return the underlying endpoint in the Notion SDK.\"\"\" return self . session . client . blocks","title":"__call__()"},{"location":"reference/#notional.session.BlocksEndpoint.__init__","text":"Initialize the blocks endpoint for the Notion API. Source code in notional/session.py def __init__ ( self , * args , ** kwargs ): \"\"\"Initialize the `blocks` endpoint for the Notion API.\"\"\" super () . __init__ ( * args , ** kwargs ) self . children = BlocksEndpoint . ChildrenEndpoint ( * args , ** kwargs )","title":"__init__()"},{"location":"reference/#notional.session.BlocksEndpoint.delete","text":"Delete (archive) the specified Block. Source code in notional/session.py def delete ( self , block ): \"\"\"Delete (archive) the specified Block.\"\"\" log . info ( \"Deleting block :: %s \" , block . id ) data = self () . delete ( block . id . hex ) return block . refresh ( ** data )","title":"delete()"},{"location":"reference/#notional.session.BlocksEndpoint.restore","text":"Restore (unarchive) the specified Block. Source code in notional/session.py def restore ( self , block ): \"\"\"Restore (unarchive) the specified Block.\"\"\" log . info ( \"Restoring block :: %s \" , block . id ) data = self () . update ( block . id . hex , archived = False ) return block . refresh ( ** data )","title":"restore()"},{"location":"reference/#notional.session.BlocksEndpoint.retrieve","text":"Return the Block with the given ID. Source code in notional/session.py def retrieve ( self , block_id ): \"\"\"Return the Block with the given ID.\"\"\" log . info ( \"Retrieving block :: %s \" , block_id ) data = self () . retrieve ( block_id ) return Block . parse_obj ( data )","title":"retrieve()"},{"location":"reference/#notional.session.BlocksEndpoint.update","text":"Update the block content on the server. The block info will be refreshed to the latest version from the server. Source code in notional/session.py def update ( self , block ): \"\"\"Update the block content on the server. The block info will be refreshed to the latest version from the server. \"\"\" log . info ( \"Updating block :: %s \" , block . id ) data = self () . update ( block . id . hex , ** block . to_api ()) return block . refresh ( ** data )","title":"update()"},{"location":"reference/#notional.session.DatabasesEndpoint","text":"Notional interface to the API 'databases' endpoint. Source code in notional/session.py class DatabasesEndpoint ( Endpoint ): \"\"\"Notional interface to the API 'databases' endpoint.\"\"\" def __call__ ( self ): \"\"\"Return the underlying endpoint in the Notion SDK.\"\"\" return self . session . client . databases def _build_request ( self , parent = None , schema = None , title = None ): \"\"\"Build a request payload from the given items. *NOTE* this method does not anticipate what the request will be used for and as such does not validate the inputs for any particular requests. \"\"\" request = {} if parent is not None : ref = ParentRef [ parent ] request [ \"parent\" ] = ref . to_api () if isinstance ( title , TextObject ): request [ \"title\" ] = [ title . to_api ()] elif isinstance ( title , list ): request [ \"title\" ] = [ prop . to_api () for prop in title if prop is not None ] elif isinstance ( title , str ): prop = TextObject [ title ] request [ \"title\" ] = [ prop . to_api ()] elif title is not None : raise ValueError ( \"Unrecognized data in 'title'\" ) if schema is not None : request [ \"properties\" ] = { name : value . to_api () if value is not None else None for name , value in schema . items () } return request # https://developers.notion.com/reference/create-a-database def create ( self , parent , schema , title = None ): \"\"\"Add a database to the given Page parent.\"\"\" log . info ( \"Creating database %s - %s \" , parent , title ) request = self . _build_request ( parent , schema , title ) data = self () . create ( ** request ) return Database . parse_obj ( data ) # https://developers.notion.com/reference/get-databases def list ( self ): \"\"\"Return an iterator for all Database objects in the integration scope.\"\"\" # DEPRECATED ENDPOINT ### log . info ( \"Listing known databases...\" ) databases = EndpointIterator ( endpoint = self () . list ) return ResultSet ( exec = databases , cls = Database ) # https://developers.notion.com/reference/retrieve-a-database def retrieve ( self , database_id ): \"\"\"Return the Database with the given ID.\"\"\" log . info ( \"Retrieving database :: %s \" , database_id ) data = self () . retrieve ( database_id ) return Database . parse_obj ( data ) # https://developers.notion.com/reference/update-a-database def update ( self , database , title = None , schema = None ): \"\"\"Update the Database object on the server. The database info will be refreshed to the latest version from the server. \"\"\" dbid = get_target_id ( database ) log . info ( \"Updating database info :: \" , dbid ) request = self . _build_request ( schema = schema , title = title ) if request : data = self () . update ( dbid , ** request ) database = database . refresh ( ** data ) return database def delete ( self , database ): \"\"\"Delete (archive) the specified Database.\"\"\" log . info ( \"Deleting database :: %s \" , database . id ) return self . session . blocks . delete ( database ) def restore ( self , database ): \"\"\"Restore (unarchive) the specified Database.\"\"\" log . info ( \"Restoring database :: %s \" , database . id ) return self . session . blocks . restore ( database ) # https://developers.notion.com/reference/post-database-query def query ( self , target ): \"\"\"Initialize a new Query object with the target data class. :param target: either a string with the database ID or an ORM class \"\"\" log . info ( \"Initializing database query :: { %s }\" , get_target_id ( target )) database_id = get_target_id ( target ) cls = None if isclass ( target ) and issubclass ( target , ConnectedPage ): cls = target if cls . _notional__session != self . session : raise ValueError ( \"ConnectedPage belongs to a different session\" ) return QueryBuilder ( endpoint = self () . query , cls = cls , database_id = database_id )","title":"DatabasesEndpoint"},{"location":"reference/#notional.session.DatabasesEndpoint.__call__","text":"Return the underlying endpoint in the Notion SDK. Source code in notional/session.py def __call__ ( self ): \"\"\"Return the underlying endpoint in the Notion SDK.\"\"\" return self . session . client . databases","title":"__call__()"},{"location":"reference/#notional.session.DatabasesEndpoint.create","text":"Add a database to the given Page parent. Source code in notional/session.py def create ( self , parent , schema , title = None ): \"\"\"Add a database to the given Page parent.\"\"\" log . info ( \"Creating database %s - %s \" , parent , title ) request = self . _build_request ( parent , schema , title ) data = self () . create ( ** request ) return Database . parse_obj ( data )","title":"create()"},{"location":"reference/#notional.session.DatabasesEndpoint.delete","text":"Delete (archive) the specified Database. Source code in notional/session.py def delete ( self , database ): \"\"\"Delete (archive) the specified Database.\"\"\" log . info ( \"Deleting database :: %s \" , database . id ) return self . session . blocks . delete ( database )","title":"delete()"},{"location":"reference/#notional.session.DatabasesEndpoint.list","text":"Return an iterator for all Database objects in the integration scope. Source code in notional/session.py def list ( self ): \"\"\"Return an iterator for all Database objects in the integration scope.\"\"\" # DEPRECATED ENDPOINT ### log . info ( \"Listing known databases...\" ) databases = EndpointIterator ( endpoint = self () . list ) return ResultSet ( exec = databases , cls = Database )","title":"list()"},{"location":"reference/#notional.session.DatabasesEndpoint.query","text":"Initialize a new Query object with the target data class. :param target: either a string with the database ID or an ORM class Source code in notional/session.py def query ( self , target ): \"\"\"Initialize a new Query object with the target data class. :param target: either a string with the database ID or an ORM class \"\"\" log . info ( \"Initializing database query :: { %s }\" , get_target_id ( target )) database_id = get_target_id ( target ) cls = None if isclass ( target ) and issubclass ( target , ConnectedPage ): cls = target if cls . _notional__session != self . session : raise ValueError ( \"ConnectedPage belongs to a different session\" ) return QueryBuilder ( endpoint = self () . query , cls = cls , database_id = database_id )","title":"query()"},{"location":"reference/#notional.session.DatabasesEndpoint.restore","text":"Restore (unarchive) the specified Database. Source code in notional/session.py def restore ( self , database ): \"\"\"Restore (unarchive) the specified Database.\"\"\" log . info ( \"Restoring database :: %s \" , database . id ) return self . session . blocks . restore ( database )","title":"restore()"},{"location":"reference/#notional.session.DatabasesEndpoint.retrieve","text":"Return the Database with the given ID. Source code in notional/session.py def retrieve ( self , database_id ): \"\"\"Return the Database with the given ID.\"\"\" log . info ( \"Retrieving database :: %s \" , database_id ) data = self () . retrieve ( database_id ) return Database . parse_obj ( data )","title":"retrieve()"},{"location":"reference/#notional.session.DatabasesEndpoint.update","text":"Update the Database object on the server. The database info will be refreshed to the latest version from the server. Source code in notional/session.py def update ( self , database , title = None , schema = None ): \"\"\"Update the Database object on the server. The database info will be refreshed to the latest version from the server. \"\"\" dbid = get_target_id ( database ) log . info ( \"Updating database info :: \" , dbid ) request = self . _build_request ( schema = schema , title = title ) if request : data = self () . update ( dbid , ** request ) database = database . refresh ( ** data ) return database","title":"update()"},{"location":"reference/#notional.session.Endpoint","text":"Notional wrapper for the API endpoints. Source code in notional/session.py class Endpoint ( object ): \"\"\"Notional wrapper for the API endpoints.\"\"\" def __init__ ( self , session ): \"\"\"Initialize the `Endpoint` for the supplied session.\"\"\" self . session = session","title":"Endpoint"},{"location":"reference/#notional.session.Endpoint.__init__","text":"Initialize the Endpoint for the supplied session. Source code in notional/session.py def __init__ ( self , session ): \"\"\"Initialize the `Endpoint` for the supplied session.\"\"\" self . session = session","title":"__init__()"},{"location":"reference/#notional.session.PagesEndpoint","text":"Notional interface to the API 'pages' endpoint. Source code in notional/session.py class PagesEndpoint ( Endpoint ): \"\"\"Notional interface to the API 'pages' endpoint.\"\"\" def __call__ ( self ): \"\"\"Return the underlying endpoint in the Notion SDK.\"\"\" return self . session . client . pages # https://developers.notion.com/reference/post-page def create ( self , parent , title = None , properties = None , children = None ): \"\"\"Add a page to the given parent (Page or Database).\"\"\" if parent is None : raise ValueError ( \"'parent' must be provided\" ) parent = ParentRef [ parent ] request = { \"parent\" : parent . to_api ()} # the API requires a properties object, even if empty if properties is None : properties = {} if title is not None : properties [ \"title\" ] = Title [ title ] request [ \"properties\" ] = { name : prop . to_api () if prop is not None else None for name , prop in properties . items () } if children is not None : request [ \"children\" ] = [ child . to_api () for child in children if child is not None ] log . info ( \"Creating page :: %s => %s \" , parent , title ) data = self () . create ( ** request ) return Page . parse_obj ( data ) def delete ( self , page ): \"\"\"Delete (archive) the specified Page.\"\"\" return self . set ( page , archived = True ) def restore ( self , page ): \"\"\"Restore (unarchive) the specified Page.\"\"\" return self . set ( page , archived = False ) # https://developers.notion.com/reference/retrieve-a-page def retrieve ( self , page_id ): \"\"\"Return the Page with the given ID.\"\"\" log . info ( \"Retrieving page :: %s \" , page_id ) data = self () . retrieve ( page_id ) return Page . parse_obj ( data ) # https://developers.notion.com/reference/patch-page def update ( self , page , ** properties ): \"\"\"Update the Page object properties on the server. If `properties` are provided, only those values will be updated. If `properties` is empty, all page properties will be updated. `properties` are specified as `\"name\"`: `PropertyValue` pairs. The page info will be refreshed to the latest version from the server. \"\"\" log . info ( \"Updating page info :: %s \" , page . id ) if not properties : properties = page . properties props = { name : value . to_api () if value is not None else None for name , value in properties . items () } data = self () . update ( page . id . hex , properties = props ) return page . refresh ( ** data ) def set ( self , page , cover = False , icon = False , archived = None ): \"\"\"Set specific page attributes (such as cover, icon, etc) on the server. To remove an attribute, set its value to None. \"\"\" if cover is None : log . info ( \"Removing page cover :: %s \" , page . id ) data = self () . update ( page . id . hex , cover = {}) elif cover is not False : log . info ( \"Setting page cover :: %s => %s \" , page . id , cover ) data = self () . update ( page . id . hex , cover = cover . to_api ()) if icon is None : log . info ( \"Removing page icon :: %s \" , page . id ) data = self () . update ( page . id . hex , icon = {}) elif icon is not False : log . info ( \"Setting page icon :: %s => %s \" , page . id , icon ) data = self () . update ( page . id . hex , icon = icon . to_api ()) if archived is False : log . info ( \"Restoring page :: %s \" , page . id ) data = self () . update ( page . id . hex , archived = False ) elif archived is True : log . info ( \"Archiving page :: %s \" , page . id ) data = self () . update ( page . id . hex , archived = True ) return page . refresh ( ** data )","title":"PagesEndpoint"},{"location":"reference/#notional.session.PagesEndpoint.__call__","text":"Return the underlying endpoint in the Notion SDK. Source code in notional/session.py def __call__ ( self ): \"\"\"Return the underlying endpoint in the Notion SDK.\"\"\" return self . session . client . pages","title":"__call__()"},{"location":"reference/#notional.session.PagesEndpoint.create","text":"Add a page to the given parent (Page or Database). Source code in notional/session.py def create ( self , parent , title = None , properties = None , children = None ): \"\"\"Add a page to the given parent (Page or Database).\"\"\" if parent is None : raise ValueError ( \"'parent' must be provided\" ) parent = ParentRef [ parent ] request = { \"parent\" : parent . to_api ()} # the API requires a properties object, even if empty if properties is None : properties = {} if title is not None : properties [ \"title\" ] = Title [ title ] request [ \"properties\" ] = { name : prop . to_api () if prop is not None else None for name , prop in properties . items () } if children is not None : request [ \"children\" ] = [ child . to_api () for child in children if child is not None ] log . info ( \"Creating page :: %s => %s \" , parent , title ) data = self () . create ( ** request ) return Page . parse_obj ( data )","title":"create()"},{"location":"reference/#notional.session.PagesEndpoint.delete","text":"Delete (archive) the specified Page. Source code in notional/session.py def delete ( self , page ): \"\"\"Delete (archive) the specified Page.\"\"\" return self . set ( page , archived = True )","title":"delete()"},{"location":"reference/#notional.session.PagesEndpoint.restore","text":"Restore (unarchive) the specified Page. Source code in notional/session.py def restore ( self , page ): \"\"\"Restore (unarchive) the specified Page.\"\"\" return self . set ( page , archived = False )","title":"restore()"},{"location":"reference/#notional.session.PagesEndpoint.retrieve","text":"Return the Page with the given ID. Source code in notional/session.py def retrieve ( self , page_id ): \"\"\"Return the Page with the given ID.\"\"\" log . info ( \"Retrieving page :: %s \" , page_id ) data = self () . retrieve ( page_id ) return Page . parse_obj ( data )","title":"retrieve()"},{"location":"reference/#notional.session.PagesEndpoint.set","text":"Set specific page attributes (such as cover, icon, etc) on the server. To remove an attribute, set its value to None. Source code in notional/session.py def set ( self , page , cover = False , icon = False , archived = None ): \"\"\"Set specific page attributes (such as cover, icon, etc) on the server. To remove an attribute, set its value to None. \"\"\" if cover is None : log . info ( \"Removing page cover :: %s \" , page . id ) data = self () . update ( page . id . hex , cover = {}) elif cover is not False : log . info ( \"Setting page cover :: %s => %s \" , page . id , cover ) data = self () . update ( page . id . hex , cover = cover . to_api ()) if icon is None : log . info ( \"Removing page icon :: %s \" , page . id ) data = self () . update ( page . id . hex , icon = {}) elif icon is not False : log . info ( \"Setting page icon :: %s => %s \" , page . id , icon ) data = self () . update ( page . id . hex , icon = icon . to_api ()) if archived is False : log . info ( \"Restoring page :: %s \" , page . id ) data = self () . update ( page . id . hex , archived = False ) elif archived is True : log . info ( \"Archiving page :: %s \" , page . id ) data = self () . update ( page . id . hex , archived = True ) return page . refresh ( ** data )","title":"set()"},{"location":"reference/#notional.session.PagesEndpoint.update","text":"Update the Page object properties on the server. If properties are provided, only those values will be updated. If properties is empty, all page properties will be updated. properties are specified as \"name\" : PropertyValue pairs. The page info will be refreshed to the latest version from the server. Source code in notional/session.py def update ( self , page , ** properties ): \"\"\"Update the Page object properties on the server. If `properties` are provided, only those values will be updated. If `properties` is empty, all page properties will be updated. `properties` are specified as `\"name\"`: `PropertyValue` pairs. The page info will be refreshed to the latest version from the server. \"\"\" log . info ( \"Updating page info :: %s \" , page . id ) if not properties : properties = page . properties props = { name : value . to_api () if value is not None else None for name , value in properties . items () } data = self () . update ( page . id . hex , properties = props ) return page . refresh ( ** data )","title":"update()"},{"location":"reference/#notional.session.SearchEndpoint","text":"Notional interface to the API 'search' endpoint. Source code in notional/session.py class SearchEndpoint ( Endpoint ): \"\"\"Notional interface to the API 'search' endpoint.\"\"\" # https://developers.notion.com/reference/post-search def __call__ ( self , text = None ): \"\"\"Perform a search with the optional text. If specified, the call will perform a search with the given text. :return: a `QueryBuilder` with the requested search :rtype: query.QueryBuilder \"\"\" params = {} if text is not None : params [ \"query\" ] = text return QueryBuilder ( endpoint = self . session . client . search , ** params )","title":"SearchEndpoint"},{"location":"reference/#notional.session.SearchEndpoint.__call__","text":"Perform a search with the optional text. If specified, the call will perform a search with the given text. :return: a QueryBuilder with the requested search :rtype: query.QueryBuilder Source code in notional/session.py def __call__ ( self , text = None ): \"\"\"Perform a search with the optional text. If specified, the call will perform a search with the given text. :return: a `QueryBuilder` with the requested search :rtype: query.QueryBuilder \"\"\" params = {} if text is not None : params [ \"query\" ] = text return QueryBuilder ( endpoint = self . session . client . search , ** params )","title":"__call__()"},{"location":"reference/#notional.session.Session","text":"An active session with the Notion SDK. Source code in notional/session.py class Session ( object ): \"\"\"An active session with the Notion SDK.\"\"\" def __init__ ( self , ** kwargs ): \"\"\"Initialize the `Session` object and the endpoints. `kwargs` will be passed direction to the Notion SDK Client. For more details, see the (full docs)[https://ramnes.github.io/notion-sdk-py/reference/client/]. :param auth: bearer token for authentication \"\"\" self . client = notion_client . Client ( ** kwargs ) self . blocks = BlocksEndpoint ( self ) self . databases = DatabasesEndpoint ( self ) self . pages = PagesEndpoint ( self ) self . search = SearchEndpoint ( self ) self . users = UsersEndpoint ( self ) log . info ( \"Initialized Notion SDK client\" ) @property def IsActive ( self ): \"\"\"Determine if the current session is active. The session is considered \"active\" if it has not been closed. This does not determine if the session can connect to the Notion API. \"\"\" return self . client is not None def close ( self ): \"\"\"Close the session and release resources.\"\"\" if self . client is None : raise SessionError ( \"Session is not active.\" ) self . client . close () self . client = None def ping ( self ): \"\"\"Confirm that the session is active and able to connect to Notion. Raises SessionError if there is a problem, otherwise returns True. \"\"\" if self . IsActive is False : return False error = None try : me = self . users . me () if me is None : raise SessionError ( \"Unable to get current user\" ) except ConnectError : error = \"Unable to connect to Notion\" except APIResponseError as err : error = str ( err ) if error is not None : raise SessionError ( error ) return True","title":"Session"},{"location":"reference/#notional.session.Session.IsActive","text":"Determine if the current session is active. The session is considered \"active\" if it has not been closed. This does not determine if the session can connect to the Notion API.","title":"IsActive"},{"location":"reference/#notional.session.Session.__init__","text":"Initialize the Session object and the endpoints. kwargs will be passed direction to the Notion SDK Client. For more details, see the (full docs)[https://ramnes.github.io/notion-sdk-py/reference/client/]. :param auth: bearer token for authentication Source code in notional/session.py def __init__ ( self , ** kwargs ): \"\"\"Initialize the `Session` object and the endpoints. `kwargs` will be passed direction to the Notion SDK Client. For more details, see the (full docs)[https://ramnes.github.io/notion-sdk-py/reference/client/]. :param auth: bearer token for authentication \"\"\" self . client = notion_client . Client ( ** kwargs ) self . blocks = BlocksEndpoint ( self ) self . databases = DatabasesEndpoint ( self ) self . pages = PagesEndpoint ( self ) self . search = SearchEndpoint ( self ) self . users = UsersEndpoint ( self ) log . info ( \"Initialized Notion SDK client\" )","title":"__init__()"},{"location":"reference/#notional.session.Session.close","text":"Close the session and release resources. Source code in notional/session.py def close ( self ): \"\"\"Close the session and release resources.\"\"\" if self . client is None : raise SessionError ( \"Session is not active.\" ) self . client . close () self . client = None","title":"close()"},{"location":"reference/#notional.session.Session.ping","text":"Confirm that the session is active and able to connect to Notion. Raises SessionError if there is a problem, otherwise returns True. Source code in notional/session.py def ping ( self ): \"\"\"Confirm that the session is active and able to connect to Notion. Raises SessionError if there is a problem, otherwise returns True. \"\"\" if self . IsActive is False : return False error = None try : me = self . users . me () if me is None : raise SessionError ( \"Unable to get current user\" ) except ConnectError : error = \"Unable to connect to Notion\" except APIResponseError as err : error = str ( err ) if error is not None : raise SessionError ( error ) return True","title":"ping()"},{"location":"reference/#notional.session.SessionError","text":"Raised when there are issues with the Notion session. Source code in notional/session.py class SessionError ( Exception ): \"\"\"Raised when there are issues with the Notion session.\"\"\" def __init__ ( self , message ): \"\"\"Initialize the `SessionError` with a supplied message..\"\"\" super () . __init__ ( message )","title":"SessionError"},{"location":"reference/#notional.session.SessionError.__init__","text":"Initialize the SessionError with a supplied message.. Source code in notional/session.py def __init__ ( self , message ): \"\"\"Initialize the `SessionError` with a supplied message..\"\"\" super () . __init__ ( message )","title":"__init__()"},{"location":"reference/#notional.session.UsersEndpoint","text":"Notional interface to the API 'users' endpoint. Source code in notional/session.py class UsersEndpoint ( Endpoint ): \"\"\"Notional interface to the API 'users' endpoint.\"\"\" def __call__ ( self ): \"\"\"Return the underlying endpoint in the Notion SDK.\"\"\" return self . session . client . users # https://developers.notion.com/reference/get-users def list ( self ): \"\"\"Return an iterator for all users in the workspace.\"\"\" users = EndpointIterator ( endpoint = self () . list ) log . info ( \"Listing known users...\" ) return ResultSet ( exec = users , cls = User ) # https://developers.notion.com/reference/get-user def retrieve ( self , user_id ): \"\"\"Return the User with the given ID.\"\"\" log . info ( \"Retrieving user :: %s \" , user_id ) data = self () . retrieve ( user_id ) return User . parse_obj ( data ) # https://developers.notion.com/reference/get-self def me ( self ): \"\"\"Return the current bot User.\"\"\" log . info ( \"Retrieving current integration bot\" ) data = self () . me () return User . parse_obj ( data )","title":"UsersEndpoint"},{"location":"reference/#notional.session.UsersEndpoint.__call__","text":"Return the underlying endpoint in the Notion SDK. Source code in notional/session.py def __call__ ( self ): \"\"\"Return the underlying endpoint in the Notion SDK.\"\"\" return self . session . client . users","title":"__call__()"},{"location":"reference/#notional.session.UsersEndpoint.list","text":"Return an iterator for all users in the workspace. Source code in notional/session.py def list ( self ): \"\"\"Return an iterator for all users in the workspace.\"\"\" users = EndpointIterator ( endpoint = self () . list ) log . info ( \"Listing known users...\" ) return ResultSet ( exec = users , cls = User )","title":"list()"},{"location":"reference/#notional.session.UsersEndpoint.me","text":"Return the current bot User. Source code in notional/session.py def me ( self ): \"\"\"Return the current bot User.\"\"\" log . info ( \"Retrieving current integration bot\" ) data = self () . me () return User . parse_obj ( data )","title":"me()"},{"location":"reference/#notional.session.UsersEndpoint.retrieve","text":"Return the User with the given ID. Source code in notional/session.py def retrieve ( self , user_id ): \"\"\"Return the User with the given ID.\"\"\" log . info ( \"Retrieving user :: %s \" , user_id ) data = self () . retrieve ( user_id ) return User . parse_obj ( data )","title":"retrieve()"},{"location":"reference/#notional.text","text":"Utilities for working text, markdown & Rich Text in Notion.","title":"text"},{"location":"reference/#notional.text.Annotations","text":"Style information for RichTextObject's. Source code in notional/text.py class Annotations ( DataObject ): \"\"\"Style information for RichTextObject's.\"\"\" bold : bool = False italic : bool = False strikethrough : bool = False underline : bool = False code : bool = False color : FullColor = None @property def is_plain ( self ): \"\"\"Determine if any flags are set in this `Annotations` object. If all flags match their defaults, this is considered a \"plain\" style. \"\"\" # XXX a better approach here would be to just compate all fields to defaults if self . bold : return False if self . italic : return False if self . strikethrough : return False if self . underline : return False if self . code : return False if self . color is not None : return False return True","title":"Annotations"},{"location":"reference/#notional.text.Annotations.is_plain","text":"Determine if any flags are set in this Annotations object. If all flags match their defaults, this is considered a \"plain\" style.","title":"is_plain"},{"location":"reference/#notional.text.CodingLanguage","text":"Available coding languages. Source code in notional/text.py class CodingLanguage ( str , Enum ): \"\"\"Available coding languages.\"\"\" ABAP = \"abap\" ARDUION = \"arduino\" BASH = \"bash\" BASIC = \"basic\" C = \"c\" CLOJURE = \"clojure\" COFFEESCRIPT = \"coffeescript\" CPP = \"c++\" CSHARP = \"c#\" CSS = \"css\" DART = \"dart\" DIFF = \"diff\" DOCKER = \"docker\" ELIXIR = \"elixir\" ELM = \"elm\" ERLANG = \"erlang\" FLOW = \"flow\" FORTRAN = \"fortran\" FSHARP = \"f#\" GHERKIN = \"gherkin\" GLSL = \"glsl\" GO = \"go\" GRAPHQL = \"graphql\" GROOVY = \"groovy\" HASKELL = \"haskell\" HTML = \"html\" JAVA = \"java\" JAVASCRIPT = \"javascript\" JSON = \"json\" JULIA = \"julia\" KOTLIN = \"kotlin\" LATEX = \"latex\" LESS = \"less\" LISP = \"lisp\" LIVESCRIPT = \"livescript\" LUA = \"lua\" MAKEFILE = \"makefile\" MARKDOWN = \"markdown\" MARKUP = \"markup\" MATLAB = \"matlab\" MERMAID = \"mermaid\" NIX = \"nix\" OBJECTIVE_C = \"objective-c\" OCAML = \"ocaml\" PASCAL = \"pascal\" PERL = \"perl\" PHP = \"php\" PLAIN_TEXT = \"plain text\" POWERSHELL = \"powershell\" PROLOG = \"prolog\" PROTOBUF = \"protobuf\" PYTHON = \"python\" R = \"r\" REASON = \"reason\" RUBY = \"ruby\" RUST = \"rust\" SASS = \"sass\" SCALA = \"scala\" SCHEME = \"scheme\" SCSS = \"scss\" SHELL = \"shell\" SQL = \"sql\" SWIFT = \"swift\" TYPESCRIPT = \"typescript\" VB_NET = \"vb.net\" VERILOG = \"verilog\" VHDL = \"vhdl\" VISUAL_BASIC = \"visual basic\" WEBASSEMBLY = \"webassembly\" XML = \"xml\" YAML = \"yaml\" MISC = \"java/c/c++/c#\"","title":"CodingLanguage"},{"location":"reference/#notional.text.Color","text":"Basic color values. Source code in notional/text.py class Color ( str , Enum ): \"\"\"Basic color values.\"\"\" DEFAULT = \"default\" GRAY = \"gray\" BROWN = \"brown\" ORANGE = \"orange\" YELLOW = \"yellow\" GREEN = \"green\" BLUE = \"blue\" PURPLE = \"purple\" PINK = \"pink\" RED = \"red\"","title":"Color"},{"location":"reference/#notional.text.FullColor","text":"Extended color values, including backgounds. Source code in notional/text.py class FullColor ( str , Enum ): \"\"\"Extended color values, including backgounds.\"\"\" DEFAULT = \"default\" GRAY = \"gray\" BROWN = \"brown\" ORANGE = \"orange\" YELLOW = \"yellow\" GREEN = \"green\" BLUE = \"blue\" PURPLE = \"purple\" PINK = \"pink\" RED = \"red\" GRAY_BACKGROUND = \"gray_background\" BROWN_BACKGROUND = \"brown_background\" ORANGE_BACKGROUND = \"orange_background\" YELLOW_BACKGROUND = \"yellow_background\" GREEN_BACKGROUND = \"green_background\" BLUE_BACKGROUND = \"blue_background\" PURPLE_BACKGROUND = \"purple_background\" PINK_BACKGROUND = \"pink_background\" RED_BACKGROUND = \"red_background\"","title":"FullColor"},{"location":"reference/#notional.text.LinkObject","text":"Reference a URL. Source code in notional/text.py class LinkObject ( DataObject ): \"\"\"Reference a URL.\"\"\" type : str = \"url\" url : str = None","title":"LinkObject"},{"location":"reference/#notional.text.RichTextObject","text":"Base class for Notion rich text elements. Source code in notional/text.py class RichTextObject ( TypedObject ): \"\"\"Base class for Notion rich text elements.\"\"\" plain_text : str href : Optional [ str ] = None annotations : Optional [ Annotations ] = None def __str__ ( self ): \"\"\"Return a string representation of this object.\"\"\" if self . href is None : text = self . plain_text or \"\" elif self . plain_text is None or len ( self . plain_text ) == 0 : text = f \"( { self . href } )\" else : text = f \"[ { self . plain_text } ]( { self . href } )\" if self . annotations : if self . annotations . bold : text = f \"* { text } *\" if self . annotations . italic : text = f \"** { text } **\" if self . annotations . underline : text = f \"_ { text } _\" if self . annotations . strikethrough : text = f \"~ { text } ~\" if self . annotations . code : text = f \"` { text } `\" return text","title":"RichTextObject"},{"location":"reference/#notional.text.RichTextObject.__str__","text":"Return a string representation of this object. Source code in notional/text.py def __str__ ( self ): \"\"\"Return a string representation of this object.\"\"\" if self . href is None : text = self . plain_text or \"\" elif self . plain_text is None or len ( self . plain_text ) == 0 : text = f \"( { self . href } )\" else : text = f \"[ { self . plain_text } ]( { self . href } )\" if self . annotations : if self . annotations . bold : text = f \"* { text } *\" if self . annotations . italic : text = f \"** { text } **\" if self . annotations . underline : text = f \"_ { text } _\" if self . annotations . strikethrough : text = f \"~ { text } ~\" if self . annotations . code : text = f \"` { text } `\" return text","title":"__str__()"},{"location":"reference/#notional.text.TextObject","text":"Notion text element. Source code in notional/text.py class TextObject ( RichTextObject , type = \"text\" ): \"\"\"Notion text element.\"\"\" class _NestedData ( NestedObject ): content : str = None link : Optional [ LinkObject ] = None text : _NestedData = _NestedData () @classmethod def __compose__ ( cls , text , href = None , style = None ): \"\"\"Compose a TextObject from the given properties. :param text: the plain text of this object :param href: an optional link for this object :param style: an optional Annotations object for this text \"\"\" if text is None : return None # TODO convert markdown in text:str to RichText? link = LinkObject ( url = href ) if href else None nested = TextObject . _NestedData ( content = text , link = link ) style = deepcopy ( style ) return TextObject ( plain_text = text , text = nested , href = href , annotations = style , )","title":"TextObject"},{"location":"reference/#notional.text.TextObject.__compose__","text":"Compose a TextObject from the given properties. :param text: the plain text of this object :param href: an optional link for this object :param style: an optional Annotations object for this text Source code in notional/text.py @classmethod def __compose__ ( cls , text , href = None , style = None ): \"\"\"Compose a TextObject from the given properties. :param text: the plain text of this object :param href: an optional link for this object :param style: an optional Annotations object for this text \"\"\" if text is None : return None # TODO convert markdown in text:str to RichText? link = LinkObject ( url = href ) if href else None nested = TextObject . _NestedData ( content = text , link = link ) style = deepcopy ( style ) return TextObject ( plain_text = text , text = nested , href = href , annotations = style , )","title":"__compose__()"},{"location":"reference/#notional.text.chunky","text":"Break the given text into chunks of at most length size. Source code in notional/text.py def chunky ( text , length = MAX_TEXT_OBJECT_SIZE ): \"\"\"Break the given `text` into chunks of at most `length` size.\"\"\" return ( text [ idx : idx + length ] for idx in range ( 0 , len ( text ), length ))","title":"chunky()"},{"location":"reference/#notional.text.lstrip","text":"Remove leading whitespace from each TextObject in the list. Source code in notional/text.py def lstrip ( * rtf ): \"\"\"Remove leading whitespace from each `TextObject` in the list.\"\"\" if rtf is None or len ( rtf ) < 1 : return for obj in rtf : if not isinstance ( obj , TextObject ): raise AttributeError ( \"invalid object in rtf\" ) if obj . text and obj . text . content : strip_text = obj . text . content . lstrip () obj . text . content = strip_text obj . plain_text = strip_text","title":"lstrip()"},{"location":"reference/#notional.text.make_safe_python_name","text":"Make the given string safe for use as a Python identifier. This will remove any leading characters that are not valid and change all invalid interior sequences to underscore. Source code in notional/text.py def make_safe_python_name ( name ): \"\"\"Make the given string safe for use as a Python identifier. This will remove any leading characters that are not valid and change all invalid interior sequences to underscore. \"\"\" s = re . sub ( r \"[^0-9a-zA-Z_]+\" , \"_\" , name ) s = re . sub ( r \"^[^a-zA-Z]+\" , \"\" , s ) # remove trailing underscores return s . rstrip ( \"_\" )","title":"make_safe_python_name()"},{"location":"reference/#notional.text.markdown","text":"Return text as markdown from the list of RichText objects. Source code in notional/text.py def markdown ( * rtf ): \"\"\"Return text as markdown from the list of RichText objects.\"\"\" return \"\" . join ( str ( text ) for text in rtf if text )","title":"markdown()"},{"location":"reference/#notional.text.plain_text","text":"Return the combined plain text from the list of RichText objects. Source code in notional/text.py def plain_text ( * rtf ): \"\"\"Return the combined plain text from the list of RichText objects.\"\"\" return \"\" . join ( text . plain_text for text in rtf if text )","title":"plain_text()"},{"location":"reference/#notional.text.rstrip","text":"Remove trailing whitespace from each TextObject in the list. Source code in notional/text.py def rstrip ( * rtf ): \"\"\"Remove trailing whitespace from each `TextObject` in the list.\"\"\" if rtf is None or len ( rtf ) < 1 : return for obj in rtf : if not isinstance ( obj , TextObject ): raise AttributeError ( \"invalid object in rtf\" ) if obj . text and obj . text . content : strip_text = obj . text . content . rstrip () obj . text . content = strip_text obj . plain_text = strip_text","title":"rstrip()"},{"location":"reference/#notional.text.strip","text":"Remove leading and trailing whitespace from each TextObject in the list. This is functionally equivalent to: lstrip ( * rtf ) rstrip ( * rtf ) :param rtf: a list of TextObject 's Source code in notional/text.py def strip ( * rtf ): \"\"\"Remove leading and trailing whitespace from each `TextObject` in the list. This is functionally equivalent to: ```python lstrip(*rtf) rstrip(*rtf) ``` :param rtf: a list of `TextObject`'s \"\"\" lstrip ( * rtf ) rstrip ( * rtf )","title":"strip()"},{"location":"reference/#notional.text.truncate","text":"Truncate the given text, using a supplied tail as a placeholder. Source code in notional/text.py def truncate ( text , length =- 1 , trail = \"...\" ): \"\"\"Truncate the given text, using a supplied tail as a placeholder.\"\"\" if text is None : return None # repr() includes open and close quotes... literal = repr ( text )[ 1 : - 1 ] if 0 < length < len ( literal ): literal = literal [: length ] if trail is not None : literal += trail return literal","title":"truncate()"},{"location":"reference/#notional.types","text":"Wrapper for Notion API data types. Similar to other records, these object provide access to the primitive data structure used in the Notion API as well as higher-level methods.","title":"types"},{"location":"reference/#notional.types.Checkbox","text":"Simple checkbox type; represented as a boolean. Source code in notional/types.py class Checkbox ( NativeTypeMixin , PropertyValue , type = \"checkbox\" ): \"\"\"Simple checkbox type; represented as a boolean.\"\"\" checkbox : Optional [ bool ] = None","title":"Checkbox"},{"location":"reference/#notional.types.CreatedBy","text":"A Notion created-by property value. Source code in notional/types.py class CreatedBy ( PropertyValue , type = \"created_by\" ): \"\"\"A Notion created-by property value.\"\"\" created_by : User def __str__ ( self ): \"\"\"Return the contents of this property as a string.\"\"\" return str ( self . created_by )","title":"CreatedBy"},{"location":"reference/#notional.types.CreatedBy.__str__","text":"Return the contents of this property as a string. Source code in notional/types.py def __str__ ( self ): \"\"\"Return the contents of this property as a string.\"\"\" return str ( self . created_by )","title":"__str__()"},{"location":"reference/#notional.types.CreatedTime","text":"A Notion created-time property value. Source code in notional/types.py class CreatedTime ( NativeTypeMixin , PropertyValue , type = \"created_time\" ): \"\"\"A Notion created-time property value.\"\"\" created_time : datetime","title":"CreatedTime"},{"location":"reference/#notional.types.Date","text":"Notion complex date type - may include timestamp and/or be a date range. Source code in notional/types.py class Date ( PropertyValue , type = \"date\" ): \"\"\"Notion complex date type - may include timestamp and/or be a date range.\"\"\" date : Optional [ DateRange ] = None def __contains__ ( self , other ): \"\"\"Determine if the given date is in the range (inclusive) of this Date. Raises ValueError if the Date object is not a range - e.g. has no end date. \"\"\" if not self . IsRange : raise ValueError ( \"This date is not a range\" ) return self . Start <= other <= self . End def __str__ ( self ): \"\"\"Return a string representation of this property.\"\"\" return \"\" if self . date is None else str ( self . date ) @classmethod def __compose__ ( cls , start , end = None ): \"\"\"Create a new Date from the native values.\"\"\" return cls ( date = DateRange ( start = start , end = end )) @property def IsRange ( self ): \"\"\"Determine if this object represents a date range (versus a single date).\"\"\" if self . date is None : return False return self . date . end is not None @property def Start ( self ): \"\"\"Return the start date of this property.\"\"\" return None if self . date is None else self . date . start @property def End ( self ): \"\"\"Return the end date of this property.\"\"\" return None if self . date is None else self . date . end","title":"Date"},{"location":"reference/#notional.types.Date.End","text":"Return the end date of this property.","title":"End"},{"location":"reference/#notional.types.Date.IsRange","text":"Determine if this object represents a date range (versus a single date).","title":"IsRange"},{"location":"reference/#notional.types.Date.Start","text":"Return the start date of this property.","title":"Start"},{"location":"reference/#notional.types.Date.__compose__","text":"Create a new Date from the native values. Source code in notional/types.py @classmethod def __compose__ ( cls , start , end = None ): \"\"\"Create a new Date from the native values.\"\"\" return cls ( date = DateRange ( start = start , end = end ))","title":"__compose__()"},{"location":"reference/#notional.types.Date.__contains__","text":"Determine if the given date is in the range (inclusive) of this Date. Raises ValueError if the Date object is not a range - e.g. has no end date. Source code in notional/types.py def __contains__ ( self , other ): \"\"\"Determine if the given date is in the range (inclusive) of this Date. Raises ValueError if the Date object is not a range - e.g. has no end date. \"\"\" if not self . IsRange : raise ValueError ( \"This date is not a range\" ) return self . Start <= other <= self . End","title":"__contains__()"},{"location":"reference/#notional.types.Date.__str__","text":"Return a string representation of this property. Source code in notional/types.py def __str__ ( self ): \"\"\"Return a string representation of this property.\"\"\" return \"\" if self . date is None else str ( self . date )","title":"__str__()"},{"location":"reference/#notional.types.DateFormula","text":"A Notion date formula result. Source code in notional/types.py class DateFormula ( FormulaResult , type = \"date\" ): \"\"\"A Notion date formula result.\"\"\" date : Optional [ DateRange ] = None @property def Result ( self ): \"\"\"Return the result of this DateFormula.\"\"\" return self . date","title":"DateFormula"},{"location":"reference/#notional.types.DateFormula.Result","text":"Return the result of this DateFormula.","title":"Result"},{"location":"reference/#notional.types.DateRange","text":"A Notion date range, with an optional end date. Source code in notional/types.py class DateRange ( DataObject ): \"\"\"A Notion date range, with an optional end date.\"\"\" start : Union [ date , datetime ] end : Optional [ Union [ date , datetime ]] = None def __str__ ( self ): \"\"\"Return a string representation of this object.\"\"\" if self . end is None : return f \" { self . start } \" return f \" { self . start } :: { self . end } \"","title":"DateRange"},{"location":"reference/#notional.types.DateRange.__str__","text":"Return a string representation of this object. Source code in notional/types.py def __str__ ( self ): \"\"\"Return a string representation of this object.\"\"\" if self . end is None : return f \" { self . start } \" return f \" { self . start } :: { self . end } \"","title":"__str__()"},{"location":"reference/#notional.types.Email","text":"Notion email type. Source code in notional/types.py class Email ( NativeTypeMixin , PropertyValue , type = \"email\" ): \"\"\"Notion email type.\"\"\" email : Optional [ str ] = None","title":"Email"},{"location":"reference/#notional.types.EmojiObject","text":"A Notion emoji object. Source code in notional/types.py class EmojiObject ( TypedObject , type = \"emoji\" ): \"\"\"A Notion emoji object.\"\"\" emoji : str def __str__ ( self ): \"\"\"Return this EmojiObject as a simple string.\"\"\" return self . emoji @classmethod def __compose__ ( cls , emoji ): \"\"\"Compose an EmojiObject from the given emjoi string.\"\"\" return EmojiObject ( emoji = emoji )","title":"EmojiObject"},{"location":"reference/#notional.types.EmojiObject.__compose__","text":"Compose an EmojiObject from the given emjoi string. Source code in notional/types.py @classmethod def __compose__ ( cls , emoji ): \"\"\"Compose an EmojiObject from the given emjoi string.\"\"\" return EmojiObject ( emoji = emoji )","title":"__compose__()"},{"location":"reference/#notional.types.EmojiObject.__str__","text":"Return this EmojiObject as a simple string. Source code in notional/types.py def __str__ ( self ): \"\"\"Return this EmojiObject as a simple string.\"\"\" return self . emoji","title":"__str__()"},{"location":"reference/#notional.types.EquationObject","text":"Notion equation element. Source code in notional/types.py class EquationObject ( RichTextObject , type = \"equation\" ): \"\"\"Notion equation element.\"\"\" class _NestedData ( NestedObject ): expression : str equation : _NestedData def __str__ ( self ): \"\"\"Return a string representation of this object.\"\"\" if self . equation is None : return None return self . equation . expression","title":"EquationObject"},{"location":"reference/#notional.types.ExternalFile","text":"An external file object. Source code in notional/types.py class ExternalFile ( FileObject , type = \"external\" ): \"\"\"An external file object.\"\"\" class _NestedData ( NestedObject ): url : str external : _NestedData def __str__ ( self ): \"\"\"Return a string representation of this object.\"\"\" name = self . name or \"__unknown__\" if self . external and self . external . url : return f \"![ { name } ]( { self . external . url } )\" return name @classmethod def __compose__ ( cls , url , name = None ): \"\"\"Create a new `ExternalFile` from the given URL.\"\"\" return cls ( name = name , external = cls . _NestedData ( url = url ))","title":"ExternalFile"},{"location":"reference/#notional.types.ExternalFile.__compose__","text":"Create a new ExternalFile from the given URL. Source code in notional/types.py @classmethod def __compose__ ( cls , url , name = None ): \"\"\"Create a new `ExternalFile` from the given URL.\"\"\" return cls ( name = name , external = cls . _NestedData ( url = url ))","title":"__compose__()"},{"location":"reference/#notional.types.FileObject","text":"A Notion file object. Depending on the context, a FileObject may require a name (such as in the Files property). This makes the object heirarchy difficult, so here we simply allow name to be optional. It is the responsibility of the caller to set name if required by the API. Source code in notional/types.py class FileObject ( TypedObject ): \"\"\"A Notion file object. Depending on the context, a FileObject may require a name (such as in the `Files` property). This makes the object heirarchy difficult, so here we simply allow `name` to be optional. It is the responsibility of the caller to set `name` if required by the API. \"\"\" name : Optional [ str ] = None def __str__ ( self ): \"\"\"Return a string representation of this object.\"\"\" return self . name or \"__unknown__\"","title":"FileObject"},{"location":"reference/#notional.types.FileObject.__str__","text":"Return a string representation of this object. Source code in notional/types.py def __str__ ( self ): \"\"\"Return a string representation of this object.\"\"\" return self . name or \"__unknown__\"","title":"__str__()"},{"location":"reference/#notional.types.Files","text":"Notion files type. Source code in notional/types.py class Files ( PropertyValue , type = \"files\" ): \"\"\"Notion files type.\"\"\" files : List [ FileObject ] = [] def __contains__ ( self , other ): \"\"\"Determine if the given FileObject or name is in the property.\"\"\" if self . files is None : return False for ref in self . files : if ref == other : return True if ref . name == other : return True return False def __str__ ( self ): \"\"\"Return a string representation of this property.\"\"\" return \"; \" . join ([ str ( file ) for file in self . files ]) def __iter__ ( self ): \"\"\"Iterate over the FileObject's in this property.\"\"\" if self . files is None : return None return iter ( self . files ) def __len__ ( self ): \"\"\"Return the number of Files in this property.\"\"\" return len ( self . files ) def __getitem__ ( self , name ): \"\"\"Return the FileObject with the given name.\"\"\" if self . files is None : return None for ref in self . files : if ref . name == name : return ref raise AttributeError ( \"No such file\" ) def __iadd__ ( self , obj ): \"\"\"Append the given `FileObject` in place.\"\"\" if obj in self : raise ValueError ( f \"Item exists: { obj } \" ) self . append ( obj ) return self def __isub__ ( self , obj ): \"\"\"Remove the given `FileObject` in place.\"\"\" if obj not in self : raise ValueError ( f \"No such item: { obj } \" ) self . remove ( obj ) return self def append ( self , obj ): \"\"\"Append the given file reference to this property. :param ref: the `FileObject` to be added \"\"\" log . debug ( \"append file - %s \" , obj ) self . files . append ( obj ) def remove ( self , obj ): \"\"\"Remove the given file reference from this property. :param ref: the `FileObject` to be removed \"\"\" log . debug ( \"remove file - %s \" , obj ) self . files . remove ( obj )","title":"Files"},{"location":"reference/#notional.types.Files.__contains__","text":"Determine if the given FileObject or name is in the property. Source code in notional/types.py def __contains__ ( self , other ): \"\"\"Determine if the given FileObject or name is in the property.\"\"\" if self . files is None : return False for ref in self . files : if ref == other : return True if ref . name == other : return True return False","title":"__contains__()"},{"location":"reference/#notional.types.Files.__getitem__","text":"Return the FileObject with the given name. Source code in notional/types.py def __getitem__ ( self , name ): \"\"\"Return the FileObject with the given name.\"\"\" if self . files is None : return None for ref in self . files : if ref . name == name : return ref raise AttributeError ( \"No such file\" )","title":"__getitem__()"},{"location":"reference/#notional.types.Files.__iadd__","text":"Append the given FileObject in place. Source code in notional/types.py def __iadd__ ( self , obj ): \"\"\"Append the given `FileObject` in place.\"\"\" if obj in self : raise ValueError ( f \"Item exists: { obj } \" ) self . append ( obj ) return self","title":"__iadd__()"},{"location":"reference/#notional.types.Files.__isub__","text":"Remove the given FileObject in place. Source code in notional/types.py def __isub__ ( self , obj ): \"\"\"Remove the given `FileObject` in place.\"\"\" if obj not in self : raise ValueError ( f \"No such item: { obj } \" ) self . remove ( obj ) return self","title":"__isub__()"},{"location":"reference/#notional.types.Files.__iter__","text":"Iterate over the FileObject's in this property. Source code in notional/types.py def __iter__ ( self ): \"\"\"Iterate over the FileObject's in this property.\"\"\" if self . files is None : return None return iter ( self . files )","title":"__iter__()"},{"location":"reference/#notional.types.Files.__len__","text":"Return the number of Files in this property. Source code in notional/types.py def __len__ ( self ): \"\"\"Return the number of Files in this property.\"\"\" return len ( self . files )","title":"__len__()"},{"location":"reference/#notional.types.Files.__str__","text":"Return a string representation of this property. Source code in notional/types.py def __str__ ( self ): \"\"\"Return a string representation of this property.\"\"\" return \"; \" . join ([ str ( file ) for file in self . files ])","title":"__str__()"},{"location":"reference/#notional.types.Files.append","text":"Append the given file reference to this property. :param ref: the FileObject to be added Source code in notional/types.py def append ( self , obj ): \"\"\"Append the given file reference to this property. :param ref: the `FileObject` to be added \"\"\" log . debug ( \"append file - %s \" , obj ) self . files . append ( obj )","title":"append()"},{"location":"reference/#notional.types.Files.remove","text":"Remove the given file reference from this property. :param ref: the FileObject to be removed Source code in notional/types.py def remove ( self , obj ): \"\"\"Remove the given file reference from this property. :param ref: the `FileObject` to be removed \"\"\" log . debug ( \"remove file - %s \" , obj ) self . files . remove ( obj )","title":"remove()"},{"location":"reference/#notional.types.Formula","text":"A Notion formula property value. Source code in notional/types.py class Formula ( PropertyValue , type = \"formula\" ): \"\"\"A Notion formula property value.\"\"\" formula : Optional [ FormulaResult ] = None def __str__ ( self ): \"\"\"Return the result of this formula as a string.\"\"\" return str ( self . Result or \"\" ) @property def Result ( self ): \"\"\"Return the result of this Formula in its native type.\"\"\" if self . formula is None : return None return self . formula . Result","title":"Formula"},{"location":"reference/#notional.types.Formula.Result","text":"Return the result of this Formula in its native type.","title":"Result"},{"location":"reference/#notional.types.Formula.__str__","text":"Return the result of this formula as a string. Source code in notional/types.py def __str__ ( self ): \"\"\"Return the result of this formula as a string.\"\"\" return str ( self . Result or \"\" )","title":"__str__()"},{"location":"reference/#notional.types.FormulaResult","text":"A Notion formula result. This object contains the result of the expression in the database properties. Source code in notional/types.py class FormulaResult ( TypedObject ): \"\"\"A Notion formula result. This object contains the result of the expression in the database properties. \"\"\" def __str__ ( self ): \"\"\"Return the formula result as a string.\"\"\" return self . Result or \"\" @property def Result ( self ): \"\"\"Return the result of this FormulaResult.\"\"\" raise NotImplementedError ( \"Result unavailable\" )","title":"FormulaResult"},{"location":"reference/#notional.types.FormulaResult.Result","text":"Return the result of this FormulaResult.","title":"Result"},{"location":"reference/#notional.types.FormulaResult.__str__","text":"Return the formula result as a string. Source code in notional/types.py def __str__ ( self ): \"\"\"Return the formula result as a string.\"\"\" return self . Result or \"\"","title":"__str__()"},{"location":"reference/#notional.types.HostedFile","text":"A Notion file object. Source code in notional/types.py class HostedFile ( FileObject , type = \"file\" ): \"\"\"A Notion file object.\"\"\" class _NestedData ( NestedObject ): url : str expiry_time : Optional [ datetime ] = None file : _NestedData","title":"HostedFile"},{"location":"reference/#notional.types.LastEditedBy","text":"A Notion last-edited-by property value. Source code in notional/types.py class LastEditedBy ( PropertyValue , type = \"last_edited_by\" ): \"\"\"A Notion last-edited-by property value.\"\"\" last_edited_by : User def __str__ ( self ): \"\"\"Return the contents of this property as a string.\"\"\" return str ( self . last_edited_by )","title":"LastEditedBy"},{"location":"reference/#notional.types.LastEditedBy.__str__","text":"Return the contents of this property as a string. Source code in notional/types.py def __str__ ( self ): \"\"\"Return the contents of this property as a string.\"\"\" return str ( self . last_edited_by )","title":"__str__()"},{"location":"reference/#notional.types.LastEditedTime","text":"A Notion last-edited-time property value. Source code in notional/types.py class LastEditedTime ( NativeTypeMixin , PropertyValue , type = \"last_edited_time\" ): \"\"\"A Notion last-edited-time property value.\"\"\" last_edited_time : datetime","title":"LastEditedTime"},{"location":"reference/#notional.types.MentionData","text":"Base class for typed Mention data objects. Source code in notional/types.py class MentionData ( TypedObject ): \"\"\"Base class for typed `Mention` data objects.\"\"\"","title":"MentionData"},{"location":"reference/#notional.types.MentionDatabase","text":"Nested database information for Mention properties. Source code in notional/types.py class MentionDatabase ( MentionData , type = \"database\" ): \"\"\"Nested database information for `Mention` properties.\"\"\" database : PageReference","title":"MentionDatabase"},{"location":"reference/#notional.types.MentionDate","text":"Nested date data for Mention properties. Source code in notional/types.py class MentionDate ( MentionData , type = \"date\" ): \"\"\"Nested date data for `Mention` properties.\"\"\" date : DateRange","title":"MentionDate"},{"location":"reference/#notional.types.MentionLink","text":"Nested url data for Mention properties. Source code in notional/types.py class MentionLink ( MentionData , type = \"link_preview\" ): \"\"\"Nested url data for `Mention` properties.\"\"\" url : str","title":"MentionLink"},{"location":"reference/#notional.types.MentionObject","text":"Notion mention element. Source code in notional/types.py class MentionObject ( RichTextObject , type = \"mention\" ): \"\"\"Notion mention element.\"\"\" mention : MentionData","title":"MentionObject"},{"location":"reference/#notional.types.MentionPage","text":"Nested page data for Mention properties. Source code in notional/types.py class MentionPage ( MentionData , type = \"page\" ): \"\"\"Nested page data for `Mention` properties.\"\"\" page : PageReference","title":"MentionPage"},{"location":"reference/#notional.types.MentionTemplate","text":"Nested template data for Mention properties. Source code in notional/types.py class MentionTemplate ( MentionData , type = \"template_mention\" ): \"\"\"Nested template data for `Mention` properties.\"\"\" template_mention : MentionTemplateData","title":"MentionTemplate"},{"location":"reference/#notional.types.MentionTemplateData","text":"Nested template data for Mention properties. Source code in notional/types.py class MentionTemplateData ( TypedObject ): \"\"\"Nested template data for `Mention` properties.\"\"\"","title":"MentionTemplateData"},{"location":"reference/#notional.types.MentionTemplateDate","text":"Nested date template data for Mention properties. Source code in notional/types.py class MentionTemplateDate ( MentionTemplateData , type = \"template_mention_date\" ): \"\"\"Nested date template data for `Mention` properties.\"\"\" template_mention_date : str","title":"MentionTemplateDate"},{"location":"reference/#notional.types.MentionTemplateUser","text":"Nested user template data for Mention properties. Source code in notional/types.py class MentionTemplateUser ( MentionTemplateData , type = \"template_mention_user\" ): \"\"\"Nested user template data for `Mention` properties.\"\"\" template_mention_user : str","title":"MentionTemplateUser"},{"location":"reference/#notional.types.MentionUser","text":"Nested user data for Mention properties. Source code in notional/types.py class MentionUser ( MentionData , type = \"user\" ): \"\"\"Nested user data for `Mention` properties.\"\"\" user : User","title":"MentionUser"},{"location":"reference/#notional.types.MultiSelect","text":"Notion multi-select type. Source code in notional/types.py class MultiSelect ( PropertyValue , type = \"multi_select\" ): \"\"\"Notion multi-select type.\"\"\" multi_select : List [ SelectValue ] = [] def __str__ ( self ): \"\"\"Return a string representation of this property.\"\"\" return \", \" . join ( self . Values ) def __len__ ( self ): \"\"\"Count the number of selected values.\"\"\" return len ( self . multi_select ) def __getitem__ ( self , index ): \"\"\"Return the SelectValue object at the given index.\"\"\" if self . multi_select is None : raise IndexError ( \"empty property\" ) if index > len ( self . multi_select ): raise IndexError ( \"index out of range\" ) return self . multi_select [ index ] def __iadd__ ( self , other ): \"\"\"Add the given option to this MultiSelect.\"\"\" if other in self : raise ValueError ( f \"Duplicate item: { other } \" ) self . append ( other ) return self def __isub__ ( self , other ): \"\"\"Remove the given value from this MultiSelect.\"\"\" if other not in self : raise ValueError ( f \"No such item: { other } \" ) self . remove ( other ) return self def __contains__ ( self , name ): \"\"\"Determine if the given name is in this MultiSelect. To avoid confusion, only names are considered for comparison, not ID's. \"\"\" for opt in self . multi_select : if opt . name == name : return True return False def __iter__ ( self ): \"\"\"Iterate over the SelectValue's in this property.\"\"\" if self . multi_select is None : return None return iter ( self . multi_select ) @classmethod def __compose__ ( cls , value ): \"\"\"Initialize a new MultiSelect from the given value.\"\"\" if isinstance ( value , list ): return cls . _compose_from_list ( * value ) return cls . _compose_from_list ( value ) def append ( self , * values ): \"\"\"Add selected values to this MultiSelect.\"\"\" for value in values : if value is None : raise ValueError ( \"'None' is an invalid value\" ) if value not in self : opt = SelectValue ( name = value ) self . multi_select . append ( opt ) def remove ( self , * values ): \"\"\"Remove selected values from this MultiSelect.\"\"\" self . multi_select = [ opt for opt in self . multi_select if opt . name not in values ] @property def Values ( self ): \"\"\"Return the names of each value in this MultiSelect as a list.\"\"\" if self . multi_select is None : return None return [ str ( val ) for val in self . multi_select if val . name is not None ] @classmethod def _compose_from_list ( cls , * values ): \"\"\"Create a Select block from a list of values. All values in the list will be automatically converted to strings. \"\"\" select = [] for value in values : if value is None : continue select . append ( SelectValue ( name = str ( value ))) return cls ( multi_select = select )","title":"MultiSelect"},{"location":"reference/#notional.types.MultiSelect.Values","text":"Return the names of each value in this MultiSelect as a list.","title":"Values"},{"location":"reference/#notional.types.MultiSelect.__compose__","text":"Initialize a new MultiSelect from the given value. Source code in notional/types.py @classmethod def __compose__ ( cls , value ): \"\"\"Initialize a new MultiSelect from the given value.\"\"\" if isinstance ( value , list ): return cls . _compose_from_list ( * value ) return cls . _compose_from_list ( value )","title":"__compose__()"},{"location":"reference/#notional.types.MultiSelect.__contains__","text":"Determine if the given name is in this MultiSelect. To avoid confusion, only names are considered for comparison, not ID's. Source code in notional/types.py def __contains__ ( self , name ): \"\"\"Determine if the given name is in this MultiSelect. To avoid confusion, only names are considered for comparison, not ID's. \"\"\" for opt in self . multi_select : if opt . name == name : return True return False","title":"__contains__()"},{"location":"reference/#notional.types.MultiSelect.__getitem__","text":"Return the SelectValue object at the given index. Source code in notional/types.py def __getitem__ ( self , index ): \"\"\"Return the SelectValue object at the given index.\"\"\" if self . multi_select is None : raise IndexError ( \"empty property\" ) if index > len ( self . multi_select ): raise IndexError ( \"index out of range\" ) return self . multi_select [ index ]","title":"__getitem__()"},{"location":"reference/#notional.types.MultiSelect.__iadd__","text":"Add the given option to this MultiSelect. Source code in notional/types.py def __iadd__ ( self , other ): \"\"\"Add the given option to this MultiSelect.\"\"\" if other in self : raise ValueError ( f \"Duplicate item: { other } \" ) self . append ( other ) return self","title":"__iadd__()"},{"location":"reference/#notional.types.MultiSelect.__isub__","text":"Remove the given value from this MultiSelect. Source code in notional/types.py def __isub__ ( self , other ): \"\"\"Remove the given value from this MultiSelect.\"\"\" if other not in self : raise ValueError ( f \"No such item: { other } \" ) self . remove ( other ) return self","title":"__isub__()"},{"location":"reference/#notional.types.MultiSelect.__iter__","text":"Iterate over the SelectValue's in this property. Source code in notional/types.py def __iter__ ( self ): \"\"\"Iterate over the SelectValue's in this property.\"\"\" if self . multi_select is None : return None return iter ( self . multi_select )","title":"__iter__()"},{"location":"reference/#notional.types.MultiSelect.__len__","text":"Count the number of selected values. Source code in notional/types.py def __len__ ( self ): \"\"\"Count the number of selected values.\"\"\" return len ( self . multi_select )","title":"__len__()"},{"location":"reference/#notional.types.MultiSelect.__str__","text":"Return a string representation of this property. Source code in notional/types.py def __str__ ( self ): \"\"\"Return a string representation of this property.\"\"\" return \", \" . join ( self . Values )","title":"__str__()"},{"location":"reference/#notional.types.MultiSelect.append","text":"Add selected values to this MultiSelect. Source code in notional/types.py def append ( self , * values ): \"\"\"Add selected values to this MultiSelect.\"\"\" for value in values : if value is None : raise ValueError ( \"'None' is an invalid value\" ) if value not in self : opt = SelectValue ( name = value ) self . multi_select . append ( opt )","title":"append()"},{"location":"reference/#notional.types.MultiSelect.remove","text":"Remove selected values from this MultiSelect. Source code in notional/types.py def remove ( self , * values ): \"\"\"Remove selected values from this MultiSelect.\"\"\" self . multi_select = [ opt for opt in self . multi_select if opt . name not in values ]","title":"remove()"},{"location":"reference/#notional.types.NativeTypeMixin","text":"Mixin class for properties that can be represented as native Python types. Source code in notional/types.py class NativeTypeMixin : \"\"\"Mixin class for properties that can be represented as native Python types.\"\"\" def __str__ ( self ): \"\"\"Return a string representation of this object.\"\"\" value = self . Value if value is None : return \"\" return str ( value ) def __eq__ ( self , other ): \"\"\"Determine if this property is equal to the given object.\"\"\" return self . Value == other def __ne__ ( self , other ): \"\"\"Determine if this property is not equal to the given object.\"\"\" return self . Value != other @classmethod def __compose__ ( cls , value ): \"\"\"Build the property value from the native Python value.\"\"\" # use type-name field to instantiate the class when possible if hasattr ( cls , \"type\" ): return cls ( ** { cls . type : value }) raise NotImplementedError () @property def Value ( self ): \"\"\"Get the current value of this property as a native Python type.\"\"\" cls = self . __class__ # check to see if the object has a field with the type-name # (this is assigned by TypedObject during subclass creation) if hasattr ( cls , \"type\" ) and hasattr ( self , cls . type ): return getattr ( self , cls . type ) raise NotImplementedError ()","title":"NativeTypeMixin"},{"location":"reference/#notional.types.NativeTypeMixin.Value","text":"Get the current value of this property as a native Python type.","title":"Value"},{"location":"reference/#notional.types.NativeTypeMixin.__compose__","text":"Build the property value from the native Python value. Source code in notional/types.py @classmethod def __compose__ ( cls , value ): \"\"\"Build the property value from the native Python value.\"\"\" # use type-name field to instantiate the class when possible if hasattr ( cls , \"type\" ): return cls ( ** { cls . type : value }) raise NotImplementedError ()","title":"__compose__()"},{"location":"reference/#notional.types.NativeTypeMixin.__eq__","text":"Determine if this property is equal to the given object. Source code in notional/types.py def __eq__ ( self , other ): \"\"\"Determine if this property is equal to the given object.\"\"\" return self . Value == other","title":"__eq__()"},{"location":"reference/#notional.types.NativeTypeMixin.__ne__","text":"Determine if this property is not equal to the given object. Source code in notional/types.py def __ne__ ( self , other ): \"\"\"Determine if this property is not equal to the given object.\"\"\" return self . Value != other","title":"__ne__()"},{"location":"reference/#notional.types.NativeTypeMixin.__str__","text":"Return a string representation of this object. Source code in notional/types.py def __str__ ( self ): \"\"\"Return a string representation of this object.\"\"\" value = self . Value if value is None : return \"\" return str ( value )","title":"__str__()"},{"location":"reference/#notional.types.Number","text":"Simple number type. Source code in notional/types.py class Number ( NativeTypeMixin , PropertyValue , type = \"number\" ): \"\"\"Simple number type.\"\"\" number : Optional [ Union [ float , int ]] = None def __iadd__ ( self , other ): \"\"\"Add the given value to this Number.\"\"\" self . number += other return self def __isub__ ( self , other ): \"\"\"Subtract the given value from this Number.\"\"\" self . number -= other return self @property def Value ( self ): \"\"\"Get the current value of this property as a native Python number.\"\"\" if self . number is None : return None if self . number == int ( self . number ): return int ( self . number ) return self . number","title":"Number"},{"location":"reference/#notional.types.Number.Value","text":"Get the current value of this property as a native Python number.","title":"Value"},{"location":"reference/#notional.types.Number.__iadd__","text":"Add the given value to this Number. Source code in notional/types.py def __iadd__ ( self , other ): \"\"\"Add the given value to this Number.\"\"\" self . number += other return self","title":"__iadd__()"},{"location":"reference/#notional.types.Number.__isub__","text":"Subtract the given value from this Number. Source code in notional/types.py def __isub__ ( self , other ): \"\"\"Subtract the given value from this Number.\"\"\" self . number -= other return self","title":"__isub__()"},{"location":"reference/#notional.types.NumberFormula","text":"A Notion number formula result. Source code in notional/types.py class NumberFormula ( FormulaResult , type = \"number\" ): \"\"\"A Notion number formula result.\"\"\" number : Optional [ Union [ float , int ]] = None @property def Result ( self ): \"\"\"Return the result of this NumberFormula.\"\"\" return self . number","title":"NumberFormula"},{"location":"reference/#notional.types.NumberFormula.Result","text":"Return the result of this NumberFormula.","title":"Result"},{"location":"reference/#notional.types.PageReference","text":"A page reference is an object with an id property. Source code in notional/types.py class PageReference ( DataObject ): \"\"\"A page reference is an object with an id property.\"\"\" id : UUID @classmethod def __compose__ ( cls , page ): \"\"\"Return the correct page reference based on the object type.\"\"\" if isinstance ( page , str ): return PageReference ( id = page ) if isinstance ( page , UUID ): return PageReference ( id = page ) if hasattr ( page , \"id\" ): return PageReference ( id = page . id ) raise ValueError ( \"Unrecognized 'page' attribute\" )","title":"PageReference"},{"location":"reference/#notional.types.PageReference.__compose__","text":"Return the correct page reference based on the object type. Source code in notional/types.py @classmethod def __compose__ ( cls , page ): \"\"\"Return the correct page reference based on the object type.\"\"\" if isinstance ( page , str ): return PageReference ( id = page ) if isinstance ( page , UUID ): return PageReference ( id = page ) if hasattr ( page , \"id\" ): return PageReference ( id = page . id ) raise ValueError ( \"Unrecognized 'page' attribute\" )","title":"__compose__()"},{"location":"reference/#notional.types.People","text":"Notion people type. Source code in notional/types.py class People ( PropertyValue , type = \"people\" ): \"\"\"Notion people type.\"\"\" people : List [ User ] = [] def __iter__ ( self ): \"\"\"Iterate over the User's in this property.\"\"\" if self . people is None : return None return iter ( self . people ) def __contains__ ( self , other ): \"\"\"Determine if the given User or name is in this People. To avoid confusion, only names are considered for comparison (not ID's). \"\"\" for user in self . people : if user == other : return True if user . name == other : return True return False def __len__ ( self ): \"\"\"Return the number of People in this property.\"\"\" return len ( self . people ) def __getitem__ ( self , index ): \"\"\"Return the People object at the given index.\"\"\" if self . people is None : raise IndexError ( \"empty property\" ) if index > len ( self . people ): raise IndexError ( \"index out of range\" ) return self . people [ index ] def __str__ ( self ): \"\"\"Return a string representation of this property.\"\"\" return \", \" . join ([ str ( user ) for user in self . people ])","title":"People"},{"location":"reference/#notional.types.People.__contains__","text":"Determine if the given User or name is in this People. To avoid confusion, only names are considered for comparison (not ID's). Source code in notional/types.py def __contains__ ( self , other ): \"\"\"Determine if the given User or name is in this People. To avoid confusion, only names are considered for comparison (not ID's). \"\"\" for user in self . people : if user == other : return True if user . name == other : return True return False","title":"__contains__()"},{"location":"reference/#notional.types.People.__getitem__","text":"Return the People object at the given index. Source code in notional/types.py def __getitem__ ( self , index ): \"\"\"Return the People object at the given index.\"\"\" if self . people is None : raise IndexError ( \"empty property\" ) if index > len ( self . people ): raise IndexError ( \"index out of range\" ) return self . people [ index ]","title":"__getitem__()"},{"location":"reference/#notional.types.People.__iter__","text":"Iterate over the User's in this property. Source code in notional/types.py def __iter__ ( self ): \"\"\"Iterate over the User's in this property.\"\"\" if self . people is None : return None return iter ( self . people )","title":"__iter__()"},{"location":"reference/#notional.types.People.__len__","text":"Return the number of People in this property. Source code in notional/types.py def __len__ ( self ): \"\"\"Return the number of People in this property.\"\"\" return len ( self . people )","title":"__len__()"},{"location":"reference/#notional.types.People.__str__","text":"Return a string representation of this property. Source code in notional/types.py def __str__ ( self ): \"\"\"Return a string representation of this property.\"\"\" return \", \" . join ([ str ( user ) for user in self . people ])","title":"__str__()"},{"location":"reference/#notional.types.PhoneNumber","text":"Notion phone type. Source code in notional/types.py class PhoneNumber ( NativeTypeMixin , PropertyValue , type = \"phone_number\" ): \"\"\"Notion phone type.\"\"\" phone_number : Optional [ str ] = None","title":"PhoneNumber"},{"location":"reference/#notional.types.PropertyValue","text":"Base class for Notion property values. Source code in notional/types.py class PropertyValue ( TypedObject ): \"\"\"Base class for Notion property values.\"\"\" id : Optional [ str ] = None","title":"PropertyValue"},{"location":"reference/#notional.types.Relation","text":"A Notion relation property value. Source code in notional/types.py class Relation ( PropertyValue , type = \"relation\" ): \"\"\"A Notion relation property value.\"\"\" relation : List [ PageReference ] = [] @classmethod def __compose__ ( cls , pages ): \"\"\"Return a `Relation` property with the specified pages.\"\"\" if isinstance ( pages , list ): refs = [ PageReference [ page ] for page in pages ] else : refs = [ PageReference [ pages ]] return cls ( relation = refs ) def __contains__ ( self , page ): \"\"\"Determine if the given page is in this Relation.\"\"\" return PageReference [ page ] in self . relation def __iter__ ( self ): \"\"\"Iterate over the PageReference's in this property.\"\"\" if self . relation is None : return None return iter ( self . relation ) def __len__ ( self ): \"\"\"Return the number of PageReference's in this property.\"\"\" return len ( self . relation ) def __getitem__ ( self , index ): \"\"\"Return the PageReference object at the given index.\"\"\" if self . relation is None : raise IndexError ( \"empty property\" ) if index > len ( self . relation ): raise IndexError ( \"index out of range\" ) return self . relation [ index ] def __iadd__ ( self , page ): \"\"\"Add the given page to this Relation in place.\"\"\" ref = PageReference [ page ] if ref in self . relation : raise ValueError ( f \"Duplicate item: { ref . id } \" ) self . relation . append ( ref ) return self def __isub__ ( self , page ): \"\"\"Remove the given page from this Relation in place.\"\"\" ref = PageReference [ page ] if ref in self . relation : raise ValueError ( f \"No such item: { ref . id } \" ) self . relation . remove ( ref ) return self","title":"Relation"},{"location":"reference/#notional.types.Relation.__compose__","text":"Return a Relation property with the specified pages. Source code in notional/types.py @classmethod def __compose__ ( cls , pages ): \"\"\"Return a `Relation` property with the specified pages.\"\"\" if isinstance ( pages , list ): refs = [ PageReference [ page ] for page in pages ] else : refs = [ PageReference [ pages ]] return cls ( relation = refs )","title":"__compose__()"},{"location":"reference/#notional.types.Relation.__contains__","text":"Determine if the given page is in this Relation. Source code in notional/types.py def __contains__ ( self , page ): \"\"\"Determine if the given page is in this Relation.\"\"\" return PageReference [ page ] in self . relation","title":"__contains__()"},{"location":"reference/#notional.types.Relation.__getitem__","text":"Return the PageReference object at the given index. Source code in notional/types.py def __getitem__ ( self , index ): \"\"\"Return the PageReference object at the given index.\"\"\" if self . relation is None : raise IndexError ( \"empty property\" ) if index > len ( self . relation ): raise IndexError ( \"index out of range\" ) return self . relation [ index ]","title":"__getitem__()"},{"location":"reference/#notional.types.Relation.__iadd__","text":"Add the given page to this Relation in place. Source code in notional/types.py def __iadd__ ( self , page ): \"\"\"Add the given page to this Relation in place.\"\"\" ref = PageReference [ page ] if ref in self . relation : raise ValueError ( f \"Duplicate item: { ref . id } \" ) self . relation . append ( ref ) return self","title":"__iadd__()"},{"location":"reference/#notional.types.Relation.__isub__","text":"Remove the given page from this Relation in place. Source code in notional/types.py def __isub__ ( self , page ): \"\"\"Remove the given page from this Relation in place.\"\"\" ref = PageReference [ page ] if ref in self . relation : raise ValueError ( f \"No such item: { ref . id } \" ) self . relation . remove ( ref ) return self","title":"__isub__()"},{"location":"reference/#notional.types.Relation.__iter__","text":"Iterate over the PageReference's in this property. Source code in notional/types.py def __iter__ ( self ): \"\"\"Iterate over the PageReference's in this property.\"\"\" if self . relation is None : return None return iter ( self . relation )","title":"__iter__()"},{"location":"reference/#notional.types.Relation.__len__","text":"Return the number of PageReference's in this property. Source code in notional/types.py def __len__ ( self ): \"\"\"Return the number of PageReference's in this property.\"\"\" return len ( self . relation )","title":"__len__()"},{"location":"reference/#notional.types.RichText","text":"Notion rich text type. Source code in notional/types.py class RichText ( NativeTypeMixin , PropertyValue , type = \"rich_text\" ): \"\"\"Notion rich text type.\"\"\" rich_text : List [ RichTextObject ] = [] def __len__ ( self ): \"\"\"Return the number of object in the RichText object.\"\"\" return len ( self . rich_text ) @classmethod def __compose__ ( cls , text ): \"\"\"Create a new `RichText` property from the given strings.\"\"\" return cls ( rich_text = [ TextObject [ text ]]) @property def Value ( self ): \"\"\"Return the plain text from this RichText.\"\"\" if self . rich_text is None : return None return plain_text ( * self . rich_text )","title":"RichText"},{"location":"reference/#notional.types.RichText.Value","text":"Return the plain text from this RichText.","title":"Value"},{"location":"reference/#notional.types.RichText.__compose__","text":"Create a new RichText property from the given strings. Source code in notional/types.py @classmethod def __compose__ ( cls , text ): \"\"\"Create a new `RichText` property from the given strings.\"\"\" return cls ( rich_text = [ TextObject [ text ]])","title":"__compose__()"},{"location":"reference/#notional.types.RichText.__len__","text":"Return the number of object in the RichText object. Source code in notional/types.py def __len__ ( self ): \"\"\"Return the number of object in the RichText object.\"\"\" return len ( self . rich_text )","title":"__len__()"},{"location":"reference/#notional.types.Rollup","text":"A Notion rollup property value. Source code in notional/types.py class Rollup ( PropertyValue , type = \"rollup\" ): \"\"\"A Notion rollup property value.\"\"\" rollup : Optional [ RollupObject ] = None def __str__ ( self ): \"\"\"Return a string representation of this Rollup property.\"\"\" if self . rollup is None : return \"\" value = self . rollup . Value if value is None : return \"\" return str ( value )","title":"Rollup"},{"location":"reference/#notional.types.Rollup.__str__","text":"Return a string representation of this Rollup property. Source code in notional/types.py def __str__ ( self ): \"\"\"Return a string representation of this Rollup property.\"\"\" if self . rollup is None : return \"\" value = self . rollup . Value if value is None : return \"\" return str ( value )","title":"__str__()"},{"location":"reference/#notional.types.RollupArray","text":"A Notion rollup array property value. Source code in notional/types.py class RollupArray ( RollupObject , type = \"array\" ): \"\"\"A Notion rollup array property value.\"\"\" array : List [ PropertyValue ] @property def Value ( self ): \"\"\"Return the native representation of this Rollup object.\"\"\" return self . array","title":"RollupArray"},{"location":"reference/#notional.types.RollupArray.Value","text":"Return the native representation of this Rollup object.","title":"Value"},{"location":"reference/#notional.types.RollupDate","text":"A Notion rollup date property value. Source code in notional/types.py class RollupDate ( RollupObject , type = \"date\" ): \"\"\"A Notion rollup date property value.\"\"\" date : Optional [ DateRange ] = None @property def Value ( self ): \"\"\"Return the native representation of this Rollup object.\"\"\" return self . date","title":"RollupDate"},{"location":"reference/#notional.types.RollupDate.Value","text":"Return the native representation of this Rollup object.","title":"Value"},{"location":"reference/#notional.types.RollupNumber","text":"A Notion rollup number property value. Source code in notional/types.py class RollupNumber ( RollupObject , type = \"number\" ): \"\"\"A Notion rollup number property value.\"\"\" number : Optional [ Union [ float , int ]] = None @property def Value ( self ): \"\"\"Return the native representation of this Rollup object.\"\"\" return self . number","title":"RollupNumber"},{"location":"reference/#notional.types.RollupNumber.Value","text":"Return the native representation of this Rollup object.","title":"Value"},{"location":"reference/#notional.types.RollupObject","text":"A Notion rollup property value. Source code in notional/types.py class RollupObject ( TypedObject , ABC ): \"\"\"A Notion rollup property value.\"\"\" function : Optional [ Function ] = None @property @abstractmethod def Value ( self ): \"\"\"Return the native representation of this Rollup object.\"\"\"","title":"RollupObject"},{"location":"reference/#notional.types.RollupObject.Value","text":"Return the native representation of this Rollup object.","title":"Value"},{"location":"reference/#notional.types.SelectOne","text":"Notion select type. Source code in notional/types.py class SelectOne ( NativeTypeMixin , PropertyValue , type = \"select\" ): \"\"\"Notion select type.\"\"\" select : Optional [ SelectValue ] = None def __str__ ( self ): \"\"\"Return a string representation of this property.\"\"\" return self . Value or \"\" def __eq__ ( self , other ): \"\"\"Determine if this property is equal to the given object. To avoid confusion, this method compares Select options by name. \"\"\" if self . select is None : return other is None return other == self . select . name @classmethod def __compose__ ( cls , value ): \"\"\"Create a `SelectOne` property from the given value. :param value: a string to use for this property \"\"\" if value is None : raise ValueError ( \"'name' cannot be None\" ) return cls ( select = SelectValue ( name = value )) @property def Value ( self ): \"\"\"Return the value of this property as a string.\"\"\" if self . select is None : return None return str ( self . select )","title":"SelectOne"},{"location":"reference/#notional.types.SelectOne.Value","text":"Return the value of this property as a string.","title":"Value"},{"location":"reference/#notional.types.SelectOne.__compose__","text":"Create a SelectOne property from the given value. :param value: a string to use for this property Source code in notional/types.py @classmethod def __compose__ ( cls , value ): \"\"\"Create a `SelectOne` property from the given value. :param value: a string to use for this property \"\"\" if value is None : raise ValueError ( \"'name' cannot be None\" ) return cls ( select = SelectValue ( name = value ))","title":"__compose__()"},{"location":"reference/#notional.types.SelectOne.__eq__","text":"Determine if this property is equal to the given object. To avoid confusion, this method compares Select options by name. Source code in notional/types.py def __eq__ ( self , other ): \"\"\"Determine if this property is equal to the given object. To avoid confusion, this method compares Select options by name. \"\"\" if self . select is None : return other is None return other == self . select . name","title":"__eq__()"},{"location":"reference/#notional.types.SelectOne.__str__","text":"Return a string representation of this property. Source code in notional/types.py def __str__ ( self ): \"\"\"Return a string representation of this property.\"\"\" return self . Value or \"\"","title":"__str__()"},{"location":"reference/#notional.types.SelectValue","text":"Values for select & multi-select properties. Source code in notional/types.py class SelectValue ( DataObject ): \"\"\"Values for select & multi-select properties.\"\"\" name : str id : Optional [ Union [ UUID , str ]] = None color : Optional [ Color ] = None def __str__ ( self ): \"\"\"Return a string representation of this property.\"\"\" return self . name","title":"SelectValue"},{"location":"reference/#notional.types.SelectValue.__str__","text":"Return a string representation of this property. Source code in notional/types.py def __str__ ( self ): \"\"\"Return a string representation of this property.\"\"\" return self . name","title":"__str__()"},{"location":"reference/#notional.types.StringFormula","text":"A Notion string formula result. Source code in notional/types.py class StringFormula ( FormulaResult , type = \"string\" ): \"\"\"A Notion string formula result.\"\"\" string : Optional [ str ] = None @property def Result ( self ): \"\"\"Return the result of this StringFormula.\"\"\" return self . string","title":"StringFormula"},{"location":"reference/#notional.types.StringFormula.Result","text":"Return the result of this StringFormula.","title":"Result"},{"location":"reference/#notional.types.Title","text":"Notion title type. Source code in notional/types.py class Title ( NativeTypeMixin , PropertyValue , type = \"title\" ): \"\"\"Notion title type.\"\"\" title : List [ RichTextObject ] = [] def __len__ ( self ): \"\"\"Return the number of object in the Title object.\"\"\" return len ( self . title ) @classmethod def __compose__ ( cls , text ): \"\"\"Create a new `Title` property from the given text.\"\"\" return cls ( title = [ TextObject [ text ]]) @property def Value ( self ): \"\"\"Return the plain text from this Title.\"\"\" if self . title is None : return None return plain_text ( * self . title )","title":"Title"},{"location":"reference/#notional.types.Title.Value","text":"Return the plain text from this Title.","title":"Value"},{"location":"reference/#notional.types.Title.__compose__","text":"Create a new Title property from the given text. Source code in notional/types.py @classmethod def __compose__ ( cls , text ): \"\"\"Create a new `Title` property from the given text.\"\"\" return cls ( title = [ TextObject [ text ]])","title":"__compose__()"},{"location":"reference/#notional.types.Title.__len__","text":"Return the number of object in the Title object. Source code in notional/types.py def __len__ ( self ): \"\"\"Return the number of object in the Title object.\"\"\" return len ( self . title )","title":"__len__()"},{"location":"reference/#notional.types.URL","text":"Notion URL type. Source code in notional/types.py class URL ( NativeTypeMixin , PropertyValue , type = \"url\" ): \"\"\"Notion URL type.\"\"\" url : Optional [ str ] = None","title":"URL"},{"location":"reference/#notional.user","text":"Wrapper for Notion user objects.","title":"user"},{"location":"reference/#notional.user.Bot","text":"Represents a Bot in Notion. Source code in notional/user.py class Bot ( User ): \"\"\"Represents a Bot in Notion.\"\"\" class _NestedData ( NestedObject ): pass bot : _NestedData = None def __str__ ( self ): \"\"\"Return a string representation of this `Bot`.\"\"\" return f \"[% { self . name } ]\"","title":"Bot"},{"location":"reference/#notional.user.Bot.__str__","text":"Return a string representation of this Bot . Source code in notional/user.py def __str__ ( self ): \"\"\"Return a string representation of this `Bot`.\"\"\" return f \"[% { self . name } ]\"","title":"__str__()"},{"location":"reference/#notional.user.Person","text":"Represents a Person in Notion. Source code in notional/user.py class Person ( User ): \"\"\"Represents a Person in Notion.\"\"\" class _NestedData ( NestedObject ): email : str person : _NestedData = None def __str__ ( self ): \"\"\"Return a string representation of this `Person`.\"\"\" return f \"[@ { self . name } ]\"","title":"Person"},{"location":"reference/#notional.user.Person.__str__","text":"Return a string representation of this Person . Source code in notional/user.py def __str__ ( self ): \"\"\"Return a string representation of this `Person`.\"\"\" return f \"[@ { self . name } ]\"","title":"__str__()"},{"location":"reference/#notional.user.User","text":"Represents a User in Notion. Source code in notional/user.py class User ( DataObject ): \"\"\"Represents a User in Notion.\"\"\" # XXX why isn't this a TypedObject ? id : UUID object : str = \"user\" type : Optional [ UserType ] = None name : Optional [ str ] = None avatar_url : Optional [ str ] = None @classmethod def parse_obj ( cls , obj ): \"\"\"Attempt to parse the given object data into the correct `User` type.\"\"\" if obj is None : return None if \"type\" in obj : if obj [ \"type\" ] == \"person\" : return Person ( ** obj ) if obj [ \"type\" ] == \"bot\" : return Bot ( ** obj ) return cls ( obj )","title":"User"},{"location":"reference/#notional.user.User.parse_obj","text":"Attempt to parse the given object data into the correct User type. Source code in notional/user.py @classmethod def parse_obj ( cls , obj ): \"\"\"Attempt to parse the given object data into the correct `User` type.\"\"\" if obj is None : return None if \"type\" in obj : if obj [ \"type\" ] == \"person\" : return Person ( ** obj ) if obj [ \"type\" ] == \"bot\" : return Bot ( ** obj ) return cls ( obj )","title":"parse_obj()"},{"location":"reference/#notional.user.UserType","text":"Available user types. Source code in notional/user.py class UserType ( str , Enum ): \"\"\"Available user types.\"\"\" PERSON = \"person\" BOT = \"bot\"","title":"UserType"},{"location":"reference/#notional.version","text":"Consistent version information for notional.","title":"version"},{"location":"reference/blocks/","text":"Wrapper for Notion API blocks. Blocks are specifc records that hold content. Similar to other records, these object provide access to the primitive data structure used in the Notion API as well as higher-level methods. Block ( Record , TypedObject ) pydantic-model A standard block object in Notion. Calling the block will expose the nested data in the object. Source code in notional/blocks.py class Block ( Record , TypedObject , object = \"block\" ): \"\"\"A standard block object in Notion. Calling the block will expose the nested data in the object. \"\"\" Bookmark ( Block ) pydantic-model A bookmark block in Notion. Source code in notional/blocks.py class Bookmark ( Block , type = \"bookmark\" ): \"\"\"A bookmark block in Notion.\"\"\" class _NestedData ( NestedObject ): url : str = None caption : Optional [ List [ RichTextObject ]] = None bookmark : _NestedData = _NestedData () @classmethod def __compose__ ( cls , url ): \"\"\"Compoase a new `Bookmark` block from a specific URL.\"\"\" return Bookmark ( bookmark = Bookmark . _NestedData ( url = url )) @property def URL ( self ): \"\"\"Return the URL contained in this `Bookmark` block.\"\"\" return self . bookmark . url @property def Markdown ( self ): \"\"\"Return the contents of this block as markdown text.\"\"\" if self . bookmark and self . bookmark . url : return f \"< { self . bookmark . url } >\" return \"\" Markdown property readonly Return the contents of this block as markdown text. URL property readonly Return the URL contained in this Bookmark block. __compose__ ( url ) classmethod special Compoase a new Bookmark block from a specific URL. Source code in notional/blocks.py @classmethod def __compose__ ( cls , url ): \"\"\"Compoase a new `Bookmark` block from a specific URL.\"\"\" return Bookmark ( bookmark = Bookmark . _NestedData ( url = url )) Breadcrumb ( Block ) pydantic-model A breadcrumb block in Notion. Source code in notional/blocks.py class Breadcrumb ( Block , type = \"breadcrumb\" ): \"\"\"A breadcrumb block in Notion.\"\"\" class _NestedData ( NestedObject ): pass breadcrumb : _NestedData = _NestedData () BulletedListItem ( TextBlock , WithChildrenMixin ) pydantic-model A bulleted list item in Notion. Source code in notional/blocks.py class BulletedListItem ( TextBlock , WithChildrenMixin , type = \"bulleted_list_item\" ): \"\"\"A bulleted list item in Notion.\"\"\" class _NestedData ( NestedObject ): rich_text : List [ RichTextObject ] = [] children : Optional [ List [ Block ]] = None color : FullColor = FullColor . DEFAULT bulleted_list_item : _NestedData = _NestedData () @property def Markdown ( self ): \"\"\"Return the contents of this block as markdown text.\"\"\" if self . bulleted_list_item and self . bulleted_list_item . rich_text : return f \"- { markdown ( * self . bulleted_list_item . rich_text ) } \" return \"\" Markdown property readonly Return the contents of this block as markdown text. Callout ( TextBlock , WithChildrenMixin ) pydantic-model A callout block in Notion. Source code in notional/blocks.py class Callout ( TextBlock , WithChildrenMixin , type = \"callout\" ): \"\"\"A callout block in Notion.\"\"\" class _NestedData ( NestedObject ): rich_text : List [ RichTextObject ] = [] children : Optional [ List [ Block ]] = None icon : Optional [ Union [ FileObject , EmojiObject ]] = None color : FullColor = FullColor . DEFAULT callout : _NestedData = _NestedData () ChildDatabase ( Block ) pydantic-model A child database block in Notion. Source code in notional/blocks.py class ChildDatabase ( Block , type = \"child_database\" ): \"\"\"A child database block in Notion.\"\"\" class _NestedData ( NestedObject ): title : str = None child_database : _NestedData = _NestedData () ChildPage ( Block ) pydantic-model A child page block in Notion. Source code in notional/blocks.py class ChildPage ( Block , type = \"child_page\" ): \"\"\"A child page block in Notion.\"\"\" class _NestedData ( NestedObject ): title : str = None child_page : _NestedData = _NestedData () Code ( TextBlock ) pydantic-model A code block in Notion. Source code in notional/blocks.py class Code ( TextBlock , type = \"code\" ): \"\"\"A code block in Notion.\"\"\" class _NestedData ( NestedObject ): rich_text : List [ RichTextObject ] = [] caption : List [ RichTextObject ] = [] language : CodingLanguage = CodingLanguage . PLAIN_TEXT code : _NestedData = _NestedData () @classmethod def __compose__ ( cls , text , lang = CodingLanguage . PLAIN_TEXT ): \"\"\"Compose a `Code` block from the given text and language.\"\"\" return Code ( code = Code . _NestedData ( rich_text = [ TextObject [ text ]], language = lang , ) ) @property def Markdown ( self ): \"\"\"Return the contents of this block as markdown text.\"\"\" lang = self . code . language if self . code and self . code . language else \"\" # FIXME this is not the standard way to represent code blocks in markdown... if self . code and self . code . rich_text : return f \"``` { lang } \\n { markdown ( * self . code . rich_text ) } \\n ```\" return \"\" Markdown property readonly Return the contents of this block as markdown text. __compose__ ( text , lang =< CodingLanguage . PLAIN_TEXT : 'plain text' > ) classmethod special Compose a Code block from the given text and language. Source code in notional/blocks.py @classmethod def __compose__ ( cls , text , lang = CodingLanguage . PLAIN_TEXT ): \"\"\"Compose a `Code` block from the given text and language.\"\"\" return Code ( code = Code . _NestedData ( rich_text = [ TextObject [ text ]], language = lang , ) ) Column ( Block ) pydantic-model A column block in Notion. Source code in notional/blocks.py class Column ( Block , type = \"column\" ): \"\"\"A column block in Notion.\"\"\" class _NestedData ( NestedObject ): pass column : _NestedData = _NestedData () ColumnList ( Block ) pydantic-model A column list block in Notion. Source code in notional/blocks.py class ColumnList ( Block , type = \"column_list\" ): \"\"\"A column list block in Notion.\"\"\" class _NestedData ( NestedObject ): pass column_list : _NestedData = _NestedData () Divider ( Block ) pydantic-model A divider block in Notion. Source code in notional/blocks.py class Divider ( Block , type = \"divider\" ): \"\"\"A divider block in Notion.\"\"\" divider : Any = {} @property def Markdown ( self ): \"\"\"Return the contents of this block as markdown text.\"\"\" return \"---\" Markdown property readonly Return the contents of this block as markdown text. Embed ( Block ) pydantic-model An embed block in Notion. Source code in notional/blocks.py class Embed ( Block , type = \"embed\" ): \"\"\"An embed block in Notion.\"\"\" class _NestedData ( NestedObject ): url : str = None embed : _NestedData = _NestedData () @classmethod def __compose__ ( cls , url ): \"\"\"Create a new `Embed` block from the given URL.\"\"\" return Embed ( embed = Embed . _NestedData ( url = url )) @property def URL ( self ): \"\"\"Return the URL contained in this `Embed` block.\"\"\" return self . embed . url @property def Markdown ( self ): \"\"\"Return the contents of this block as markdown text.\"\"\" if self . embed and self . embed . url : return f \"< { self . embed . url } >\" return \"\" Markdown property readonly Return the contents of this block as markdown text. URL property readonly Return the URL contained in this Embed block. __compose__ ( url ) classmethod special Create a new Embed block from the given URL. Source code in notional/blocks.py @classmethod def __compose__ ( cls , url ): \"\"\"Create a new `Embed` block from the given URL.\"\"\" return Embed ( embed = Embed . _NestedData ( url = url )) File ( Block ) pydantic-model A file block in Notion. Source code in notional/blocks.py class File ( Block , type = \"file\" ): \"\"\"A file block in Notion.\"\"\" file : FileObject = None Heading1 ( TextBlock ) pydantic-model A heading_1 block in Notion. Source code in notional/blocks.py class Heading1 ( TextBlock , type = \"heading_1\" ): \"\"\"A heading_1 block in Notion.\"\"\" class _NestedData ( NestedObject ): rich_text : List [ RichTextObject ] = [] color : FullColor = FullColor . DEFAULT heading_1 : _NestedData = _NestedData () @property def Markdown ( self ): \"\"\"Return the contents of this block as markdown text.\"\"\" if self . heading_1 and self . heading_1 . rich_text : return f \"# { markdown ( * self . heading_1 . rich_text ) } #\" return \"\" Markdown property readonly Return the contents of this block as markdown text. Heading2 ( TextBlock ) pydantic-model A heading_2 block in Notion. Source code in notional/blocks.py class Heading2 ( TextBlock , type = \"heading_2\" ): \"\"\"A heading_2 block in Notion.\"\"\" class _NestedData ( NestedObject ): rich_text : List [ RichTextObject ] = [] color : FullColor = FullColor . DEFAULT heading_2 : _NestedData = _NestedData () @property def Markdown ( self ): \"\"\"Return the contents of this block as markdown text.\"\"\" if self . heading_2 and self . heading_2 . rich_text : return f \"## { markdown ( * self . heading_2 . rich_text ) } ##\" return \"\" Markdown property readonly Return the contents of this block as markdown text. Heading3 ( TextBlock ) pydantic-model A heading_3 block in Notion. Source code in notional/blocks.py class Heading3 ( TextBlock , type = \"heading_3\" ): \"\"\"A heading_3 block in Notion.\"\"\" class _NestedData ( NestedObject ): rich_text : List [ RichTextObject ] = [] color : FullColor = FullColor . DEFAULT heading_3 : _NestedData = _NestedData () @property def Markdown ( self ): \"\"\"Return the contents of this block as markdown text.\"\"\" if self . heading_3 and self . heading_3 . rich_text : return f \"### { markdown ( * self . heading_3 . rich_text ) } ###\" return \"\" Markdown property readonly Return the contents of this block as markdown text. Image ( Block ) pydantic-model An image block in Notion. Source code in notional/blocks.py class Image ( Block , type = \"image\" ): \"\"\"An image block in Notion.\"\"\" image : FileObject = None LinkPreview ( Block ) pydantic-model A link_preview block in Notion. Source code in notional/blocks.py class LinkPreview ( Block , type = \"link_preview\" ): \"\"\"A link_preview block in Notion.\"\"\" class _NestedData ( NestedObject ): url : str = None link_preview : _NestedData = _NestedData () @classmethod def __compose__ ( cls , url ): \"\"\"Create a new `LinkPreview` block from the given URL.\"\"\" return LinkPreview ( link_preview = LinkPreview . _NestedData ( url = url )) @property def URL ( self ): \"\"\"Return the URL contained in this `LinkPreview` block.\"\"\" return self . link_preview . url @property def Markdown ( self ): \"\"\"Return the contents of this block as markdown text.\"\"\" if self . link_preview and self . link_preview . url : return f \"< { self . link_preview . url } >\" return \"\" Markdown property readonly Return the contents of this block as markdown text. URL property readonly Return the URL contained in this LinkPreview block. __compose__ ( url ) classmethod special Create a new LinkPreview block from the given URL. Source code in notional/blocks.py @classmethod def __compose__ ( cls , url ): \"\"\"Create a new `LinkPreview` block from the given URL.\"\"\" return LinkPreview ( link_preview = LinkPreview . _NestedData ( url = url )) LinkToPage ( Block ) pydantic-model A link_to_page block in Notion. Source code in notional/blocks.py class LinkToPage ( Block , type = \"link_to_page\" ): \"\"\"A link_to_page block in Notion.\"\"\" link_to_page : ParentRef NumberedListItem ( TextBlock , WithChildrenMixin ) pydantic-model A numbered list item in Notion. Source code in notional/blocks.py class NumberedListItem ( TextBlock , WithChildrenMixin , type = \"numbered_list_item\" ): \"\"\"A numbered list item in Notion.\"\"\" class _NestedData ( NestedObject ): rich_text : List [ RichTextObject ] = [] children : Optional [ List [ Block ]] = None color : FullColor = FullColor . DEFAULT numbered_list_item : _NestedData = _NestedData () @property def Markdown ( self ): \"\"\"Return the contents of this block as markdown text.\"\"\" if self . numbered_list_item and self . numbered_list_item . rich_text : return f \"1. { markdown ( * self . numbered_list_item . rich_text ) } \" return \"\" Markdown property readonly Return the contents of this block as markdown text. PDF ( Block ) pydantic-model A pdf block in Notion. Source code in notional/blocks.py class PDF ( Block , type = \"pdf\" ): \"\"\"A pdf block in Notion.\"\"\" pdf : FileObject = None Paragraph ( TextBlock , WithChildrenMixin ) pydantic-model A paragraph block in Notion. Source code in notional/blocks.py class Paragraph ( TextBlock , WithChildrenMixin , type = \"paragraph\" ): \"\"\"A paragraph block in Notion.\"\"\" class _NestedData ( NestedObject ): rich_text : List [ RichTextObject ] = [] children : Optional [ List [ Block ]] = None color : FullColor = FullColor . DEFAULT paragraph : _NestedData = _NestedData () @property def Markdown ( self ): \"\"\"Return the contents of this block as markdown text.\"\"\" if self . paragraph and self . paragraph . rich_text : return markdown ( * self . paragraph . rich_text ) return \"\" Markdown property readonly Return the contents of this block as markdown text. Quote ( TextBlock , WithChildrenMixin ) pydantic-model A quote block in Notion. Source code in notional/blocks.py class Quote ( TextBlock , WithChildrenMixin , type = \"quote\" ): \"\"\"A quote block in Notion.\"\"\" class _NestedData ( NestedObject ): rich_text : List [ RichTextObject ] = [] children : Optional [ List [ Block ]] = None color : FullColor = FullColor . DEFAULT quote : _NestedData = _NestedData () @property def Markdown ( self ): \"\"\"Return the contents of this block as markdown text.\"\"\" if self . quote and self . quote . rich_text : return \"> \" + markdown ( * self . quote . rich_text ) return \"\" Markdown property readonly Return the contents of this block as markdown text. SyncedBlock ( Block , WithChildrenMixin ) pydantic-model A synced_block block in Notion - either original or synced. Source code in notional/blocks.py class SyncedBlock ( Block , WithChildrenMixin , type = \"synced_block\" ): \"\"\"A synced_block block in Notion - either original or synced.\"\"\" class _NestedData ( NestedObject ): synced_from : Optional [ BlockRef ] = None children : Optional [ List [ Block ]] = None synced_block : _NestedData = _NestedData () @property def IsOriginal ( self ): \"\"\"Determine if this block represents the original content. If this method returns `False`, the block represents the sync'ed block. \"\"\" return self . synced_block . synced_from is None IsOriginal property readonly Determine if this block represents the original content. If this method returns False , the block represents the sync'ed block. Table ( Block , WithChildrenMixin ) pydantic-model A table block in Notion. Source code in notional/blocks.py class Table ( Block , WithChildrenMixin , type = \"table\" ): \"\"\"A table block in Notion.\"\"\" class _NestedData ( NestedObject ): table_width : int = 0 has_column_header : bool = False has_row_header : bool = False # note that children will not be populated when getting this block # https://developers.notion.com/reference/block#table-blocks children : Optional [ List [ TableRow ]] = [] table : _NestedData = _NestedData () def append ( self , block : TableRow ): \"\"\"Append the given row to this table. This method is only applicable when creating a new `Table` block. In order to add rows to an existing `Table`, use the `blocks.children.append()` endpoint. When adding a row, this method will rase an exception if the width does not match the expected number of cells for existing rows in the block. \"\"\" # XXX need to review whether this is applicable during update... may need # to raise an error if the block has already been created on the server if not isinstance ( block , TableRow ): raise ValueError ( \"Only TableRow may be appended to Table blocks.\" ) if self . Width == 0 : self . table . table_width = block . Width elif self . Width != block . Width : raise ValueError ( \"Number of cells in row must match table\" ) self . table . children . append ( block ) @property def Width ( self ): \"\"\"Return the current width of this table.\"\"\" return self . table . table_width Width property readonly Return the current width of this table. append ( self , block ) Append the given row to this table. This method is only applicable when creating a new Table block. In order to add rows to an existing Table , use the blocks.children.append() endpoint. When adding a row, this method will rase an exception if the width does not match the expected number of cells for existing rows in the block. Source code in notional/blocks.py def append ( self , block : TableRow ): \"\"\"Append the given row to this table. This method is only applicable when creating a new `Table` block. In order to add rows to an existing `Table`, use the `blocks.children.append()` endpoint. When adding a row, this method will rase an exception if the width does not match the expected number of cells for existing rows in the block. \"\"\" # XXX need to review whether this is applicable during update... may need # to raise an error if the block has already been created on the server if not isinstance ( block , TableRow ): raise ValueError ( \"Only TableRow may be appended to Table blocks.\" ) if self . Width == 0 : self . table . table_width = block . Width elif self . Width != block . Width : raise ValueError ( \"Number of cells in row must match table\" ) self . table . children . append ( block ) TableOfContents ( Block ) pydantic-model A table_of_contents block in Notion. Source code in notional/blocks.py class TableOfContents ( Block , type = \"table_of_contents\" ): \"\"\"A table_of_contents block in Notion.\"\"\" class _NestedData ( NestedObject ): color : FullColor = FullColor . DEFAULT table_of_contents : _NestedData = _NestedData () TableRow ( Block ) pydantic-model A table_row block in Notion. Source code in notional/blocks.py class TableRow ( Block , type = \"table_row\" ): \"\"\"A table_row block in Notion.\"\"\" class _NestedData ( NestedObject ): cells : List [ List [ RichTextObject ]] = None table_row : _NestedData = _NestedData () def append ( self , text ): \"\"\"Append the given text as a new cell in this `TableRow`. `text` may be a string, `RichTextObject` or a list of `RichTextObject`'s. :param text: the text content to append \"\"\" if self . table_row . cells is None : self . table_row . cells = [] if isinstance ( text , list ): self . table_row . cells . append ( list ) elif isinstance ( text , RichTextObject ): self . table_row . cells . append ([ text ]) else : rtf = TextObject . from_value ( text ) self . table_row . cells . append ([ rtf ]) @property def Width ( self ): \"\"\"Return the width (number of cells) in this `TableRow`.\"\"\" return len ( self . table_row . cells ) if self . table_row . cells else 0 Width property readonly Return the width (number of cells) in this TableRow . append ( self , text ) Append the given text as a new cell in this TableRow . text may be a string, RichTextObject or a list of RichTextObject 's. :param text: the text content to append Source code in notional/blocks.py def append ( self , text ): \"\"\"Append the given text as a new cell in this `TableRow`. `text` may be a string, `RichTextObject` or a list of `RichTextObject`'s. :param text: the text content to append \"\"\" if self . table_row . cells is None : self . table_row . cells = [] if isinstance ( text , list ): self . table_row . cells . append ( list ) elif isinstance ( text , RichTextObject ): self . table_row . cells . append ([ text ]) else : rtf = TextObject . from_value ( text ) self . table_row . cells . append ([ rtf ]) Template ( Block , WithChildrenMixin ) pydantic-model A template block in Notion. Source code in notional/blocks.py class Template ( Block , WithChildrenMixin , type = \"template\" ): \"\"\"A template block in Notion.\"\"\" class _NestedData ( NestedObject ): rich_text : Optional [ List [ RichTextObject ]] = None children : Optional [ List [ Block ]] = None template : _NestedData = _NestedData () TextBlock ( Block , ABC ) pydantic-model A standard text block object in Notion. Source code in notional/blocks.py class TextBlock ( Block , ABC ): \"\"\"A standard text block object in Notion.\"\"\" # text blocks have a nested object with 'type' name and a 'text' child @property def __text__ ( self ): \"\"\"Provide short-hand access to the nested text content in this block.\"\"\" return self ( \"rich_text\" ) @classmethod def __compose__ ( cls , text ): \"\"\"Compose a `TextBlock` from the given text.\"\"\" if text is None : return None obj = cls () obj . concat ( text ) return obj def concat ( self , * text ): \"\"\"Concatenate text (either `RichTextObject` or `str` items) to this block.\"\"\" nested = self () if not hasattr ( nested , \"rich_text\" ): raise AttributeError ( \"nested data does not contain text\" ) if nested . rich_text is None : nested . rich_text = [] for obj in text : if obj is None : continue self . _append_object ( obj ) def _append_object ( self , obj ): \"\"\"Append the given object to the internal text of this TextObject.\"\"\" if isinstance ( obj , RichTextObject ): self . _append_rtf ( obj ) elif isinstance ( obj , str ): self . _append_text ( obj ) else : raise ValueError ( \"unsupported text object\" ) def _append_rtf ( self , rtf ): \"\"\"Append the given RichTextObject to this TextObject.\"\"\" nested = self () nested . rich_text . append ( rtf ) def _append_text ( self , text ): \"\"\"Append the given text to this TextObject. This text will be split into chunks in accordance with the Notion API. \"\"\" nested = self () # break up the text and compose new TextObject's from the pieces for chunk in chunky ( text ): obj = TextObject [ chunk ] nested . rich_text . append ( obj ) @property def PlainText ( self ): \"\"\"Return the contents of this Block as plain text.\"\"\" content = self . __text__ return None if content is None else plain_text ( * content ) PlainText property readonly Return the contents of this Block as plain text. __text__ property readonly special Provide short-hand access to the nested text content in this block. __compose__ ( text ) classmethod special Compose a TextBlock from the given text. Source code in notional/blocks.py @classmethod def __compose__ ( cls , text ): \"\"\"Compose a `TextBlock` from the given text.\"\"\" if text is None : return None obj = cls () obj . concat ( text ) return obj concat ( self , * text ) Concatenate text (either RichTextObject or str items) to this block. Source code in notional/blocks.py def concat ( self , * text ): \"\"\"Concatenate text (either `RichTextObject` or `str` items) to this block.\"\"\" nested = self () if not hasattr ( nested , \"rich_text\" ): raise AttributeError ( \"nested data does not contain text\" ) if nested . rich_text is None : nested . rich_text = [] for obj in text : if obj is None : continue self . _append_object ( obj ) ToDo ( TextBlock , WithChildrenMixin ) pydantic-model A todo list item in Notion. Source code in notional/blocks.py class ToDo ( TextBlock , WithChildrenMixin , type = \"to_do\" ): \"\"\"A todo list item in Notion.\"\"\" class _NestedData ( NestedObject ): rich_text : List [ RichTextObject ] = [] checked : bool = False children : Optional [ List [ Block ]] = None color : FullColor = FullColor . DEFAULT to_do : _NestedData = _NestedData () @classmethod def __compose__ ( cls , text , checked = False , href = None ): \"\"\"Compose a ToDo block from the given text and checked state.\"\"\" return ToDo ( to_do = ToDo . _NestedData ( rich_text = [ TextObject [ text , href ]], checked = checked , ) ) @property def IsChecked ( self ): \"\"\"Determine if this ToDo is marked as checked or not. If the block is empty (e.g. no nested data), this method returns `None`. \"\"\" return self . to_do . checked if self . to_do else None @property def Markdown ( self ): \"\"\"Return the contents of this block as markdown text.\"\"\" if self . to_do and self . to_do . rich_text : if self . to_do . checked : return f \"- [x] { markdown ( * self . to_do . rich_text ) } \" return f \"- [ ] { markdown ( * self . to_do . rich_text ) } \" return \"\" IsChecked property readonly Determine if this ToDo is marked as checked or not. If the block is empty (e.g. no nested data), this method returns None . Markdown property readonly Return the contents of this block as markdown text. __compose__ ( text , checked = False , href = None ) classmethod special Compose a ToDo block from the given text and checked state. Source code in notional/blocks.py @classmethod def __compose__ ( cls , text , checked = False , href = None ): \"\"\"Compose a ToDo block from the given text and checked state.\"\"\" return ToDo ( to_do = ToDo . _NestedData ( rich_text = [ TextObject [ text , href ]], checked = checked , ) ) Toggle ( TextBlock , WithChildrenMixin ) pydantic-model A toggle list item in Notion. Source code in notional/blocks.py class Toggle ( TextBlock , WithChildrenMixin , type = \"toggle\" ): \"\"\"A toggle list item in Notion.\"\"\" class _NestedData ( NestedObject ): rich_text : List [ RichTextObject ] = [] children : Optional [ List [ Block ]] = None color : FullColor = FullColor . DEFAULT toggle : _NestedData = _NestedData () UnsupportedBlock ( Block ) pydantic-model A placeholder for unsupported blocks in the API. Source code in notional/blocks.py class UnsupportedBlock ( Block , type = \"unsupported\" ): \"\"\"A placeholder for unsupported blocks in the API.\"\"\" class _NestedData ( NestedObject ): pass unsupported : Optional [ _NestedData ] = None Video ( Block ) pydantic-model A video block in Notion. Source code in notional/blocks.py class Video ( Block , type = \"video\" ): \"\"\"A video block in Notion.\"\"\" video : FileObject = None WithChildrenMixin Mixin for blocks that support children blocks. Source code in notional/blocks.py class WithChildrenMixin : \"\"\"Mixin for blocks that support children blocks.\"\"\" @property def __children__ ( self ): \"\"\"Provide short-hand access to the children in this block.\"\"\" return self ( \"children\" ) def __iadd__ ( self , block ): \"\"\"Append the given block to the children of this parent in place.\"\"\" self . append ( block ) return self def append ( self , block ): \"\"\"Append the given block to the children of this parent.\"\"\" if block is None : raise ValueError ( \"block cannot be None\" ) nested = self () if not hasattr ( nested , \"children\" ): raise TypeError ( \"nested data does not contain children\" ) if nested . children is None : nested . children = [] nested . children . append ( block ) self . has_children = True __children__ property readonly special Provide short-hand access to the children in this block. __iadd__ ( self , block ) special Append the given block to the children of this parent in place. Source code in notional/blocks.py def __iadd__ ( self , block ): \"\"\"Append the given block to the children of this parent in place.\"\"\" self . append ( block ) return self append ( self , block ) Append the given block to the children of this parent. Source code in notional/blocks.py def append ( self , block ): \"\"\"Append the given block to the children of this parent.\"\"\" if block is None : raise ValueError ( \"block cannot be None\" ) nested = self () if not hasattr ( nested , \"children\" ): raise TypeError ( \"nested data does not contain children\" ) if nested . children is None : nested . children = [] nested . children . append ( block ) self . has_children = True","title":"Blocks"},{"location":"reference/blocks/#notional.blocks.Block","text":"A standard block object in Notion. Calling the block will expose the nested data in the object. Source code in notional/blocks.py class Block ( Record , TypedObject , object = \"block\" ): \"\"\"A standard block object in Notion. Calling the block will expose the nested data in the object. \"\"\"","title":"Block"},{"location":"reference/blocks/#notional.blocks.Bookmark","text":"A bookmark block in Notion. Source code in notional/blocks.py class Bookmark ( Block , type = \"bookmark\" ): \"\"\"A bookmark block in Notion.\"\"\" class _NestedData ( NestedObject ): url : str = None caption : Optional [ List [ RichTextObject ]] = None bookmark : _NestedData = _NestedData () @classmethod def __compose__ ( cls , url ): \"\"\"Compoase a new `Bookmark` block from a specific URL.\"\"\" return Bookmark ( bookmark = Bookmark . _NestedData ( url = url )) @property def URL ( self ): \"\"\"Return the URL contained in this `Bookmark` block.\"\"\" return self . bookmark . url @property def Markdown ( self ): \"\"\"Return the contents of this block as markdown text.\"\"\" if self . bookmark and self . bookmark . url : return f \"< { self . bookmark . url } >\" return \"\"","title":"Bookmark"},{"location":"reference/blocks/#notional.blocks.Bookmark.Markdown","text":"Return the contents of this block as markdown text.","title":"Markdown"},{"location":"reference/blocks/#notional.blocks.Bookmark.URL","text":"Return the URL contained in this Bookmark block.","title":"URL"},{"location":"reference/blocks/#notional.blocks.Bookmark.__compose__","text":"Compoase a new Bookmark block from a specific URL. Source code in notional/blocks.py @classmethod def __compose__ ( cls , url ): \"\"\"Compoase a new `Bookmark` block from a specific URL.\"\"\" return Bookmark ( bookmark = Bookmark . _NestedData ( url = url ))","title":"__compose__()"},{"location":"reference/blocks/#notional.blocks.Breadcrumb","text":"A breadcrumb block in Notion. Source code in notional/blocks.py class Breadcrumb ( Block , type = \"breadcrumb\" ): \"\"\"A breadcrumb block in Notion.\"\"\" class _NestedData ( NestedObject ): pass breadcrumb : _NestedData = _NestedData ()","title":"Breadcrumb"},{"location":"reference/blocks/#notional.blocks.BulletedListItem","text":"A bulleted list item in Notion. Source code in notional/blocks.py class BulletedListItem ( TextBlock , WithChildrenMixin , type = \"bulleted_list_item\" ): \"\"\"A bulleted list item in Notion.\"\"\" class _NestedData ( NestedObject ): rich_text : List [ RichTextObject ] = [] children : Optional [ List [ Block ]] = None color : FullColor = FullColor . DEFAULT bulleted_list_item : _NestedData = _NestedData () @property def Markdown ( self ): \"\"\"Return the contents of this block as markdown text.\"\"\" if self . bulleted_list_item and self . bulleted_list_item . rich_text : return f \"- { markdown ( * self . bulleted_list_item . rich_text ) } \" return \"\"","title":"BulletedListItem"},{"location":"reference/blocks/#notional.blocks.BulletedListItem.Markdown","text":"Return the contents of this block as markdown text.","title":"Markdown"},{"location":"reference/blocks/#notional.blocks.Callout","text":"A callout block in Notion. Source code in notional/blocks.py class Callout ( TextBlock , WithChildrenMixin , type = \"callout\" ): \"\"\"A callout block in Notion.\"\"\" class _NestedData ( NestedObject ): rich_text : List [ RichTextObject ] = [] children : Optional [ List [ Block ]] = None icon : Optional [ Union [ FileObject , EmojiObject ]] = None color : FullColor = FullColor . DEFAULT callout : _NestedData = _NestedData ()","title":"Callout"},{"location":"reference/blocks/#notional.blocks.ChildDatabase","text":"A child database block in Notion. Source code in notional/blocks.py class ChildDatabase ( Block , type = \"child_database\" ): \"\"\"A child database block in Notion.\"\"\" class _NestedData ( NestedObject ): title : str = None child_database : _NestedData = _NestedData ()","title":"ChildDatabase"},{"location":"reference/blocks/#notional.blocks.ChildPage","text":"A child page block in Notion. Source code in notional/blocks.py class ChildPage ( Block , type = \"child_page\" ): \"\"\"A child page block in Notion.\"\"\" class _NestedData ( NestedObject ): title : str = None child_page : _NestedData = _NestedData ()","title":"ChildPage"},{"location":"reference/blocks/#notional.blocks.Code","text":"A code block in Notion. Source code in notional/blocks.py class Code ( TextBlock , type = \"code\" ): \"\"\"A code block in Notion.\"\"\" class _NestedData ( NestedObject ): rich_text : List [ RichTextObject ] = [] caption : List [ RichTextObject ] = [] language : CodingLanguage = CodingLanguage . PLAIN_TEXT code : _NestedData = _NestedData () @classmethod def __compose__ ( cls , text , lang = CodingLanguage . PLAIN_TEXT ): \"\"\"Compose a `Code` block from the given text and language.\"\"\" return Code ( code = Code . _NestedData ( rich_text = [ TextObject [ text ]], language = lang , ) ) @property def Markdown ( self ): \"\"\"Return the contents of this block as markdown text.\"\"\" lang = self . code . language if self . code and self . code . language else \"\" # FIXME this is not the standard way to represent code blocks in markdown... if self . code and self . code . rich_text : return f \"``` { lang } \\n { markdown ( * self . code . rich_text ) } \\n ```\" return \"\"","title":"Code"},{"location":"reference/blocks/#notional.blocks.Code.Markdown","text":"Return the contents of this block as markdown text.","title":"Markdown"},{"location":"reference/blocks/#notional.blocks.Code.__compose__","text":"Compose a Code block from the given text and language. Source code in notional/blocks.py @classmethod def __compose__ ( cls , text , lang = CodingLanguage . PLAIN_TEXT ): \"\"\"Compose a `Code` block from the given text and language.\"\"\" return Code ( code = Code . _NestedData ( rich_text = [ TextObject [ text ]], language = lang , ) )","title":"__compose__()"},{"location":"reference/blocks/#notional.blocks.Column","text":"A column block in Notion. Source code in notional/blocks.py class Column ( Block , type = \"column\" ): \"\"\"A column block in Notion.\"\"\" class _NestedData ( NestedObject ): pass column : _NestedData = _NestedData ()","title":"Column"},{"location":"reference/blocks/#notional.blocks.ColumnList","text":"A column list block in Notion. Source code in notional/blocks.py class ColumnList ( Block , type = \"column_list\" ): \"\"\"A column list block in Notion.\"\"\" class _NestedData ( NestedObject ): pass column_list : _NestedData = _NestedData ()","title":"ColumnList"},{"location":"reference/blocks/#notional.blocks.Divider","text":"A divider block in Notion. Source code in notional/blocks.py class Divider ( Block , type = \"divider\" ): \"\"\"A divider block in Notion.\"\"\" divider : Any = {} @property def Markdown ( self ): \"\"\"Return the contents of this block as markdown text.\"\"\" return \"---\"","title":"Divider"},{"location":"reference/blocks/#notional.blocks.Divider.Markdown","text":"Return the contents of this block as markdown text.","title":"Markdown"},{"location":"reference/blocks/#notional.blocks.Embed","text":"An embed block in Notion. Source code in notional/blocks.py class Embed ( Block , type = \"embed\" ): \"\"\"An embed block in Notion.\"\"\" class _NestedData ( NestedObject ): url : str = None embed : _NestedData = _NestedData () @classmethod def __compose__ ( cls , url ): \"\"\"Create a new `Embed` block from the given URL.\"\"\" return Embed ( embed = Embed . _NestedData ( url = url )) @property def URL ( self ): \"\"\"Return the URL contained in this `Embed` block.\"\"\" return self . embed . url @property def Markdown ( self ): \"\"\"Return the contents of this block as markdown text.\"\"\" if self . embed and self . embed . url : return f \"< { self . embed . url } >\" return \"\"","title":"Embed"},{"location":"reference/blocks/#notional.blocks.Embed.Markdown","text":"Return the contents of this block as markdown text.","title":"Markdown"},{"location":"reference/blocks/#notional.blocks.Embed.URL","text":"Return the URL contained in this Embed block.","title":"URL"},{"location":"reference/blocks/#notional.blocks.Embed.__compose__","text":"Create a new Embed block from the given URL. Source code in notional/blocks.py @classmethod def __compose__ ( cls , url ): \"\"\"Create a new `Embed` block from the given URL.\"\"\" return Embed ( embed = Embed . _NestedData ( url = url ))","title":"__compose__()"},{"location":"reference/blocks/#notional.blocks.File","text":"A file block in Notion. Source code in notional/blocks.py class File ( Block , type = \"file\" ): \"\"\"A file block in Notion.\"\"\" file : FileObject = None","title":"File"},{"location":"reference/blocks/#notional.blocks.Heading1","text":"A heading_1 block in Notion. Source code in notional/blocks.py class Heading1 ( TextBlock , type = \"heading_1\" ): \"\"\"A heading_1 block in Notion.\"\"\" class _NestedData ( NestedObject ): rich_text : List [ RichTextObject ] = [] color : FullColor = FullColor . DEFAULT heading_1 : _NestedData = _NestedData () @property def Markdown ( self ): \"\"\"Return the contents of this block as markdown text.\"\"\" if self . heading_1 and self . heading_1 . rich_text : return f \"# { markdown ( * self . heading_1 . rich_text ) } #\" return \"\"","title":"Heading1"},{"location":"reference/blocks/#notional.blocks.Heading1.Markdown","text":"Return the contents of this block as markdown text.","title":"Markdown"},{"location":"reference/blocks/#notional.blocks.Heading2","text":"A heading_2 block in Notion. Source code in notional/blocks.py class Heading2 ( TextBlock , type = \"heading_2\" ): \"\"\"A heading_2 block in Notion.\"\"\" class _NestedData ( NestedObject ): rich_text : List [ RichTextObject ] = [] color : FullColor = FullColor . DEFAULT heading_2 : _NestedData = _NestedData () @property def Markdown ( self ): \"\"\"Return the contents of this block as markdown text.\"\"\" if self . heading_2 and self . heading_2 . rich_text : return f \"## { markdown ( * self . heading_2 . rich_text ) } ##\" return \"\"","title":"Heading2"},{"location":"reference/blocks/#notional.blocks.Heading2.Markdown","text":"Return the contents of this block as markdown text.","title":"Markdown"},{"location":"reference/blocks/#notional.blocks.Heading3","text":"A heading_3 block in Notion. Source code in notional/blocks.py class Heading3 ( TextBlock , type = \"heading_3\" ): \"\"\"A heading_3 block in Notion.\"\"\" class _NestedData ( NestedObject ): rich_text : List [ RichTextObject ] = [] color : FullColor = FullColor . DEFAULT heading_3 : _NestedData = _NestedData () @property def Markdown ( self ): \"\"\"Return the contents of this block as markdown text.\"\"\" if self . heading_3 and self . heading_3 . rich_text : return f \"### { markdown ( * self . heading_3 . rich_text ) } ###\" return \"\"","title":"Heading3"},{"location":"reference/blocks/#notional.blocks.Heading3.Markdown","text":"Return the contents of this block as markdown text.","title":"Markdown"},{"location":"reference/blocks/#notional.blocks.Image","text":"An image block in Notion. Source code in notional/blocks.py class Image ( Block , type = \"image\" ): \"\"\"An image block in Notion.\"\"\" image : FileObject = None","title":"Image"},{"location":"reference/blocks/#notional.blocks.LinkPreview","text":"A link_preview block in Notion. Source code in notional/blocks.py class LinkPreview ( Block , type = \"link_preview\" ): \"\"\"A link_preview block in Notion.\"\"\" class _NestedData ( NestedObject ): url : str = None link_preview : _NestedData = _NestedData () @classmethod def __compose__ ( cls , url ): \"\"\"Create a new `LinkPreview` block from the given URL.\"\"\" return LinkPreview ( link_preview = LinkPreview . _NestedData ( url = url )) @property def URL ( self ): \"\"\"Return the URL contained in this `LinkPreview` block.\"\"\" return self . link_preview . url @property def Markdown ( self ): \"\"\"Return the contents of this block as markdown text.\"\"\" if self . link_preview and self . link_preview . url : return f \"< { self . link_preview . url } >\" return \"\"","title":"LinkPreview"},{"location":"reference/blocks/#notional.blocks.LinkPreview.Markdown","text":"Return the contents of this block as markdown text.","title":"Markdown"},{"location":"reference/blocks/#notional.blocks.LinkPreview.URL","text":"Return the URL contained in this LinkPreview block.","title":"URL"},{"location":"reference/blocks/#notional.blocks.LinkPreview.__compose__","text":"Create a new LinkPreview block from the given URL. Source code in notional/blocks.py @classmethod def __compose__ ( cls , url ): \"\"\"Create a new `LinkPreview` block from the given URL.\"\"\" return LinkPreview ( link_preview = LinkPreview . _NestedData ( url = url ))","title":"__compose__()"},{"location":"reference/blocks/#notional.blocks.LinkToPage","text":"A link_to_page block in Notion. Source code in notional/blocks.py class LinkToPage ( Block , type = \"link_to_page\" ): \"\"\"A link_to_page block in Notion.\"\"\" link_to_page : ParentRef","title":"LinkToPage"},{"location":"reference/blocks/#notional.blocks.NumberedListItem","text":"A numbered list item in Notion. Source code in notional/blocks.py class NumberedListItem ( TextBlock , WithChildrenMixin , type = \"numbered_list_item\" ): \"\"\"A numbered list item in Notion.\"\"\" class _NestedData ( NestedObject ): rich_text : List [ RichTextObject ] = [] children : Optional [ List [ Block ]] = None color : FullColor = FullColor . DEFAULT numbered_list_item : _NestedData = _NestedData () @property def Markdown ( self ): \"\"\"Return the contents of this block as markdown text.\"\"\" if self . numbered_list_item and self . numbered_list_item . rich_text : return f \"1. { markdown ( * self . numbered_list_item . rich_text ) } \" return \"\"","title":"NumberedListItem"},{"location":"reference/blocks/#notional.blocks.NumberedListItem.Markdown","text":"Return the contents of this block as markdown text.","title":"Markdown"},{"location":"reference/blocks/#notional.blocks.PDF","text":"A pdf block in Notion. Source code in notional/blocks.py class PDF ( Block , type = \"pdf\" ): \"\"\"A pdf block in Notion.\"\"\" pdf : FileObject = None","title":"PDF"},{"location":"reference/blocks/#notional.blocks.Paragraph","text":"A paragraph block in Notion. Source code in notional/blocks.py class Paragraph ( TextBlock , WithChildrenMixin , type = \"paragraph\" ): \"\"\"A paragraph block in Notion.\"\"\" class _NestedData ( NestedObject ): rich_text : List [ RichTextObject ] = [] children : Optional [ List [ Block ]] = None color : FullColor = FullColor . DEFAULT paragraph : _NestedData = _NestedData () @property def Markdown ( self ): \"\"\"Return the contents of this block as markdown text.\"\"\" if self . paragraph and self . paragraph . rich_text : return markdown ( * self . paragraph . rich_text ) return \"\"","title":"Paragraph"},{"location":"reference/blocks/#notional.blocks.Paragraph.Markdown","text":"Return the contents of this block as markdown text.","title":"Markdown"},{"location":"reference/blocks/#notional.blocks.Quote","text":"A quote block in Notion. Source code in notional/blocks.py class Quote ( TextBlock , WithChildrenMixin , type = \"quote\" ): \"\"\"A quote block in Notion.\"\"\" class _NestedData ( NestedObject ): rich_text : List [ RichTextObject ] = [] children : Optional [ List [ Block ]] = None color : FullColor = FullColor . DEFAULT quote : _NestedData = _NestedData () @property def Markdown ( self ): \"\"\"Return the contents of this block as markdown text.\"\"\" if self . quote and self . quote . rich_text : return \"> \" + markdown ( * self . quote . rich_text ) return \"\"","title":"Quote"},{"location":"reference/blocks/#notional.blocks.Quote.Markdown","text":"Return the contents of this block as markdown text.","title":"Markdown"},{"location":"reference/blocks/#notional.blocks.SyncedBlock","text":"A synced_block block in Notion - either original or synced. Source code in notional/blocks.py class SyncedBlock ( Block , WithChildrenMixin , type = \"synced_block\" ): \"\"\"A synced_block block in Notion - either original or synced.\"\"\" class _NestedData ( NestedObject ): synced_from : Optional [ BlockRef ] = None children : Optional [ List [ Block ]] = None synced_block : _NestedData = _NestedData () @property def IsOriginal ( self ): \"\"\"Determine if this block represents the original content. If this method returns `False`, the block represents the sync'ed block. \"\"\" return self . synced_block . synced_from is None","title":"SyncedBlock"},{"location":"reference/blocks/#notional.blocks.SyncedBlock.IsOriginal","text":"Determine if this block represents the original content. If this method returns False , the block represents the sync'ed block.","title":"IsOriginal"},{"location":"reference/blocks/#notional.blocks.Table","text":"A table block in Notion. Source code in notional/blocks.py class Table ( Block , WithChildrenMixin , type = \"table\" ): \"\"\"A table block in Notion.\"\"\" class _NestedData ( NestedObject ): table_width : int = 0 has_column_header : bool = False has_row_header : bool = False # note that children will not be populated when getting this block # https://developers.notion.com/reference/block#table-blocks children : Optional [ List [ TableRow ]] = [] table : _NestedData = _NestedData () def append ( self , block : TableRow ): \"\"\"Append the given row to this table. This method is only applicable when creating a new `Table` block. In order to add rows to an existing `Table`, use the `blocks.children.append()` endpoint. When adding a row, this method will rase an exception if the width does not match the expected number of cells for existing rows in the block. \"\"\" # XXX need to review whether this is applicable during update... may need # to raise an error if the block has already been created on the server if not isinstance ( block , TableRow ): raise ValueError ( \"Only TableRow may be appended to Table blocks.\" ) if self . Width == 0 : self . table . table_width = block . Width elif self . Width != block . Width : raise ValueError ( \"Number of cells in row must match table\" ) self . table . children . append ( block ) @property def Width ( self ): \"\"\"Return the current width of this table.\"\"\" return self . table . table_width","title":"Table"},{"location":"reference/blocks/#notional.blocks.Table.Width","text":"Return the current width of this table.","title":"Width"},{"location":"reference/blocks/#notional.blocks.Table.append","text":"Append the given row to this table. This method is only applicable when creating a new Table block. In order to add rows to an existing Table , use the blocks.children.append() endpoint. When adding a row, this method will rase an exception if the width does not match the expected number of cells for existing rows in the block. Source code in notional/blocks.py def append ( self , block : TableRow ): \"\"\"Append the given row to this table. This method is only applicable when creating a new `Table` block. In order to add rows to an existing `Table`, use the `blocks.children.append()` endpoint. When adding a row, this method will rase an exception if the width does not match the expected number of cells for existing rows in the block. \"\"\" # XXX need to review whether this is applicable during update... may need # to raise an error if the block has already been created on the server if not isinstance ( block , TableRow ): raise ValueError ( \"Only TableRow may be appended to Table blocks.\" ) if self . Width == 0 : self . table . table_width = block . Width elif self . Width != block . Width : raise ValueError ( \"Number of cells in row must match table\" ) self . table . children . append ( block )","title":"append()"},{"location":"reference/blocks/#notional.blocks.TableOfContents","text":"A table_of_contents block in Notion. Source code in notional/blocks.py class TableOfContents ( Block , type = \"table_of_contents\" ): \"\"\"A table_of_contents block in Notion.\"\"\" class _NestedData ( NestedObject ): color : FullColor = FullColor . DEFAULT table_of_contents : _NestedData = _NestedData ()","title":"TableOfContents"},{"location":"reference/blocks/#notional.blocks.TableRow","text":"A table_row block in Notion. Source code in notional/blocks.py class TableRow ( Block , type = \"table_row\" ): \"\"\"A table_row block in Notion.\"\"\" class _NestedData ( NestedObject ): cells : List [ List [ RichTextObject ]] = None table_row : _NestedData = _NestedData () def append ( self , text ): \"\"\"Append the given text as a new cell in this `TableRow`. `text` may be a string, `RichTextObject` or a list of `RichTextObject`'s. :param text: the text content to append \"\"\" if self . table_row . cells is None : self . table_row . cells = [] if isinstance ( text , list ): self . table_row . cells . append ( list ) elif isinstance ( text , RichTextObject ): self . table_row . cells . append ([ text ]) else : rtf = TextObject . from_value ( text ) self . table_row . cells . append ([ rtf ]) @property def Width ( self ): \"\"\"Return the width (number of cells) in this `TableRow`.\"\"\" return len ( self . table_row . cells ) if self . table_row . cells else 0","title":"TableRow"},{"location":"reference/blocks/#notional.blocks.TableRow.Width","text":"Return the width (number of cells) in this TableRow .","title":"Width"},{"location":"reference/blocks/#notional.blocks.TableRow.append","text":"Append the given text as a new cell in this TableRow . text may be a string, RichTextObject or a list of RichTextObject 's. :param text: the text content to append Source code in notional/blocks.py def append ( self , text ): \"\"\"Append the given text as a new cell in this `TableRow`. `text` may be a string, `RichTextObject` or a list of `RichTextObject`'s. :param text: the text content to append \"\"\" if self . table_row . cells is None : self . table_row . cells = [] if isinstance ( text , list ): self . table_row . cells . append ( list ) elif isinstance ( text , RichTextObject ): self . table_row . cells . append ([ text ]) else : rtf = TextObject . from_value ( text ) self . table_row . cells . append ([ rtf ])","title":"append()"},{"location":"reference/blocks/#notional.blocks.Template","text":"A template block in Notion. Source code in notional/blocks.py class Template ( Block , WithChildrenMixin , type = \"template\" ): \"\"\"A template block in Notion.\"\"\" class _NestedData ( NestedObject ): rich_text : Optional [ List [ RichTextObject ]] = None children : Optional [ List [ Block ]] = None template : _NestedData = _NestedData ()","title":"Template"},{"location":"reference/blocks/#notional.blocks.TextBlock","text":"A standard text block object in Notion. Source code in notional/blocks.py class TextBlock ( Block , ABC ): \"\"\"A standard text block object in Notion.\"\"\" # text blocks have a nested object with 'type' name and a 'text' child @property def __text__ ( self ): \"\"\"Provide short-hand access to the nested text content in this block.\"\"\" return self ( \"rich_text\" ) @classmethod def __compose__ ( cls , text ): \"\"\"Compose a `TextBlock` from the given text.\"\"\" if text is None : return None obj = cls () obj . concat ( text ) return obj def concat ( self , * text ): \"\"\"Concatenate text (either `RichTextObject` or `str` items) to this block.\"\"\" nested = self () if not hasattr ( nested , \"rich_text\" ): raise AttributeError ( \"nested data does not contain text\" ) if nested . rich_text is None : nested . rich_text = [] for obj in text : if obj is None : continue self . _append_object ( obj ) def _append_object ( self , obj ): \"\"\"Append the given object to the internal text of this TextObject.\"\"\" if isinstance ( obj , RichTextObject ): self . _append_rtf ( obj ) elif isinstance ( obj , str ): self . _append_text ( obj ) else : raise ValueError ( \"unsupported text object\" ) def _append_rtf ( self , rtf ): \"\"\"Append the given RichTextObject to this TextObject.\"\"\" nested = self () nested . rich_text . append ( rtf ) def _append_text ( self , text ): \"\"\"Append the given text to this TextObject. This text will be split into chunks in accordance with the Notion API. \"\"\" nested = self () # break up the text and compose new TextObject's from the pieces for chunk in chunky ( text ): obj = TextObject [ chunk ] nested . rich_text . append ( obj ) @property def PlainText ( self ): \"\"\"Return the contents of this Block as plain text.\"\"\" content = self . __text__ return None if content is None else plain_text ( * content )","title":"TextBlock"},{"location":"reference/blocks/#notional.blocks.TextBlock.PlainText","text":"Return the contents of this Block as plain text.","title":"PlainText"},{"location":"reference/blocks/#notional.blocks.TextBlock.__text__","text":"Provide short-hand access to the nested text content in this block.","title":"__text__"},{"location":"reference/blocks/#notional.blocks.TextBlock.__compose__","text":"Compose a TextBlock from the given text. Source code in notional/blocks.py @classmethod def __compose__ ( cls , text ): \"\"\"Compose a `TextBlock` from the given text.\"\"\" if text is None : return None obj = cls () obj . concat ( text ) return obj","title":"__compose__()"},{"location":"reference/blocks/#notional.blocks.TextBlock.concat","text":"Concatenate text (either RichTextObject or str items) to this block. Source code in notional/blocks.py def concat ( self , * text ): \"\"\"Concatenate text (either `RichTextObject` or `str` items) to this block.\"\"\" nested = self () if not hasattr ( nested , \"rich_text\" ): raise AttributeError ( \"nested data does not contain text\" ) if nested . rich_text is None : nested . rich_text = [] for obj in text : if obj is None : continue self . _append_object ( obj )","title":"concat()"},{"location":"reference/blocks/#notional.blocks.ToDo","text":"A todo list item in Notion. Source code in notional/blocks.py class ToDo ( TextBlock , WithChildrenMixin , type = \"to_do\" ): \"\"\"A todo list item in Notion.\"\"\" class _NestedData ( NestedObject ): rich_text : List [ RichTextObject ] = [] checked : bool = False children : Optional [ List [ Block ]] = None color : FullColor = FullColor . DEFAULT to_do : _NestedData = _NestedData () @classmethod def __compose__ ( cls , text , checked = False , href = None ): \"\"\"Compose a ToDo block from the given text and checked state.\"\"\" return ToDo ( to_do = ToDo . _NestedData ( rich_text = [ TextObject [ text , href ]], checked = checked , ) ) @property def IsChecked ( self ): \"\"\"Determine if this ToDo is marked as checked or not. If the block is empty (e.g. no nested data), this method returns `None`. \"\"\" return self . to_do . checked if self . to_do else None @property def Markdown ( self ): \"\"\"Return the contents of this block as markdown text.\"\"\" if self . to_do and self . to_do . rich_text : if self . to_do . checked : return f \"- [x] { markdown ( * self . to_do . rich_text ) } \" return f \"- [ ] { markdown ( * self . to_do . rich_text ) } \" return \"\"","title":"ToDo"},{"location":"reference/blocks/#notional.blocks.ToDo.IsChecked","text":"Determine if this ToDo is marked as checked or not. If the block is empty (e.g. no nested data), this method returns None .","title":"IsChecked"},{"location":"reference/blocks/#notional.blocks.ToDo.Markdown","text":"Return the contents of this block as markdown text.","title":"Markdown"},{"location":"reference/blocks/#notional.blocks.ToDo.__compose__","text":"Compose a ToDo block from the given text and checked state. Source code in notional/blocks.py @classmethod def __compose__ ( cls , text , checked = False , href = None ): \"\"\"Compose a ToDo block from the given text and checked state.\"\"\" return ToDo ( to_do = ToDo . _NestedData ( rich_text = [ TextObject [ text , href ]], checked = checked , ) )","title":"__compose__()"},{"location":"reference/blocks/#notional.blocks.Toggle","text":"A toggle list item in Notion. Source code in notional/blocks.py class Toggle ( TextBlock , WithChildrenMixin , type = \"toggle\" ): \"\"\"A toggle list item in Notion.\"\"\" class _NestedData ( NestedObject ): rich_text : List [ RichTextObject ] = [] children : Optional [ List [ Block ]] = None color : FullColor = FullColor . DEFAULT toggle : _NestedData = _NestedData ()","title":"Toggle"},{"location":"reference/blocks/#notional.blocks.UnsupportedBlock","text":"A placeholder for unsupported blocks in the API. Source code in notional/blocks.py class UnsupportedBlock ( Block , type = \"unsupported\" ): \"\"\"A placeholder for unsupported blocks in the API.\"\"\" class _NestedData ( NestedObject ): pass unsupported : Optional [ _NestedData ] = None","title":"UnsupportedBlock"},{"location":"reference/blocks/#notional.blocks.Video","text":"A video block in Notion. Source code in notional/blocks.py class Video ( Block , type = \"video\" ): \"\"\"A video block in Notion.\"\"\" video : FileObject = None","title":"Video"},{"location":"reference/blocks/#notional.blocks.WithChildrenMixin","text":"Mixin for blocks that support children blocks. Source code in notional/blocks.py class WithChildrenMixin : \"\"\"Mixin for blocks that support children blocks.\"\"\" @property def __children__ ( self ): \"\"\"Provide short-hand access to the children in this block.\"\"\" return self ( \"children\" ) def __iadd__ ( self , block ): \"\"\"Append the given block to the children of this parent in place.\"\"\" self . append ( block ) return self def append ( self , block ): \"\"\"Append the given block to the children of this parent.\"\"\" if block is None : raise ValueError ( \"block cannot be None\" ) nested = self () if not hasattr ( nested , \"children\" ): raise TypeError ( \"nested data does not contain children\" ) if nested . children is None : nested . children = [] nested . children . append ( block ) self . has_children = True","title":"WithChildrenMixin"},{"location":"reference/blocks/#notional.blocks.WithChildrenMixin.__children__","text":"Provide short-hand access to the children in this block.","title":"__children__"},{"location":"reference/blocks/#notional.blocks.WithChildrenMixin.__iadd__","text":"Append the given block to the children of this parent in place. Source code in notional/blocks.py def __iadd__ ( self , block ): \"\"\"Append the given block to the children of this parent in place.\"\"\" self . append ( block ) return self","title":"__iadd__()"},{"location":"reference/blocks/#notional.blocks.WithChildrenMixin.append","text":"Append the given block to the children of this parent. Source code in notional/blocks.py def append ( self , block ): \"\"\"Append the given block to the children of this parent.\"\"\" if block is None : raise ValueError ( \"block cannot be None\" ) nested = self () if not hasattr ( nested , \"children\" ): raise TypeError ( \"nested data does not contain children\" ) if nested . children is None : nested . children = [] nested . children . append ( block ) self . has_children = True","title":"append()"},{"location":"reference/core/","text":"Base classes for working with the Notion API. ComposableObject ( ModelMetaclass ) Presents a meta class that composes objects using simple values. This is primarily to allow easy definition of data objects without disrupting the BaseModel constructor. e.g. rather than requiring a caller to understand how nested data works in the data objects, they can compose objects from simple values. Compare the following code for declaring a Paragraph: # using nested data objects: text = \"hello world\" nested = TextObject . _NestedData ( content = text ) rtf = text . TextObject ( text = nested , plain_text = text ) content = blocks . Paragraph . _NestedData ( text = [ rtf ]) para = blocks . Paragraph ( paragraph = content ) # using a composable object: para = blocks . Paragraph [ \"hello world\" ] Classes that support composition in this way must define and implement the internal __compose__ method. This method takes an arbitrary number of parameters, based on the needs of the implementation. It is up to the implementing class to ensure that the parameters are specificied correctly. Source code in notional/core.py class ComposableObject ( ModelMetaclass ): \"\"\"Presents a meta class that composes objects using simple values. This is primarily to allow easy definition of data objects without disrupting the `BaseModel` constructor. e.g. rather than requiring a caller to understand how nested data works in the data objects, they can compose objects from simple values. Compare the following code for declaring a Paragraph: ```python # using nested data objects: text = \"hello world\" nested = TextObject._NestedData(content=text) rtf = text.TextObject(text=nested, plain_text=text) content = blocks.Paragraph._NestedData(text=[rtf]) para = blocks.Paragraph(paragraph=content) # using a composable object: para = blocks.Paragraph[\"hello world\"] ``` Classes that support composition in this way must define and implement the internal `__compose__` method. This method takes an arbitrary number of parameters, based on the needs of the implementation. It is up to the implementing class to ensure that the parameters are specificied correctly. \"\"\" def __getitem__ ( self , params ): \"\"\"Return the requested class by composing using the given param. Types found in `params` will be compared to expected types in the `__compose__` method. If the requested class does not expose the `__compose__` method, this will raise an exception. \"\"\" if not hasattr ( self , \"__compose__\" ): raise NotImplementedError ( f \" { self } does not support object composition\" ) # XXX if params is empty / None, consider calling the default constructor compose = self . __compose__ if type ( params ) is tuple : return compose ( * params ) return compose ( params ) __getitem__ ( self , params ) special Return the requested class by composing using the given param. Types found in params will be compared to expected types in the __compose__ method. If the requested class does not expose the __compose__ method, this will raise an exception. Source code in notional/core.py def __getitem__ ( self , params ): \"\"\"Return the requested class by composing using the given param. Types found in `params` will be compared to expected types in the `__compose__` method. If the requested class does not expose the `__compose__` method, this will raise an exception. \"\"\" if not hasattr ( self , \"__compose__\" ): raise NotImplementedError ( f \" { self } does not support object composition\" ) # XXX if params is empty / None, consider calling the default constructor compose = self . __compose__ if type ( params ) is tuple : return compose ( * params ) return compose ( params ) DataObject ( BaseModel ) pydantic-model The base for all API objects. Source code in notional/core.py class DataObject ( BaseModel , metaclass = ComposableObject ): \"\"\"The base for all API objects.\"\"\" def __setattr__ ( self , name , value ): \"\"\"Set the attribute of this object to a given value. The implementation of `BaseModel.__setattr__` does not allow for properties. See https://github.com/samuelcolvin/pydantic/issues/1577 \"\"\" try : super () . __setattr__ ( name , value ) except ValueError as err : setters = inspect . getmembers ( self . __class__ , predicate = lambda x : isinstance ( x , property ) and x . fset is not None , ) for setter_name , _ in setters : if setter_name == name : object . __setattr__ ( self , name , value ) break else : raise err @classmethod def _modify_field_ ( cls , name , default = None ): \"\"\"Modify the `BaseModel` field information for a specific class instance. This is necessary in particular for sublcasses that change the default values of a model when defined. Notable examples are `TypedObject` and `NamedObject`. :param name: the named attribute in the class :param default: the new default for the named field \"\"\" setattr ( cls , name , default ) cls . __fields__ [ name ] . default = default cls . __fields__ [ name ] . required = default is None # https://github.com/samuelcolvin/pydantic/discussions/3139 def refresh ( __pydantic_self__ , ** data ): \"\"\"Refresh the internal attributes with new data.\"\"\" values , fields , error = validate_model ( __pydantic_self__ . __class__ , data ) if error : raise error for name in fields : value = values [ name ] log . debug ( \"set object data -- %s => %s \" , name , value ) setattr ( __pydantic_self__ , name , value ) return __pydantic_self__ def to_api ( self ): \"\"\"Convert to a suitable representation for the Notion API.\"\"\" # the API doesn't like \"undefined\" values... data = self . dict ( exclude_none = True , by_alias = True ) # we need to convert \"special\" types to string forms to help the JSON encoder. # there are efforts underway in pydantic to make this easier, but for now... return make_api_safe ( data ) __setattr__ ( self , name , value ) special Set the attribute of this object to a given value. The implementation of BaseModel.__setattr__ does not allow for properties. See https://github.com/samuelcolvin/pydantic/issues/1577 Source code in notional/core.py def __setattr__ ( self , name , value ): \"\"\"Set the attribute of this object to a given value. The implementation of `BaseModel.__setattr__` does not allow for properties. See https://github.com/samuelcolvin/pydantic/issues/1577 \"\"\" try : super () . __setattr__ ( name , value ) except ValueError as err : setters = inspect . getmembers ( self . __class__ , predicate = lambda x : isinstance ( x , property ) and x . fset is not None , ) for setter_name , _ in setters : if setter_name == name : object . __setattr__ ( self , name , value ) break else : raise err refresh ( __pydantic_self__ , ** data ) Refresh the internal attributes with new data. Source code in notional/core.py def refresh ( __pydantic_self__ , ** data ): \"\"\"Refresh the internal attributes with new data.\"\"\" values , fields , error = validate_model ( __pydantic_self__ . __class__ , data ) if error : raise error for name in fields : value = values [ name ] log . debug ( \"set object data -- %s => %s \" , name , value ) setattr ( __pydantic_self__ , name , value ) return __pydantic_self__ to_api ( self ) Convert to a suitable representation for the Notion API. Source code in notional/core.py def to_api ( self ): \"\"\"Convert to a suitable representation for the Notion API.\"\"\" # the API doesn't like \"undefined\" values... data = self . dict ( exclude_none = True , by_alias = True ) # we need to convert \"special\" types to string forms to help the JSON encoder. # there are efforts underway in pydantic to make this easier, but for now... return make_api_safe ( data ) NamedObject ( DataObject ) pydantic-model A Notion API object. Source code in notional/core.py class NamedObject ( DataObject ): \"\"\"A Notion API object.\"\"\" # XXX should NamedObject have the same typing ability as TypedObject? object : str def __init_subclass__ ( cls , object = None , ** kwargs ): \"\"\"Update `DataObject` defaults for the named object.\"\"\" super () . __init_subclass__ ( ** kwargs ) if object is not None : cls . _modify_field_ ( \"object\" , default = object ) __init_subclass__ ( object = None , ** kwargs ) classmethod special Update DataObject defaults for the named object. Source code in notional/core.py def __init_subclass__ ( cls , object = None , ** kwargs ): \"\"\"Update `DataObject` defaults for the named object.\"\"\" super () . __init_subclass__ ( ** kwargs ) if object is not None : cls . _modify_field_ ( \"object\" , default = object ) NestedObject ( DataObject ) pydantic-model Represents an API object with nested data. These objects require a 'type' property and a matching property of the same name, which holds additional data. For example, this contains a nested 'text' object: data = { type: \"text\", ... !!! text \"{\" ... } } Currently, this is a convenience class for clarity - it does not provide additional functionality at this time. Source code in notional/core.py class NestedObject ( DataObject ): \"\"\"Represents an API object with nested data. These objects require a 'type' property and a matching property of the same name, which holds additional data. For example, this contains a nested 'text' object: data = { type: \"text\", ... text: { ... } } Currently, this is a convenience class for clarity - it does not provide additional functionality at this time. \"\"\" TypedObject ( DataObject ) pydantic-model A type-referenced object. Many objects in the Notion API follow a generic->specific pattern with a 'type' parameter followed by additional data. These objects must specify a type attribute to ensure that the correct object is created. Calling the object provides direct access to the data stored in {type} . Source code in notional/core.py class TypedObject ( DataObject ): \"\"\"A type-referenced object. Many objects in the Notion API follow a generic->specific pattern with a 'type' parameter followed by additional data. These objects must specify a `type` attribute to ensure that the correct object is created. Calling the object provides direct access to the data stored in `{type}`. \"\"\" type : str # modified from the methods described in this discussion: # - https://github.com/samuelcolvin/pydantic/discussions/3091 def __init_subclass__ ( cls , type = None , ** kwargs ): \"\"\"Register the subtypes of the TypedObject subclass.\"\"\" super () . __init_subclass__ ( ** kwargs ) if type is not None : sub_type = type elif hasattr ( cls , \"__type__\" ): sub_type = cls . __type__ else : sub_type = cls . __name__ cls . _modify_field_ ( \"type\" , default = sub_type ) # initialize a __typemap__ map for each direct child of TypedObject # this allows different class trees to have the same 'type' name # but point to a different object (e.g. the 'date' type may have # different implementations depending where it is used in the API) # also, due to the order in which typed classes are defined, once # the map is defined for a subclass of TypedObject, any further # descendants of that class will have the new map via inheritance if TypedObject in cls . __bases__ and not hasattr ( cls , \"__typemap__\" ): cls . __typemap__ = {} if sub_type in cls . __typemap__ : raise ValueError ( f \"Duplicate subtype for class - { sub_type } :: { cls } \" ) log . debug ( \"registered new subtype: %s => %s \" , sub_type , cls ) cls . __typemap__ [ sub_type ] = cls def __call__ ( self , field = None ): \"\"\"Return nested data from this Block. If a field is provided, the contents of that field in the NestedData will be returned. Otherwise, the full contents of the NestedData will be returned. \"\"\" type = getattr ( self , \"type\" , None ) if type is None : raise AttributeError ( \"type not specified\" ) nested = getattr ( self , type ) if field is not None : nested = getattr ( nested , field ) return nested @classmethod def __get_validators__ ( cls ): \"\"\"Provide `BaseModel` with the means to convert `TypedObject`'s.\"\"\" yield cls . _convert_to_real_type_ @classmethod def parse_obj ( cls , obj ): \"\"\"Parse the structured object data into an instance of `TypedObject`. This method overrides `BaseModel.parse_obj()`. \"\"\" return cls . _convert_to_real_type_ ( obj ) @classmethod def _convert_to_real_type_ ( cls , data ): \"\"\"Instantiate the correct object based on the 'type' field.\"\"\" if isinstance ( data , cls ): return data if not isinstance ( data , dict ): raise ValueError ( \"Invalid 'data' object\" ) data_type = data . get ( \"type\" ) if data_type is None : raise ValueError ( \"Missing 'type' in TypedObject\" ) if not hasattr ( cls , \"__typemap__\" ): raise TypeError ( f \"Invalid TypedObject: { cls } - missing __typemap__\" ) sub = cls . __typemap__ . get ( data_type ) if sub is None : raise TypeError ( f \"Unsupport sub-type: { data_type } \" ) log . debug ( \"initializing typed object %s :: %s => %s -- %s \" , cls , data_type , sub , data ) return sub ( ** data ) __call__ ( self , field = None ) special Return nested data from this Block. If a field is provided, the contents of that field in the NestedData will be returned. Otherwise, the full contents of the NestedData will be returned. Source code in notional/core.py def __call__ ( self , field = None ): \"\"\"Return nested data from this Block. If a field is provided, the contents of that field in the NestedData will be returned. Otherwise, the full contents of the NestedData will be returned. \"\"\" type = getattr ( self , \"type\" , None ) if type is None : raise AttributeError ( \"type not specified\" ) nested = getattr ( self , type ) if field is not None : nested = getattr ( nested , field ) return nested __get_validators__ () classmethod special Provide BaseModel with the means to convert TypedObject 's. Source code in notional/core.py @classmethod def __get_validators__ ( cls ): \"\"\"Provide `BaseModel` with the means to convert `TypedObject`'s.\"\"\" yield cls . _convert_to_real_type_ __init_subclass__ ( type = None , ** kwargs ) classmethod special Register the subtypes of the TypedObject subclass. Source code in notional/core.py def __init_subclass__ ( cls , type = None , ** kwargs ): \"\"\"Register the subtypes of the TypedObject subclass.\"\"\" super () . __init_subclass__ ( ** kwargs ) if type is not None : sub_type = type elif hasattr ( cls , \"__type__\" ): sub_type = cls . __type__ else : sub_type = cls . __name__ cls . _modify_field_ ( \"type\" , default = sub_type ) # initialize a __typemap__ map for each direct child of TypedObject # this allows different class trees to have the same 'type' name # but point to a different object (e.g. the 'date' type may have # different implementations depending where it is used in the API) # also, due to the order in which typed classes are defined, once # the map is defined for a subclass of TypedObject, any further # descendants of that class will have the new map via inheritance if TypedObject in cls . __bases__ and not hasattr ( cls , \"__typemap__\" ): cls . __typemap__ = {} if sub_type in cls . __typemap__ : raise ValueError ( f \"Duplicate subtype for class - { sub_type } :: { cls } \" ) log . debug ( \"registered new subtype: %s => %s \" , sub_type , cls ) cls . __typemap__ [ sub_type ] = cls parse_obj ( obj ) classmethod Parse the structured object data into an instance of TypedObject . This method overrides BaseModel.parse_obj() . Source code in notional/core.py @classmethod def parse_obj ( cls , obj ): \"\"\"Parse the structured object data into an instance of `TypedObject`. This method overrides `BaseModel.parse_obj()`. \"\"\" return cls . _convert_to_real_type_ ( obj ) make_api_safe ( data ) Recursively convert the given data to an API-safe form. This is mostly to handle data types that will not directly serialize to JSON. Source code in notional/core.py def make_api_safe ( data ): \"\"\"Recursively convert the given data to an API-safe form. This is mostly to handle data types that will not directly serialize to JSON. \"\"\" # https://github.com/samuelcolvin/pydantic/issues/1409#issuecomment-877175194 if isinstance ( data , ( date , datetime )): return data . isoformat () if isinstance ( data , UUID ): return str ( data ) if isinstance ( data , Enum ): return data . value if isinstance ( data , dict ): return { name : make_api_safe ( value ) for name , value in data . items ()} if isinstance ( data , list ): return [ make_api_safe ( value ) for value in data ] if isinstance ( data , tuple ): return [ make_api_safe ( value ) for value in data ] return data","title":"Core"},{"location":"reference/core/#notional.core.ComposableObject","text":"Presents a meta class that composes objects using simple values. This is primarily to allow easy definition of data objects without disrupting the BaseModel constructor. e.g. rather than requiring a caller to understand how nested data works in the data objects, they can compose objects from simple values. Compare the following code for declaring a Paragraph: # using nested data objects: text = \"hello world\" nested = TextObject . _NestedData ( content = text ) rtf = text . TextObject ( text = nested , plain_text = text ) content = blocks . Paragraph . _NestedData ( text = [ rtf ]) para = blocks . Paragraph ( paragraph = content ) # using a composable object: para = blocks . Paragraph [ \"hello world\" ] Classes that support composition in this way must define and implement the internal __compose__ method. This method takes an arbitrary number of parameters, based on the needs of the implementation. It is up to the implementing class to ensure that the parameters are specificied correctly. Source code in notional/core.py class ComposableObject ( ModelMetaclass ): \"\"\"Presents a meta class that composes objects using simple values. This is primarily to allow easy definition of data objects without disrupting the `BaseModel` constructor. e.g. rather than requiring a caller to understand how nested data works in the data objects, they can compose objects from simple values. Compare the following code for declaring a Paragraph: ```python # using nested data objects: text = \"hello world\" nested = TextObject._NestedData(content=text) rtf = text.TextObject(text=nested, plain_text=text) content = blocks.Paragraph._NestedData(text=[rtf]) para = blocks.Paragraph(paragraph=content) # using a composable object: para = blocks.Paragraph[\"hello world\"] ``` Classes that support composition in this way must define and implement the internal `__compose__` method. This method takes an arbitrary number of parameters, based on the needs of the implementation. It is up to the implementing class to ensure that the parameters are specificied correctly. \"\"\" def __getitem__ ( self , params ): \"\"\"Return the requested class by composing using the given param. Types found in `params` will be compared to expected types in the `__compose__` method. If the requested class does not expose the `__compose__` method, this will raise an exception. \"\"\" if not hasattr ( self , \"__compose__\" ): raise NotImplementedError ( f \" { self } does not support object composition\" ) # XXX if params is empty / None, consider calling the default constructor compose = self . __compose__ if type ( params ) is tuple : return compose ( * params ) return compose ( params )","title":"ComposableObject"},{"location":"reference/core/#notional.core.ComposableObject.__getitem__","text":"Return the requested class by composing using the given param. Types found in params will be compared to expected types in the __compose__ method. If the requested class does not expose the __compose__ method, this will raise an exception. Source code in notional/core.py def __getitem__ ( self , params ): \"\"\"Return the requested class by composing using the given param. Types found in `params` will be compared to expected types in the `__compose__` method. If the requested class does not expose the `__compose__` method, this will raise an exception. \"\"\" if not hasattr ( self , \"__compose__\" ): raise NotImplementedError ( f \" { self } does not support object composition\" ) # XXX if params is empty / None, consider calling the default constructor compose = self . __compose__ if type ( params ) is tuple : return compose ( * params ) return compose ( params )","title":"__getitem__()"},{"location":"reference/core/#notional.core.DataObject","text":"The base for all API objects. Source code in notional/core.py class DataObject ( BaseModel , metaclass = ComposableObject ): \"\"\"The base for all API objects.\"\"\" def __setattr__ ( self , name , value ): \"\"\"Set the attribute of this object to a given value. The implementation of `BaseModel.__setattr__` does not allow for properties. See https://github.com/samuelcolvin/pydantic/issues/1577 \"\"\" try : super () . __setattr__ ( name , value ) except ValueError as err : setters = inspect . getmembers ( self . __class__ , predicate = lambda x : isinstance ( x , property ) and x . fset is not None , ) for setter_name , _ in setters : if setter_name == name : object . __setattr__ ( self , name , value ) break else : raise err @classmethod def _modify_field_ ( cls , name , default = None ): \"\"\"Modify the `BaseModel` field information for a specific class instance. This is necessary in particular for sublcasses that change the default values of a model when defined. Notable examples are `TypedObject` and `NamedObject`. :param name: the named attribute in the class :param default: the new default for the named field \"\"\" setattr ( cls , name , default ) cls . __fields__ [ name ] . default = default cls . __fields__ [ name ] . required = default is None # https://github.com/samuelcolvin/pydantic/discussions/3139 def refresh ( __pydantic_self__ , ** data ): \"\"\"Refresh the internal attributes with new data.\"\"\" values , fields , error = validate_model ( __pydantic_self__ . __class__ , data ) if error : raise error for name in fields : value = values [ name ] log . debug ( \"set object data -- %s => %s \" , name , value ) setattr ( __pydantic_self__ , name , value ) return __pydantic_self__ def to_api ( self ): \"\"\"Convert to a suitable representation for the Notion API.\"\"\" # the API doesn't like \"undefined\" values... data = self . dict ( exclude_none = True , by_alias = True ) # we need to convert \"special\" types to string forms to help the JSON encoder. # there are efforts underway in pydantic to make this easier, but for now... return make_api_safe ( data )","title":"DataObject"},{"location":"reference/core/#notional.core.DataObject.__setattr__","text":"Set the attribute of this object to a given value. The implementation of BaseModel.__setattr__ does not allow for properties. See https://github.com/samuelcolvin/pydantic/issues/1577 Source code in notional/core.py def __setattr__ ( self , name , value ): \"\"\"Set the attribute of this object to a given value. The implementation of `BaseModel.__setattr__` does not allow for properties. See https://github.com/samuelcolvin/pydantic/issues/1577 \"\"\" try : super () . __setattr__ ( name , value ) except ValueError as err : setters = inspect . getmembers ( self . __class__ , predicate = lambda x : isinstance ( x , property ) and x . fset is not None , ) for setter_name , _ in setters : if setter_name == name : object . __setattr__ ( self , name , value ) break else : raise err","title":"__setattr__()"},{"location":"reference/core/#notional.core.DataObject.refresh","text":"Refresh the internal attributes with new data. Source code in notional/core.py def refresh ( __pydantic_self__ , ** data ): \"\"\"Refresh the internal attributes with new data.\"\"\" values , fields , error = validate_model ( __pydantic_self__ . __class__ , data ) if error : raise error for name in fields : value = values [ name ] log . debug ( \"set object data -- %s => %s \" , name , value ) setattr ( __pydantic_self__ , name , value ) return __pydantic_self__","title":"refresh()"},{"location":"reference/core/#notional.core.DataObject.to_api","text":"Convert to a suitable representation for the Notion API. Source code in notional/core.py def to_api ( self ): \"\"\"Convert to a suitable representation for the Notion API.\"\"\" # the API doesn't like \"undefined\" values... data = self . dict ( exclude_none = True , by_alias = True ) # we need to convert \"special\" types to string forms to help the JSON encoder. # there are efforts underway in pydantic to make this easier, but for now... return make_api_safe ( data )","title":"to_api()"},{"location":"reference/core/#notional.core.NamedObject","text":"A Notion API object. Source code in notional/core.py class NamedObject ( DataObject ): \"\"\"A Notion API object.\"\"\" # XXX should NamedObject have the same typing ability as TypedObject? object : str def __init_subclass__ ( cls , object = None , ** kwargs ): \"\"\"Update `DataObject` defaults for the named object.\"\"\" super () . __init_subclass__ ( ** kwargs ) if object is not None : cls . _modify_field_ ( \"object\" , default = object )","title":"NamedObject"},{"location":"reference/core/#notional.core.NamedObject.__init_subclass__","text":"Update DataObject defaults for the named object. Source code in notional/core.py def __init_subclass__ ( cls , object = None , ** kwargs ): \"\"\"Update `DataObject` defaults for the named object.\"\"\" super () . __init_subclass__ ( ** kwargs ) if object is not None : cls . _modify_field_ ( \"object\" , default = object )","title":"__init_subclass__()"},{"location":"reference/core/#notional.core.NestedObject","text":"Represents an API object with nested data. These objects require a 'type' property and a matching property of the same name, which holds additional data. For example, this contains a nested 'text' object: data = { type: \"text\", ... !!! text \"{\" ... } } Currently, this is a convenience class for clarity - it does not provide additional functionality at this time. Source code in notional/core.py class NestedObject ( DataObject ): \"\"\"Represents an API object with nested data. These objects require a 'type' property and a matching property of the same name, which holds additional data. For example, this contains a nested 'text' object: data = { type: \"text\", ... text: { ... } } Currently, this is a convenience class for clarity - it does not provide additional functionality at this time. \"\"\"","title":"NestedObject"},{"location":"reference/core/#notional.core.TypedObject","text":"A type-referenced object. Many objects in the Notion API follow a generic->specific pattern with a 'type' parameter followed by additional data. These objects must specify a type attribute to ensure that the correct object is created. Calling the object provides direct access to the data stored in {type} . Source code in notional/core.py class TypedObject ( DataObject ): \"\"\"A type-referenced object. Many objects in the Notion API follow a generic->specific pattern with a 'type' parameter followed by additional data. These objects must specify a `type` attribute to ensure that the correct object is created. Calling the object provides direct access to the data stored in `{type}`. \"\"\" type : str # modified from the methods described in this discussion: # - https://github.com/samuelcolvin/pydantic/discussions/3091 def __init_subclass__ ( cls , type = None , ** kwargs ): \"\"\"Register the subtypes of the TypedObject subclass.\"\"\" super () . __init_subclass__ ( ** kwargs ) if type is not None : sub_type = type elif hasattr ( cls , \"__type__\" ): sub_type = cls . __type__ else : sub_type = cls . __name__ cls . _modify_field_ ( \"type\" , default = sub_type ) # initialize a __typemap__ map for each direct child of TypedObject # this allows different class trees to have the same 'type' name # but point to a different object (e.g. the 'date' type may have # different implementations depending where it is used in the API) # also, due to the order in which typed classes are defined, once # the map is defined for a subclass of TypedObject, any further # descendants of that class will have the new map via inheritance if TypedObject in cls . __bases__ and not hasattr ( cls , \"__typemap__\" ): cls . __typemap__ = {} if sub_type in cls . __typemap__ : raise ValueError ( f \"Duplicate subtype for class - { sub_type } :: { cls } \" ) log . debug ( \"registered new subtype: %s => %s \" , sub_type , cls ) cls . __typemap__ [ sub_type ] = cls def __call__ ( self , field = None ): \"\"\"Return nested data from this Block. If a field is provided, the contents of that field in the NestedData will be returned. Otherwise, the full contents of the NestedData will be returned. \"\"\" type = getattr ( self , \"type\" , None ) if type is None : raise AttributeError ( \"type not specified\" ) nested = getattr ( self , type ) if field is not None : nested = getattr ( nested , field ) return nested @classmethod def __get_validators__ ( cls ): \"\"\"Provide `BaseModel` with the means to convert `TypedObject`'s.\"\"\" yield cls . _convert_to_real_type_ @classmethod def parse_obj ( cls , obj ): \"\"\"Parse the structured object data into an instance of `TypedObject`. This method overrides `BaseModel.parse_obj()`. \"\"\" return cls . _convert_to_real_type_ ( obj ) @classmethod def _convert_to_real_type_ ( cls , data ): \"\"\"Instantiate the correct object based on the 'type' field.\"\"\" if isinstance ( data , cls ): return data if not isinstance ( data , dict ): raise ValueError ( \"Invalid 'data' object\" ) data_type = data . get ( \"type\" ) if data_type is None : raise ValueError ( \"Missing 'type' in TypedObject\" ) if not hasattr ( cls , \"__typemap__\" ): raise TypeError ( f \"Invalid TypedObject: { cls } - missing __typemap__\" ) sub = cls . __typemap__ . get ( data_type ) if sub is None : raise TypeError ( f \"Unsupport sub-type: { data_type } \" ) log . debug ( \"initializing typed object %s :: %s => %s -- %s \" , cls , data_type , sub , data ) return sub ( ** data )","title":"TypedObject"},{"location":"reference/core/#notional.core.TypedObject.__call__","text":"Return nested data from this Block. If a field is provided, the contents of that field in the NestedData will be returned. Otherwise, the full contents of the NestedData will be returned. Source code in notional/core.py def __call__ ( self , field = None ): \"\"\"Return nested data from this Block. If a field is provided, the contents of that field in the NestedData will be returned. Otherwise, the full contents of the NestedData will be returned. \"\"\" type = getattr ( self , \"type\" , None ) if type is None : raise AttributeError ( \"type not specified\" ) nested = getattr ( self , type ) if field is not None : nested = getattr ( nested , field ) return nested","title":"__call__()"},{"location":"reference/core/#notional.core.TypedObject.__get_validators__","text":"Provide BaseModel with the means to convert TypedObject 's. Source code in notional/core.py @classmethod def __get_validators__ ( cls ): \"\"\"Provide `BaseModel` with the means to convert `TypedObject`'s.\"\"\" yield cls . _convert_to_real_type_","title":"__get_validators__()"},{"location":"reference/core/#notional.core.TypedObject.__init_subclass__","text":"Register the subtypes of the TypedObject subclass. Source code in notional/core.py def __init_subclass__ ( cls , type = None , ** kwargs ): \"\"\"Register the subtypes of the TypedObject subclass.\"\"\" super () . __init_subclass__ ( ** kwargs ) if type is not None : sub_type = type elif hasattr ( cls , \"__type__\" ): sub_type = cls . __type__ else : sub_type = cls . __name__ cls . _modify_field_ ( \"type\" , default = sub_type ) # initialize a __typemap__ map for each direct child of TypedObject # this allows different class trees to have the same 'type' name # but point to a different object (e.g. the 'date' type may have # different implementations depending where it is used in the API) # also, due to the order in which typed classes are defined, once # the map is defined for a subclass of TypedObject, any further # descendants of that class will have the new map via inheritance if TypedObject in cls . __bases__ and not hasattr ( cls , \"__typemap__\" ): cls . __typemap__ = {} if sub_type in cls . __typemap__ : raise ValueError ( f \"Duplicate subtype for class - { sub_type } :: { cls } \" ) log . debug ( \"registered new subtype: %s => %s \" , sub_type , cls ) cls . __typemap__ [ sub_type ] = cls","title":"__init_subclass__()"},{"location":"reference/core/#notional.core.TypedObject.parse_obj","text":"Parse the structured object data into an instance of TypedObject . This method overrides BaseModel.parse_obj() . Source code in notional/core.py @classmethod def parse_obj ( cls , obj ): \"\"\"Parse the structured object data into an instance of `TypedObject`. This method overrides `BaseModel.parse_obj()`. \"\"\" return cls . _convert_to_real_type_ ( obj )","title":"parse_obj()"},{"location":"reference/core/#notional.core.make_api_safe","text":"Recursively convert the given data to an API-safe form. This is mostly to handle data types that will not directly serialize to JSON. Source code in notional/core.py def make_api_safe ( data ): \"\"\"Recursively convert the given data to an API-safe form. This is mostly to handle data types that will not directly serialize to JSON. \"\"\" # https://github.com/samuelcolvin/pydantic/issues/1409#issuecomment-877175194 if isinstance ( data , ( date , datetime )): return data . isoformat () if isinstance ( data , UUID ): return str ( data ) if isinstance ( data , Enum ): return data . value if isinstance ( data , dict ): return { name : make_api_safe ( value ) for name , value in data . items ()} if isinstance ( data , list ): return [ make_api_safe ( value ) for value in data ] if isinstance ( data , tuple ): return [ make_api_safe ( value ) for value in data ] return data","title":"make_api_safe()"},{"location":"reference/orm/","text":"Utilities for working with Notion as an ORM. There are two primary constructs in this module that enable custom type definitions in Notional: Property() and connected_page() . ConnectedPage Base class for \"live\" pages via the Notion API. All changes are committed in real time. Source code in notional/orm.py class ConnectedPage : \"\"\"Base class for \"live\" pages via the Notion API. All changes are committed in real time. \"\"\" def __init__ ( self , ** data ): \"\"\"Construct a page from the given data dictionary.\"\"\" self . _notional__page = Page ( ** data ) if data else None def __init_subclass__ ( cls , database = None , ** kwargs ): \"\"\"Register new subclasses of a ConnectedPage.\"\"\" super ( cls ) . __init_subclass__ ( ** kwargs ) if database is not None : cls . _notional__database = database elif hasattr ( cls , \"__database__\" ): cls . _notional__database = cls . __database__ @property def id ( self ): \"\"\"Return the ID of this page (if available).\"\"\" return self . _notional__page . id if self . _notional__page else None @property def children ( self ): \"\"\"Return an iterator for all child blocks of this Page.\"\"\" if self . _notional__page is None : return [] return self . _notional__session . blocks . children . list ( parent = self . _notional__page ) @property def cover ( self ): \"\"\"Return the cover for the Page.\"\"\" return self . _notional__page . cover @cover . setter def cover ( self , file ): \"\"\"Set the cover for the Page.\"\"\" self . _notional__session . pages . set ( self . _notional__page , cover = file ) @property def icon ( self ): \"\"\"Return the icon for the Page.\"\"\" return self . _notional__page . icon @icon . setter def icon ( self , emoji ): \"\"\"Set the icon for the Page. :param emoji: may be either a single emoji string or an `EmojiObject` \"\"\" if isinstance ( emoji , str ): emoji = EmojiObject [ emoji ] elif not isinstance ( emoji , EmojiObject ): raise ValueError ( \"Invalid emoji; unsupported type\" ) self . _notional__session . pages . set ( self . _notional__page , icon = emoji ) def __iadd__ ( self , block ): \"\"\"Append the given block to this page. This operation takes place on the Notion server, causing the page to save immediately. \"\"\" self . append ( block ) return self def append ( self , * blocks ): \"\"\"Append the given blocks as children of this ConnectedPage. This operation takes place on the Notion server, causing the page to update immediately. \"\"\" if self . _notional__page is None : raise ValueError ( \"Cannot append blocks; missing page\" ) if self . _notional__session is None : raise ValueError ( \"Cannot append blocks; invalid session\" ) log . debug ( \"appending %d blocks to page :: %s \" , len ( blocks ), self . _notional__page . id ) self . _notional__session . blocks . children . append ( self . _notional__page , * blocks ) @classmethod def bind ( cls , to_session ): \"\"\"Attach this ConnectedPage to the given session. Setting this to None will detach the page. \"\"\" cls . _notional__session = to_session @classmethod def query ( cls ): \"\"\"Return a `QueryBuilder` for the custom type.\"\"\" if cls . _notional__session is None : raise ValueError ( \"Unable to query; invalid session\" ) if cls . _notional__database is None : raise ValueError ( \"Unable to query; invalid database\" ) return cls . _notional__session . databases . query ( cls ) @classmethod def create ( cls , ** kwargs ): \"\"\"Create a new instance of the ConnectedPage type. Any properties that support object composition may defined in `kwargs`. This operation takes place on the Notion server, creating the page immediately. :param properties: the properties to initialize for this object as a `dict()` with format `name: value` where `name` is the attribute in the custom type and `value` is a supported type for composing \"\"\" if cls . _notional__session is None : raise ValueError ( \"Cannot create Page; invalid session\" ) if cls . _notional__database is None : raise ValueError ( \"Cannot create Page; invalid database\" ) log . debug ( \"creating new %s :: %s \" , cls , cls . _notional__database ) parent = DatabaseRef ( database_id = cls . _notional__database ) connected = cls () connected . _notional__page = cls . _notional__session . pages . create ( parent = parent ) # FIXME it would be better to convert properties to a dict and pass to the API, # rather than setting them individually here... for name , value in kwargs . items (): setattr ( connected , name , value ) return connected @classmethod def parse_obj ( cls , data ): \"\"\"Invoke the class constructor using the structured data. Similar to `BaseModel.parse_obj(data)`. \"\"\" return cls ( ** data ) children property readonly Return an iterator for all child blocks of this Page. cover property writable Return the cover for the Page. icon property writable Return the icon for the Page. id property readonly Return the ID of this page (if available). __iadd__ ( self , block ) special Append the given block to this page. This operation takes place on the Notion server, causing the page to save immediately. Source code in notional/orm.py def __iadd__ ( self , block ): \"\"\"Append the given block to this page. This operation takes place on the Notion server, causing the page to save immediately. \"\"\" self . append ( block ) return self __init__ ( self , ** data ) special Construct a page from the given data dictionary. Source code in notional/orm.py def __init__ ( self , ** data ): \"\"\"Construct a page from the given data dictionary.\"\"\" self . _notional__page = Page ( ** data ) if data else None __init_subclass__ ( database = None , ** kwargs ) classmethod special Register new subclasses of a ConnectedPage. Source code in notional/orm.py def __init_subclass__ ( cls , database = None , ** kwargs ): \"\"\"Register new subclasses of a ConnectedPage.\"\"\" super ( cls ) . __init_subclass__ ( ** kwargs ) if database is not None : cls . _notional__database = database elif hasattr ( cls , \"__database__\" ): cls . _notional__database = cls . __database__ append ( self , * blocks ) Append the given blocks as children of this ConnectedPage. This operation takes place on the Notion server, causing the page to update immediately. Source code in notional/orm.py def append ( self , * blocks ): \"\"\"Append the given blocks as children of this ConnectedPage. This operation takes place on the Notion server, causing the page to update immediately. \"\"\" if self . _notional__page is None : raise ValueError ( \"Cannot append blocks; missing page\" ) if self . _notional__session is None : raise ValueError ( \"Cannot append blocks; invalid session\" ) log . debug ( \"appending %d blocks to page :: %s \" , len ( blocks ), self . _notional__page . id ) self . _notional__session . blocks . children . append ( self . _notional__page , * blocks ) bind ( to_session ) classmethod Attach this ConnectedPage to the given session. Setting this to None will detach the page. Source code in notional/orm.py @classmethod def bind ( cls , to_session ): \"\"\"Attach this ConnectedPage to the given session. Setting this to None will detach the page. \"\"\" cls . _notional__session = to_session create ( ** kwargs ) classmethod Create a new instance of the ConnectedPage type. Any properties that support object composition may defined in kwargs . This operation takes place on the Notion server, creating the page immediately. :param properties: the properties to initialize for this object as a dict() with format name: value where name is the attribute in the custom type and value is a supported type for composing Source code in notional/orm.py @classmethod def create ( cls , ** kwargs ): \"\"\"Create a new instance of the ConnectedPage type. Any properties that support object composition may defined in `kwargs`. This operation takes place on the Notion server, creating the page immediately. :param properties: the properties to initialize for this object as a `dict()` with format `name: value` where `name` is the attribute in the custom type and `value` is a supported type for composing \"\"\" if cls . _notional__session is None : raise ValueError ( \"Cannot create Page; invalid session\" ) if cls . _notional__database is None : raise ValueError ( \"Cannot create Page; invalid database\" ) log . debug ( \"creating new %s :: %s \" , cls , cls . _notional__database ) parent = DatabaseRef ( database_id = cls . _notional__database ) connected = cls () connected . _notional__page = cls . _notional__session . pages . create ( parent = parent ) # FIXME it would be better to convert properties to a dict and pass to the API, # rather than setting them individually here... for name , value in kwargs . items (): setattr ( connected , name , value ) return connected parse_obj ( data ) classmethod Invoke the class constructor using the structured data. Similar to BaseModel.parse_obj(data) . Source code in notional/orm.py @classmethod def parse_obj ( cls , data ): \"\"\"Invoke the class constructor using the structured data. Similar to `BaseModel.parse_obj(data)`. \"\"\" return cls ( ** data ) query () classmethod Return a QueryBuilder for the custom type. Source code in notional/orm.py @classmethod def query ( cls ): \"\"\"Return a `QueryBuilder` for the custom type.\"\"\" if cls . _notional__session is None : raise ValueError ( \"Unable to query; invalid session\" ) if cls . _notional__database is None : raise ValueError ( \"Unable to query; invalid database\" ) return cls . _notional__session . databases . query ( cls ) ConnectedPageFactory A factory that builds custom types for ConnectedPage classes. Typically, these generated classes will be extended to form a custom type. Source code in notional/orm.py class ConnectedPageFactory : \"\"\"A factory that builds custom types for `ConnectedPage` classes. Typically, these generated classes will be extended to form a custom type. \"\"\" # TODO consider making this more general purpose (e.g. extend other base objects) def __init__ ( self , name = \"CustomBase\" , base = None , metaclass = None , ): \"\"\"Initialze the `ConnectedPageFactory` with the given parameters. :param name: the name of the class generated by this factory; defaults to \"CustomPage\" :param base: the class (or tuple of classes) used as the base class for types generated by this factory; defaults to `None` :param metaclass: the callable metaclass to use for generating new types; defaults to `type` \"\"\" self . name = name if base is None : self . bases = ( ConnectedPage ,) elif isinstance ( base , tuple ): self . bases = base else : self . bases = ( base ,) if metaclass is None : self . metaclass = type else : self . metaclass = metaclass def __call__ ( self , session , database , schema = None ): \"\"\"Return a new type from this factory with the given configuration.\"\"\" attrs = { \"_notional__session\" : session , \"_notional__database\" : database , } if schema is not None : for name , obj in schema . items (): safe_name = make_safe_python_name ( name ) prop = Property ( name , obj ) attrs [ safe_name ] = prop return self . metaclass ( self . name , self . bases , attrs ) __call__ ( self , session , database , schema = None ) special Return a new type from this factory with the given configuration. Source code in notional/orm.py def __call__ ( self , session , database , schema = None ): \"\"\"Return a new type from this factory with the given configuration.\"\"\" attrs = { \"_notional__session\" : session , \"_notional__database\" : database , } if schema is not None : for name , obj in schema . items (): safe_name = make_safe_python_name ( name ) prop = Property ( name , obj ) attrs [ safe_name ] = prop return self . metaclass ( self . name , self . bases , attrs ) __init__ ( self , name = 'CustomBase' , base = None , metaclass = None ) special Initialze the ConnectedPageFactory with the given parameters. :param name: the name of the class generated by this factory; defaults to \"CustomPage\" :param base: the class (or tuple of classes) used as the base class for types generated by this factory; defaults to None :param metaclass: the callable metaclass to use for generating new types; defaults to type Source code in notional/orm.py def __init__ ( self , name = \"CustomBase\" , base = None , metaclass = None , ): \"\"\"Initialze the `ConnectedPageFactory` with the given parameters. :param name: the name of the class generated by this factory; defaults to \"CustomPage\" :param base: the class (or tuple of classes) used as the base class for types generated by this factory; defaults to `None` :param metaclass: the callable metaclass to use for generating new types; defaults to `type` \"\"\" self . name = name if base is None : self . bases = ( ConnectedPage ,) elif isinstance ( base , tuple ): self . bases = base else : self . bases = ( base ,) if metaclass is None : self . metaclass = type else : self . metaclass = metaclass ConnectedProperty Contains the information and methods needed for a connected property. When created, this object does not have a reference to its parent object. Before this property is accessed for the first time, callers must use bind() to set the containing object at runtime. Source code in notional/orm.py class ConnectedProperty : \"\"\"Contains the information and methods needed for a connected property. When created, this object does not have a reference to its parent object. Before this property is accessed for the first time, callers must use `bind()` to set the containing object at runtime. \"\"\" def __init__ ( self , name , schema , default =... ): \"\"\"Initialize the property wrapper. :param name: the name of this property as it appears on Notional :param schema: the PropertyObject that defines the type of this property :param default: an optional parameter that will return a default value if one is not provided by the API \"\"\" if name is None or len ( name ) == 0 : raise ValueError ( \"Must provide a valid property name\" ) if schema is None : raise ValueError ( \"Invalid schema; cannot be None\" ) self . name = name self . default = default self . schema = schema self . data_type = type ( schema ) if not hasattr ( self . data_type , \"type\" ) or self . data_type . type is None : raise ValueError ( \"Invalid schema; undefined type\" ) self . type_name = self . data_type . type # this is kind of an ugly way to grab the value type from the schema type... # mostly b/c we are using internal knowledge of TypedObject.__typemap__ if self . type_name not in PropertyValue . __typemap__ : raise TypeError ( f \"Invalid schema; missing value type ' { self . type_name } '\" ) self . value_type = PropertyValue . __typemap__ [ self . type_name ] def bind ( self , obj ): \"\"\"Binds this property to the given object.\"\"\" if not isinstance ( obj , ConnectedPage ): raise TypeError ( \"Properties must be used in a ConnectedPage object\" ) # XXX should we do any additional error checking on the object? self . parent = obj self . page_data = self . parent . _notional__page self . session = self . parent . _notional__session def get ( self ): \"\"\"Return the current value of the property as a python object.\"\"\" log . debug ( \"fget :: %s [ %s ]\" , self . type_name , self . name ) # TODO raise instead? if self . page_data is None : return None try : prop = self . page_data [ self . name ] except AttributeError : if self . default == ... : raise AttributeError ( f \"Missing property: ' { self . name } '\" ) return self . default if not isinstance ( prop , self . value_type ): raise TypeError ( \"Type mismatch\" ) if hasattr ( prop , \"Value\" ): return prop . Value return prop def set ( self , value ): \"\"\"Set the property to the given value.\"\"\" log . debug ( \"fset :: %s [ %s ] => %s \" , self . type_name , self . name , type ( value )) # TODO raise instead? if self . page_data is None : return if isinstance ( value , self . value_type ): prop = value elif hasattr ( self . value_type , \"__compose__\" ): prop = self . value_type . __compose__ ( value ) else : raise TypeError ( f \"Unsupported value type for ' { self . type_name } '\" ) # update the property on the server (which will refresh the local data) self . session . pages . update ( self . page_data , ** { self . name : prop }) def delete ( self ): \"\"\"Delete the value assotiated with this property.\"\"\" # TODO raise instead? if self . page_data is None : return empty = self . value_type () self . session . pages . update ( self . page_data , ** { self . name : empty }) __init__ ( self , name , schema , default = Ellipsis ) special Initialize the property wrapper. :param name: the name of this property as it appears on Notional :param schema: the PropertyObject that defines the type of this property :param default: an optional parameter that will return a default value if one is not provided by the API Source code in notional/orm.py def __init__ ( self , name , schema , default =... ): \"\"\"Initialize the property wrapper. :param name: the name of this property as it appears on Notional :param schema: the PropertyObject that defines the type of this property :param default: an optional parameter that will return a default value if one is not provided by the API \"\"\" if name is None or len ( name ) == 0 : raise ValueError ( \"Must provide a valid property name\" ) if schema is None : raise ValueError ( \"Invalid schema; cannot be None\" ) self . name = name self . default = default self . schema = schema self . data_type = type ( schema ) if not hasattr ( self . data_type , \"type\" ) or self . data_type . type is None : raise ValueError ( \"Invalid schema; undefined type\" ) self . type_name = self . data_type . type # this is kind of an ugly way to grab the value type from the schema type... # mostly b/c we are using internal knowledge of TypedObject.__typemap__ if self . type_name not in PropertyValue . __typemap__ : raise TypeError ( f \"Invalid schema; missing value type ' { self . type_name } '\" ) self . value_type = PropertyValue . __typemap__ [ self . type_name ] bind ( self , obj ) Binds this property to the given object. Source code in notional/orm.py def bind ( self , obj ): \"\"\"Binds this property to the given object.\"\"\" if not isinstance ( obj , ConnectedPage ): raise TypeError ( \"Properties must be used in a ConnectedPage object\" ) # XXX should we do any additional error checking on the object? self . parent = obj self . page_data = self . parent . _notional__page self . session = self . parent . _notional__session delete ( self ) Delete the value assotiated with this property. Source code in notional/orm.py def delete ( self ): \"\"\"Delete the value assotiated with this property.\"\"\" # TODO raise instead? if self . page_data is None : return empty = self . value_type () self . session . pages . update ( self . page_data , ** { self . name : empty }) get ( self ) Return the current value of the property as a python object. Source code in notional/orm.py def get ( self ): \"\"\"Return the current value of the property as a python object.\"\"\" log . debug ( \"fget :: %s [ %s ]\" , self . type_name , self . name ) # TODO raise instead? if self . page_data is None : return None try : prop = self . page_data [ self . name ] except AttributeError : if self . default == ... : raise AttributeError ( f \"Missing property: ' { self . name } '\" ) return self . default if not isinstance ( prop , self . value_type ): raise TypeError ( \"Type mismatch\" ) if hasattr ( prop , \"Value\" ): return prop . Value return prop set ( self , value ) Set the property to the given value. Source code in notional/orm.py def set ( self , value ): \"\"\"Set the property to the given value.\"\"\" log . debug ( \"fset :: %s [ %s ] => %s \" , self . type_name , self . name , type ( value )) # TODO raise instead? if self . page_data is None : return if isinstance ( value , self . value_type ): prop = value elif hasattr ( self . value_type , \"__compose__\" ): prop = self . value_type . __compose__ ( value ) else : raise TypeError ( f \"Unsupported value type for ' { self . type_name } '\" ) # update the property on the server (which will refresh the local data) self . session . pages . update ( self . page_data , ** { self . name : prop }) Property ( name , schema = None , default = Ellipsis ) Define a property for a Notion Page object. Internally, this method uses a custom wrapper to manage the property methods. :param name: the Notion table property name :param data_type: the schema that defines this property (default = RichText) :param default: a default value when creating new objects Source code in notional/orm.py def Property ( name , schema = None , default =... ): \"\"\"Define a property for a Notion Page object. Internally, this method uses a custom wrapper to manage the property methods. :param name: the Notion table property name :param data_type: the schema that defines this property (default = RichText) :param default: a default value when creating new objects \"\"\" log . debug ( \"creating new Property: %s \" , name ) if schema is None : schema = RichText () elif not isinstance ( schema , PropertyObject ): raise TypeError ( \"Invalid data_type; not a PropertyObject\" ) cprop = ConnectedProperty ( name = name , schema = schema , default = default , ) def fget ( self ): \"\"\"Return the current value of the property as a python object.\"\"\" cprop . bind ( self ) return cprop . get () def fset ( self , value ): \"\"\"Set the property to the given value.\"\"\" cprop . bind ( self ) cprop . set ( value ) def fdel ( self ): \"\"\"Delete the value for this property.\"\"\" cprop . bind ( self ) cprop . delete () return property ( fget , fset , fdel ) connected_page ( session = None , source_db = None , schema = None , cls = None ) Return a base class for \"connected\" pages through the Notion API. Subclasses may then inherit from the returned class to define custom ORM types. :param session: an active Notional session where the database is hosted :param source_db: if provided, the returned class will use the ID and schema of this object to initialize the connected page :param schema: if provided, the returned class will contain properties according to the schema provided; defaults to None :param cls: the returned class will inherit from the given class, which must be a sublass of ConnectedPage ; defaults to ConnectedPage Source code in notional/orm.py def connected_page ( session = None , source_db = None , schema = None , cls = None ): \"\"\"Return a base class for \"connected\" pages through the Notion API. Subclasses may then inherit from the returned class to define custom ORM types. :param session: an active Notional session where the database is hosted :param source_db: if provided, the returned class will use the ID and schema of this object to initialize the connected page :param schema: if provided, the returned class will contain properties according to the schema provided; defaults to `None` :param cls: the returned class will inherit from the given class, which must be a sublass of `ConnectedPage`; defaults to `ConnectedPage` \"\"\" if cls is None : cls = ConnectedPage elif not issubclass ( cls , ConnectedPage ): raise ValueError ( \"'cls' must subclass ConnectedPage\" ) if source_db is None : dbid = None elif not isinstance ( source_db , Database ): raise ValueError ( \"'source_db' must be a Database\" ) else : if schema is None : schema = source_db . properties dbid = source_db . id factory = ConnectedPageFactory ( base = cls ) return factory ( session = session , database = dbid , schema = schema , )","title":"ORM"},{"location":"reference/orm/#notional.orm.ConnectedPage","text":"Base class for \"live\" pages via the Notion API. All changes are committed in real time. Source code in notional/orm.py class ConnectedPage : \"\"\"Base class for \"live\" pages via the Notion API. All changes are committed in real time. \"\"\" def __init__ ( self , ** data ): \"\"\"Construct a page from the given data dictionary.\"\"\" self . _notional__page = Page ( ** data ) if data else None def __init_subclass__ ( cls , database = None , ** kwargs ): \"\"\"Register new subclasses of a ConnectedPage.\"\"\" super ( cls ) . __init_subclass__ ( ** kwargs ) if database is not None : cls . _notional__database = database elif hasattr ( cls , \"__database__\" ): cls . _notional__database = cls . __database__ @property def id ( self ): \"\"\"Return the ID of this page (if available).\"\"\" return self . _notional__page . id if self . _notional__page else None @property def children ( self ): \"\"\"Return an iterator for all child blocks of this Page.\"\"\" if self . _notional__page is None : return [] return self . _notional__session . blocks . children . list ( parent = self . _notional__page ) @property def cover ( self ): \"\"\"Return the cover for the Page.\"\"\" return self . _notional__page . cover @cover . setter def cover ( self , file ): \"\"\"Set the cover for the Page.\"\"\" self . _notional__session . pages . set ( self . _notional__page , cover = file ) @property def icon ( self ): \"\"\"Return the icon for the Page.\"\"\" return self . _notional__page . icon @icon . setter def icon ( self , emoji ): \"\"\"Set the icon for the Page. :param emoji: may be either a single emoji string or an `EmojiObject` \"\"\" if isinstance ( emoji , str ): emoji = EmojiObject [ emoji ] elif not isinstance ( emoji , EmojiObject ): raise ValueError ( \"Invalid emoji; unsupported type\" ) self . _notional__session . pages . set ( self . _notional__page , icon = emoji ) def __iadd__ ( self , block ): \"\"\"Append the given block to this page. This operation takes place on the Notion server, causing the page to save immediately. \"\"\" self . append ( block ) return self def append ( self , * blocks ): \"\"\"Append the given blocks as children of this ConnectedPage. This operation takes place on the Notion server, causing the page to update immediately. \"\"\" if self . _notional__page is None : raise ValueError ( \"Cannot append blocks; missing page\" ) if self . _notional__session is None : raise ValueError ( \"Cannot append blocks; invalid session\" ) log . debug ( \"appending %d blocks to page :: %s \" , len ( blocks ), self . _notional__page . id ) self . _notional__session . blocks . children . append ( self . _notional__page , * blocks ) @classmethod def bind ( cls , to_session ): \"\"\"Attach this ConnectedPage to the given session. Setting this to None will detach the page. \"\"\" cls . _notional__session = to_session @classmethod def query ( cls ): \"\"\"Return a `QueryBuilder` for the custom type.\"\"\" if cls . _notional__session is None : raise ValueError ( \"Unable to query; invalid session\" ) if cls . _notional__database is None : raise ValueError ( \"Unable to query; invalid database\" ) return cls . _notional__session . databases . query ( cls ) @classmethod def create ( cls , ** kwargs ): \"\"\"Create a new instance of the ConnectedPage type. Any properties that support object composition may defined in `kwargs`. This operation takes place on the Notion server, creating the page immediately. :param properties: the properties to initialize for this object as a `dict()` with format `name: value` where `name` is the attribute in the custom type and `value` is a supported type for composing \"\"\" if cls . _notional__session is None : raise ValueError ( \"Cannot create Page; invalid session\" ) if cls . _notional__database is None : raise ValueError ( \"Cannot create Page; invalid database\" ) log . debug ( \"creating new %s :: %s \" , cls , cls . _notional__database ) parent = DatabaseRef ( database_id = cls . _notional__database ) connected = cls () connected . _notional__page = cls . _notional__session . pages . create ( parent = parent ) # FIXME it would be better to convert properties to a dict and pass to the API, # rather than setting them individually here... for name , value in kwargs . items (): setattr ( connected , name , value ) return connected @classmethod def parse_obj ( cls , data ): \"\"\"Invoke the class constructor using the structured data. Similar to `BaseModel.parse_obj(data)`. \"\"\" return cls ( ** data )","title":"ConnectedPage"},{"location":"reference/orm/#notional.orm.ConnectedPage.children","text":"Return an iterator for all child blocks of this Page.","title":"children"},{"location":"reference/orm/#notional.orm.ConnectedPage.cover","text":"Return the cover for the Page.","title":"cover"},{"location":"reference/orm/#notional.orm.ConnectedPage.icon","text":"Return the icon for the Page.","title":"icon"},{"location":"reference/orm/#notional.orm.ConnectedPage.id","text":"Return the ID of this page (if available).","title":"id"},{"location":"reference/orm/#notional.orm.ConnectedPage.__iadd__","text":"Append the given block to this page. This operation takes place on the Notion server, causing the page to save immediately. Source code in notional/orm.py def __iadd__ ( self , block ): \"\"\"Append the given block to this page. This operation takes place on the Notion server, causing the page to save immediately. \"\"\" self . append ( block ) return self","title":"__iadd__()"},{"location":"reference/orm/#notional.orm.ConnectedPage.__init__","text":"Construct a page from the given data dictionary. Source code in notional/orm.py def __init__ ( self , ** data ): \"\"\"Construct a page from the given data dictionary.\"\"\" self . _notional__page = Page ( ** data ) if data else None","title":"__init__()"},{"location":"reference/orm/#notional.orm.ConnectedPage.__init_subclass__","text":"Register new subclasses of a ConnectedPage. Source code in notional/orm.py def __init_subclass__ ( cls , database = None , ** kwargs ): \"\"\"Register new subclasses of a ConnectedPage.\"\"\" super ( cls ) . __init_subclass__ ( ** kwargs ) if database is not None : cls . _notional__database = database elif hasattr ( cls , \"__database__\" ): cls . _notional__database = cls . __database__","title":"__init_subclass__()"},{"location":"reference/orm/#notional.orm.ConnectedPage.append","text":"Append the given blocks as children of this ConnectedPage. This operation takes place on the Notion server, causing the page to update immediately. Source code in notional/orm.py def append ( self , * blocks ): \"\"\"Append the given blocks as children of this ConnectedPage. This operation takes place on the Notion server, causing the page to update immediately. \"\"\" if self . _notional__page is None : raise ValueError ( \"Cannot append blocks; missing page\" ) if self . _notional__session is None : raise ValueError ( \"Cannot append blocks; invalid session\" ) log . debug ( \"appending %d blocks to page :: %s \" , len ( blocks ), self . _notional__page . id ) self . _notional__session . blocks . children . append ( self . _notional__page , * blocks )","title":"append()"},{"location":"reference/orm/#notional.orm.ConnectedPage.bind","text":"Attach this ConnectedPage to the given session. Setting this to None will detach the page. Source code in notional/orm.py @classmethod def bind ( cls , to_session ): \"\"\"Attach this ConnectedPage to the given session. Setting this to None will detach the page. \"\"\" cls . _notional__session = to_session","title":"bind()"},{"location":"reference/orm/#notional.orm.ConnectedPage.create","text":"Create a new instance of the ConnectedPage type. Any properties that support object composition may defined in kwargs . This operation takes place on the Notion server, creating the page immediately. :param properties: the properties to initialize for this object as a dict() with format name: value where name is the attribute in the custom type and value is a supported type for composing Source code in notional/orm.py @classmethod def create ( cls , ** kwargs ): \"\"\"Create a new instance of the ConnectedPage type. Any properties that support object composition may defined in `kwargs`. This operation takes place on the Notion server, creating the page immediately. :param properties: the properties to initialize for this object as a `dict()` with format `name: value` where `name` is the attribute in the custom type and `value` is a supported type for composing \"\"\" if cls . _notional__session is None : raise ValueError ( \"Cannot create Page; invalid session\" ) if cls . _notional__database is None : raise ValueError ( \"Cannot create Page; invalid database\" ) log . debug ( \"creating new %s :: %s \" , cls , cls . _notional__database ) parent = DatabaseRef ( database_id = cls . _notional__database ) connected = cls () connected . _notional__page = cls . _notional__session . pages . create ( parent = parent ) # FIXME it would be better to convert properties to a dict and pass to the API, # rather than setting them individually here... for name , value in kwargs . items (): setattr ( connected , name , value ) return connected","title":"create()"},{"location":"reference/orm/#notional.orm.ConnectedPage.parse_obj","text":"Invoke the class constructor using the structured data. Similar to BaseModel.parse_obj(data) . Source code in notional/orm.py @classmethod def parse_obj ( cls , data ): \"\"\"Invoke the class constructor using the structured data. Similar to `BaseModel.parse_obj(data)`. \"\"\" return cls ( ** data )","title":"parse_obj()"},{"location":"reference/orm/#notional.orm.ConnectedPage.query","text":"Return a QueryBuilder for the custom type. Source code in notional/orm.py @classmethod def query ( cls ): \"\"\"Return a `QueryBuilder` for the custom type.\"\"\" if cls . _notional__session is None : raise ValueError ( \"Unable to query; invalid session\" ) if cls . _notional__database is None : raise ValueError ( \"Unable to query; invalid database\" ) return cls . _notional__session . databases . query ( cls )","title":"query()"},{"location":"reference/orm/#notional.orm.ConnectedPageFactory","text":"A factory that builds custom types for ConnectedPage classes. Typically, these generated classes will be extended to form a custom type. Source code in notional/orm.py class ConnectedPageFactory : \"\"\"A factory that builds custom types for `ConnectedPage` classes. Typically, these generated classes will be extended to form a custom type. \"\"\" # TODO consider making this more general purpose (e.g. extend other base objects) def __init__ ( self , name = \"CustomBase\" , base = None , metaclass = None , ): \"\"\"Initialze the `ConnectedPageFactory` with the given parameters. :param name: the name of the class generated by this factory; defaults to \"CustomPage\" :param base: the class (or tuple of classes) used as the base class for types generated by this factory; defaults to `None` :param metaclass: the callable metaclass to use for generating new types; defaults to `type` \"\"\" self . name = name if base is None : self . bases = ( ConnectedPage ,) elif isinstance ( base , tuple ): self . bases = base else : self . bases = ( base ,) if metaclass is None : self . metaclass = type else : self . metaclass = metaclass def __call__ ( self , session , database , schema = None ): \"\"\"Return a new type from this factory with the given configuration.\"\"\" attrs = { \"_notional__session\" : session , \"_notional__database\" : database , } if schema is not None : for name , obj in schema . items (): safe_name = make_safe_python_name ( name ) prop = Property ( name , obj ) attrs [ safe_name ] = prop return self . metaclass ( self . name , self . bases , attrs )","title":"ConnectedPageFactory"},{"location":"reference/orm/#notional.orm.ConnectedPageFactory.__call__","text":"Return a new type from this factory with the given configuration. Source code in notional/orm.py def __call__ ( self , session , database , schema = None ): \"\"\"Return a new type from this factory with the given configuration.\"\"\" attrs = { \"_notional__session\" : session , \"_notional__database\" : database , } if schema is not None : for name , obj in schema . items (): safe_name = make_safe_python_name ( name ) prop = Property ( name , obj ) attrs [ safe_name ] = prop return self . metaclass ( self . name , self . bases , attrs )","title":"__call__()"},{"location":"reference/orm/#notional.orm.ConnectedPageFactory.__init__","text":"Initialze the ConnectedPageFactory with the given parameters. :param name: the name of the class generated by this factory; defaults to \"CustomPage\" :param base: the class (or tuple of classes) used as the base class for types generated by this factory; defaults to None :param metaclass: the callable metaclass to use for generating new types; defaults to type Source code in notional/orm.py def __init__ ( self , name = \"CustomBase\" , base = None , metaclass = None , ): \"\"\"Initialze the `ConnectedPageFactory` with the given parameters. :param name: the name of the class generated by this factory; defaults to \"CustomPage\" :param base: the class (or tuple of classes) used as the base class for types generated by this factory; defaults to `None` :param metaclass: the callable metaclass to use for generating new types; defaults to `type` \"\"\" self . name = name if base is None : self . bases = ( ConnectedPage ,) elif isinstance ( base , tuple ): self . bases = base else : self . bases = ( base ,) if metaclass is None : self . metaclass = type else : self . metaclass = metaclass","title":"__init__()"},{"location":"reference/orm/#notional.orm.ConnectedProperty","text":"Contains the information and methods needed for a connected property. When created, this object does not have a reference to its parent object. Before this property is accessed for the first time, callers must use bind() to set the containing object at runtime. Source code in notional/orm.py class ConnectedProperty : \"\"\"Contains the information and methods needed for a connected property. When created, this object does not have a reference to its parent object. Before this property is accessed for the first time, callers must use `bind()` to set the containing object at runtime. \"\"\" def __init__ ( self , name , schema , default =... ): \"\"\"Initialize the property wrapper. :param name: the name of this property as it appears on Notional :param schema: the PropertyObject that defines the type of this property :param default: an optional parameter that will return a default value if one is not provided by the API \"\"\" if name is None or len ( name ) == 0 : raise ValueError ( \"Must provide a valid property name\" ) if schema is None : raise ValueError ( \"Invalid schema; cannot be None\" ) self . name = name self . default = default self . schema = schema self . data_type = type ( schema ) if not hasattr ( self . data_type , \"type\" ) or self . data_type . type is None : raise ValueError ( \"Invalid schema; undefined type\" ) self . type_name = self . data_type . type # this is kind of an ugly way to grab the value type from the schema type... # mostly b/c we are using internal knowledge of TypedObject.__typemap__ if self . type_name not in PropertyValue . __typemap__ : raise TypeError ( f \"Invalid schema; missing value type ' { self . type_name } '\" ) self . value_type = PropertyValue . __typemap__ [ self . type_name ] def bind ( self , obj ): \"\"\"Binds this property to the given object.\"\"\" if not isinstance ( obj , ConnectedPage ): raise TypeError ( \"Properties must be used in a ConnectedPage object\" ) # XXX should we do any additional error checking on the object? self . parent = obj self . page_data = self . parent . _notional__page self . session = self . parent . _notional__session def get ( self ): \"\"\"Return the current value of the property as a python object.\"\"\" log . debug ( \"fget :: %s [ %s ]\" , self . type_name , self . name ) # TODO raise instead? if self . page_data is None : return None try : prop = self . page_data [ self . name ] except AttributeError : if self . default == ... : raise AttributeError ( f \"Missing property: ' { self . name } '\" ) return self . default if not isinstance ( prop , self . value_type ): raise TypeError ( \"Type mismatch\" ) if hasattr ( prop , \"Value\" ): return prop . Value return prop def set ( self , value ): \"\"\"Set the property to the given value.\"\"\" log . debug ( \"fset :: %s [ %s ] => %s \" , self . type_name , self . name , type ( value )) # TODO raise instead? if self . page_data is None : return if isinstance ( value , self . value_type ): prop = value elif hasattr ( self . value_type , \"__compose__\" ): prop = self . value_type . __compose__ ( value ) else : raise TypeError ( f \"Unsupported value type for ' { self . type_name } '\" ) # update the property on the server (which will refresh the local data) self . session . pages . update ( self . page_data , ** { self . name : prop }) def delete ( self ): \"\"\"Delete the value assotiated with this property.\"\"\" # TODO raise instead? if self . page_data is None : return empty = self . value_type () self . session . pages . update ( self . page_data , ** { self . name : empty })","title":"ConnectedProperty"},{"location":"reference/orm/#notional.orm.ConnectedProperty.__init__","text":"Initialize the property wrapper. :param name: the name of this property as it appears on Notional :param schema: the PropertyObject that defines the type of this property :param default: an optional parameter that will return a default value if one is not provided by the API Source code in notional/orm.py def __init__ ( self , name , schema , default =... ): \"\"\"Initialize the property wrapper. :param name: the name of this property as it appears on Notional :param schema: the PropertyObject that defines the type of this property :param default: an optional parameter that will return a default value if one is not provided by the API \"\"\" if name is None or len ( name ) == 0 : raise ValueError ( \"Must provide a valid property name\" ) if schema is None : raise ValueError ( \"Invalid schema; cannot be None\" ) self . name = name self . default = default self . schema = schema self . data_type = type ( schema ) if not hasattr ( self . data_type , \"type\" ) or self . data_type . type is None : raise ValueError ( \"Invalid schema; undefined type\" ) self . type_name = self . data_type . type # this is kind of an ugly way to grab the value type from the schema type... # mostly b/c we are using internal knowledge of TypedObject.__typemap__ if self . type_name not in PropertyValue . __typemap__ : raise TypeError ( f \"Invalid schema; missing value type ' { self . type_name } '\" ) self . value_type = PropertyValue . __typemap__ [ self . type_name ]","title":"__init__()"},{"location":"reference/orm/#notional.orm.ConnectedProperty.bind","text":"Binds this property to the given object. Source code in notional/orm.py def bind ( self , obj ): \"\"\"Binds this property to the given object.\"\"\" if not isinstance ( obj , ConnectedPage ): raise TypeError ( \"Properties must be used in a ConnectedPage object\" ) # XXX should we do any additional error checking on the object? self . parent = obj self . page_data = self . parent . _notional__page self . session = self . parent . _notional__session","title":"bind()"},{"location":"reference/orm/#notional.orm.ConnectedProperty.delete","text":"Delete the value assotiated with this property. Source code in notional/orm.py def delete ( self ): \"\"\"Delete the value assotiated with this property.\"\"\" # TODO raise instead? if self . page_data is None : return empty = self . value_type () self . session . pages . update ( self . page_data , ** { self . name : empty })","title":"delete()"},{"location":"reference/orm/#notional.orm.ConnectedProperty.get","text":"Return the current value of the property as a python object. Source code in notional/orm.py def get ( self ): \"\"\"Return the current value of the property as a python object.\"\"\" log . debug ( \"fget :: %s [ %s ]\" , self . type_name , self . name ) # TODO raise instead? if self . page_data is None : return None try : prop = self . page_data [ self . name ] except AttributeError : if self . default == ... : raise AttributeError ( f \"Missing property: ' { self . name } '\" ) return self . default if not isinstance ( prop , self . value_type ): raise TypeError ( \"Type mismatch\" ) if hasattr ( prop , \"Value\" ): return prop . Value return prop","title":"get()"},{"location":"reference/orm/#notional.orm.ConnectedProperty.set","text":"Set the property to the given value. Source code in notional/orm.py def set ( self , value ): \"\"\"Set the property to the given value.\"\"\" log . debug ( \"fset :: %s [ %s ] => %s \" , self . type_name , self . name , type ( value )) # TODO raise instead? if self . page_data is None : return if isinstance ( value , self . value_type ): prop = value elif hasattr ( self . value_type , \"__compose__\" ): prop = self . value_type . __compose__ ( value ) else : raise TypeError ( f \"Unsupported value type for ' { self . type_name } '\" ) # update the property on the server (which will refresh the local data) self . session . pages . update ( self . page_data , ** { self . name : prop })","title":"set()"},{"location":"reference/orm/#notional.orm.Property","text":"Define a property for a Notion Page object. Internally, this method uses a custom wrapper to manage the property methods. :param name: the Notion table property name :param data_type: the schema that defines this property (default = RichText) :param default: a default value when creating new objects Source code in notional/orm.py def Property ( name , schema = None , default =... ): \"\"\"Define a property for a Notion Page object. Internally, this method uses a custom wrapper to manage the property methods. :param name: the Notion table property name :param data_type: the schema that defines this property (default = RichText) :param default: a default value when creating new objects \"\"\" log . debug ( \"creating new Property: %s \" , name ) if schema is None : schema = RichText () elif not isinstance ( schema , PropertyObject ): raise TypeError ( \"Invalid data_type; not a PropertyObject\" ) cprop = ConnectedProperty ( name = name , schema = schema , default = default , ) def fget ( self ): \"\"\"Return the current value of the property as a python object.\"\"\" cprop . bind ( self ) return cprop . get () def fset ( self , value ): \"\"\"Set the property to the given value.\"\"\" cprop . bind ( self ) cprop . set ( value ) def fdel ( self ): \"\"\"Delete the value for this property.\"\"\" cprop . bind ( self ) cprop . delete () return property ( fget , fset , fdel )","title":"Property()"},{"location":"reference/orm/#notional.orm.connected_page","text":"Return a base class for \"connected\" pages through the Notion API. Subclasses may then inherit from the returned class to define custom ORM types. :param session: an active Notional session where the database is hosted :param source_db: if provided, the returned class will use the ID and schema of this object to initialize the connected page :param schema: if provided, the returned class will contain properties according to the schema provided; defaults to None :param cls: the returned class will inherit from the given class, which must be a sublass of ConnectedPage ; defaults to ConnectedPage Source code in notional/orm.py def connected_page ( session = None , source_db = None , schema = None , cls = None ): \"\"\"Return a base class for \"connected\" pages through the Notion API. Subclasses may then inherit from the returned class to define custom ORM types. :param session: an active Notional session where the database is hosted :param source_db: if provided, the returned class will use the ID and schema of this object to initialize the connected page :param schema: if provided, the returned class will contain properties according to the schema provided; defaults to `None` :param cls: the returned class will inherit from the given class, which must be a sublass of `ConnectedPage`; defaults to `ConnectedPage` \"\"\" if cls is None : cls = ConnectedPage elif not issubclass ( cls , ConnectedPage ): raise ValueError ( \"'cls' must subclass ConnectedPage\" ) if source_db is None : dbid = None elif not isinstance ( source_db , Database ): raise ValueError ( \"'source_db' must be a Database\" ) else : if schema is None : schema = source_db . properties dbid = source_db . id factory = ConnectedPageFactory ( base = cls ) return factory ( session = session , database = dbid , schema = schema , )","title":"connected_page()"},{"location":"reference/parser/","text":"Utilities for parsing other document types in Notion. These parsers provide an alternative to the \"Import\" cabilities of the Notion client and Notion Web Clipper. Perhaps that capability will be exposed to the API in the future, which would effectively render these parsers unnecessary. CsvParser ( DocumentParser ) A standard CSV parser. Contents of this parser are available as a list of page properties according to the determined schema. Specifically, this content follows the format: ``` [ { column_1_name: entry_1_column_1_data, column_2_name: entry_1_column_2_data, column_3_name: entry_1_column_3_data, ... }, { column_1_name: entry_2_column_1_data, column_2_name: entry_2_column_2_data, column_3_name: entry_2_column_3_data, ... }, ... ] ``` Source code in notional/parser.py class CsvParser ( DocumentParser ): \"\"\"A standard CSV parser. Contents of this parser are available as a list of page properties according to the determined schema. Specifically, this content follows the format: ``` [ { column_1_name: entry_1_column_1_data, column_2_name: entry_1_column_2_data, column_3_name: entry_1_column_3_data, ... }, { column_1_name: entry_2_column_1_data, column_2_name: entry_2_column_2_data, column_3_name: entry_2_column_3_data, ... }, ... ] ``` \"\"\" schema : dict def __init__ ( self , header_row = True , title_column = 0 ): \"\"\"Initialize a new `CsvParser`. :param header_row: indicates that data will have a header row (for the schema) :param title_column: set the column in data to use for page titles \"\"\" super () . __init__ () self . _has_header = header_row self . _title_index = title_column self . schema = {} self . _field_names = [] def parse ( self , data ): \"\"\"Parse the given CSV data. Upon return, the following properties will be available in the parser: `schema`: a computed schema for the supplied data `title`: the name of the CSV file being parsed (if available) `content`: a list of page properties with the tabular data \"\"\" super () . parse ( data ) if isinstance ( data , str ): data = io . StringIO ( data , newline = \"\" ) reader = csv . reader ( data ) self . _process ( reader ) def _process ( self , reader ): # build the schema based on the first row try : header = next ( reader ) except StopIteration : raise ValueError ( \"Invalid CSV: empty data\" ) if self . _has_header : self . _build_schema ( * header ) else : cols = [ str ( num ) for num in range ( len ( header ))] self . _build_schema ( * cols ) self . _build_record ( * header ) # process remaining entries for entry in reader : self . _build_record ( * entry ) def _build_schema ( self , * fields ): if fields is None or len ( fields ) < 1 : raise ValueError ( \"Invalid CSV: empty header\" ) column = 0 for field in fields : field = field . strip () while field in self . _field_names : field = f \" { field } _ { column } \" if column == self . _title_index : self . schema [ field ] = schema . Title () else : self . schema [ field ] = schema . RichText () self . _field_names . append ( field ) column += 1 def _build_record ( self , * fields ): if len ( fields ) != len ( self . _field_names ): raise ValueError ( \"Invalid CSV: incorrect number of fields in data\" ) record = {} column = 0 for col in self . _field_names : value = fields [ column ] if column == self . _title_index : record [ col ] = types . Title [ value ] else : record [ col ] = types . RichText [ value ] column += 1 self . content . append ( record ) __init__ ( self , header_row = True , title_column = 0 ) special Initialize a new CsvParser . :param header_row: indicates that data will have a header row (for the schema) :param title_column: set the column in data to use for page titles Source code in notional/parser.py def __init__ ( self , header_row = True , title_column = 0 ): \"\"\"Initialize a new `CsvParser`. :param header_row: indicates that data will have a header row (for the schema) :param title_column: set the column in data to use for page titles \"\"\" super () . __init__ () self . _has_header = header_row self . _title_index = title_column self . schema = {} self . _field_names = [] parse ( self , data ) Parse the given CSV data. Upon return, the following properties will be available in the parser: schema : a computed schema for the supplied data title : the name of the CSV file being parsed (if available) content : a list of page properties with the tabular data Source code in notional/parser.py def parse ( self , data ): \"\"\"Parse the given CSV data. Upon return, the following properties will be available in the parser: `schema`: a computed schema for the supplied data `title`: the name of the CSV file being parsed (if available) `content`: a list of page properties with the tabular data \"\"\" super () . parse ( data ) if isinstance ( data , str ): data = io . StringIO ( data , newline = \"\" ) reader = csv . reader ( data ) self . _process ( reader ) DocumentParser ( ABC ) Base class for document parsers. Source code in notional/parser.py class DocumentParser ( ABC ): \"\"\"Base class for document parsers.\"\"\" title : str content : list def __init__ ( self ): \"\"\"Initlize the document parser.\"\"\" self . title = None self . content = [] @abstractmethod def parse ( self , data ): \"\"\"Parse the given data. This method will attempt to determine a default name for the document from the data source. Subclasses should call this method when implemting `parse()` locally. \"\"\" if hasattr ( data , \"name\" ): self . title = basename ( data . name ) __init__ ( self ) special Initlize the document parser. Source code in notional/parser.py def __init__ ( self ): \"\"\"Initlize the document parser.\"\"\" self . title = None self . content = [] parse ( self , data ) Parse the given data. This method will attempt to determine a default name for the document from the data source. Subclasses should call this method when implemting parse() locally. Source code in notional/parser.py @abstractmethod def parse ( self , data ): \"\"\"Parse the given data. This method will attempt to determine a default name for the document from the data source. Subclasses should call this method when implemting `parse()` locally. \"\"\" if hasattr ( data , \"name\" ): self . title = basename ( data . name ) HtmlParser ( DocumentParser ) An HTML parser that leverages the WHATWG HTML spec. Source code in notional/parser.py class HtmlParser ( DocumentParser ): \"\"\"An HTML parser that leverages the WHATWG HTML spec.\"\"\" meta : dict def __init__ ( self , base = None ): \"\"\"Initialize an empty `HtmlParser`. :param base: the base URL for resolving relative paths \"\"\" super () . __init__ () self . _base_url = base self . meta = {} self . _current_href = None self . _current_text_style = Annotations () def parse ( self , data ): \"\"\"Parse the given HTML data. Upon return, the following properties will be available in the parser: `title`: contents of the `<title>` element if found `content`: a list of blocks containing rendered content from the HTML data `meta`: a dictionary of any `<meta>` tags that were found \"\"\" super () . parse ( data ) doc = html5lib . parse ( data , namespaceHTMLElements = False ) self . _render ( doc ) def _render ( self , elem , parent = None ): \"\"\"Render the given element as a child of `parent`. This method will look for an appropriate `render_*` method to handle the given tag name. If there is not an available method, the element will be ignored. :param elem: the ElementTree object to render :param parent: the parent block for the rendered content or `None` \"\"\" log . debug ( \"rendering element - %s :: %s \" , elem . tag , type ( parent )) if parent is None : parent = self . content if hasattr ( self , f \"_render_ { elem . tag } \" ): log . debug ( \"handler func -- _render_ %s \" , elem . tag ) pfunc = getattr ( self , f \"_render_ { elem . tag } \" ) pfunc ( elem , parent ) log . debug ( \"block complete; %d total block(s)\" , len ( self . content )) def _render_a ( self , elem , parent ): self . _current_href = elem . get ( \"href\" ) self . _process_contents ( elem , parent = parent ) self . _current_href = None def _render_b ( self , elem , parent ): self . _current_text_style . bold = True self . _process_contents ( elem , parent = parent ) self . _current_text_style . bold = False def _render_base ( self , elem , parent ): base = elem . get ( \"href\" ) if base is not None : self . _base_url = base def _render_blockquote ( self , elem , parent ): block = blocks . Quote () self . _process_contents ( elem , parent = block ) parent . append ( block ) def _render_body ( self , elem , parent ): self . _process_contents ( elem , parent = parent ) def _render_br ( self , elem , parent ): if isinstance ( parent , blocks . TextBlock ): parent . concat ( \" \\n \" ) def _render_code ( self , elem , parent ): self . _current_text_style . code = True self . _process_contents ( elem , parent = parent ) self . _current_text_style . code = False def _render_dd ( self , elem , parent ): self . _process_contents ( elem , parent = parent ) def _render_del ( self , elem , parent ): self . _current_text_style . strikethrough = True self . _process_contents ( elem , parent = parent ) self . _current_text_style . strikethrough = False def _render_div ( self , elem , parent ): self . _process_contents ( elem , parent ) def _render_dl ( self , elem , parent ): dl = blocks . Paragraph () self . _process_contents ( elem , parent = dl ) parent . append ( dl ) def _render_dt ( self , elem , parent ): self . _process_contents ( elem , parent = parent ) def _render_em ( self , elem , parent ): self . _render_i ( elem , parent ) def _render_h1 ( self , elem , parent ): h1 = blocks . Heading1 () self . _process_contents ( elem , parent = h1 ) parent . append ( h1 ) def _render_h2 ( self , elem , parent ): h2 = blocks . Heading2 () self . _process_contents ( elem , parent = h2 ) parent . append ( h2 ) def _render_h3 ( self , elem , parent ): h3 = blocks . Heading3 () self . _process_contents ( elem , parent = h3 ) parent . append ( h3 ) def _render_h4 ( self , elem , parent ): self . _render_h3 ( elem , parent ) def _render_h5 ( self , elem , parent ): self . _render_h3 ( elem , parent ) def _render_h6 ( self , elem , parent ): self . _render_h3 ( elem , parent ) def _render_head ( self , elem , parent ): self . _process_contents ( elem , parent = parent ) def _render_hgroup ( self , elem , parent ): self . _process_contents ( elem , parent = parent ) def _render_hr ( self , elem , parent ): parent . append ( blocks . Divider ()) def _render_html ( self , elem , parent ): self . _process_contents ( elem , parent = parent ) def _render_i ( self , elem , parent ): self . _current_text_style . italic = True self . _process_contents ( elem , parent = parent ) self . _current_text_style . italic = False def _render_iframe ( self , elem , parent ): src = elem . get ( \"src\" ) if src is not None : block = blocks . Embed [ src ] parent . append ( block ) def _render_img ( self , elem , parent ): src = elem . get ( \"src\" ) # TODO use self._base_url for relative paths # TODO support embedded images (data:image) as HostedFile... if src is not None : file = types . ExternalFile [ src ] img = blocks . Image ( image = file ) parent . append ( img ) def _render_ins ( self , elem , parent ): self . _render_u ( elem , parent ) def _render_kbd ( self , elem , parent ): self . _render_code ( elem , parent ) def _render_li ( self , elem , parent ): self . _process_contents ( elem , parent ) def _render_menu ( self , elem , parent ): self . _render_ul ( elem , parent ) def _render_meta ( self , elem , parent ): name = elem . get ( \"name\" ) value = elem . get ( \"content\" ) if name and value : self . meta [ name ] = value def _render_object ( self , elem , parent ): # XXX support 'data' attribute as an embed or upload? self . _process_contents ( elem , parent = parent ) def _render_ol ( self , elem , parent ): self . _process_list ( elem , parent , blocks . NumberedListItem ) def _render_p ( self , elem , parent ): para = blocks . Paragraph () self . _process_contents ( elem , parent = para ) parent . append ( para ) def _render_pre ( self , elem , parent ): block = blocks . Code () self . _process_contents ( elem , parent = block ) parent . append ( block ) def _render_s ( self , elem , parent ): self . _render_del ( elem , parent ) def _render_samp ( self , elem , parent ): self . _render_code ( elem , parent ) def _render_span ( self , elem , parent ): self . _process_contents ( elem , parent = parent ) def _render_strike ( self , elem , parent ): self . _render_del ( elem , parent ) def _render_strong ( self , elem , parent ): self . _render_b ( elem , parent ) def _render_table ( self , elem , parent ): table = blocks . Table () self . _process_contents ( elem , parent = table ) if table . Width > 0 : parent . append ( table ) def _render_tbody ( self , elem , parent ): self . _process_contents ( elem , parent ) def _render_td ( self , elem , parent ): if not isinstance ( parent , blocks . TableRow ): raise TypeError ( \"Invalid parent for <td>\" ) if elem_has_text ( elem ): self . _process_contents ( elem , parent = parent ) else : self . _append_text ( \"\" , parent ) def _render_tfoot ( self , elem , parent ): self . _process_contents ( elem , parent = parent ) def _render_th ( self , elem , parent ): self . _render_td ( elem , parent = parent ) def _render_thead ( self , elem , parent ): if not isinstance ( parent , blocks . Table ): raise TypeError ( \"Invalid parent for <thead>\" ) parent . table . has_column_header = True self . _process_contents ( elem , parent = parent ) def _render_title ( self , elem , parent ): self . title = gather_text ( elem ) def _render_tr ( self , elem , parent ): if not isinstance ( parent , blocks . Table ): raise TypeError ( \"Invalid parent for <tr>\" ) row = blocks . TableRow () for td in elem . findall ( \"td\" ): self . _render ( td , parent = row ) parent . append ( row ) def _render_tt ( self , elem , parent ): self . _render_pre ( elem , parent = parent ) def _render_u ( self , elem , parent ): self . _current_text_style . underline = True self . _process_contents ( elem , parent = parent ) self . _current_text_style . underline = False def _render_ul ( self , elem , parent ): self . _process_list ( elem , parent , blocks . BulletedListItem ) def _render_var ( self , elem , parent ): self . _render_code ( elem , parent = parent ) def _append_text ( self , text , parent ): \"\"\"Append text to the given parent using current style and link information. If the parent does not support text children, the text will be ignored. When appropriate, whitespace in the text will be removed. \"\"\" log . debug ( \"appending text :: %s => ' %s '\" , parent . type , truncate ( text , 10 )) if not isinstance ( parent , blocks . Code ): text = condense_text ( text ) obj = TextObject [ text , self . _current_href , self . _current_text_style ] if isinstance ( parent , blocks . TextBlock ): if obj is not None : parent . concat ( obj ) elif isinstance ( parent , blocks . TableRow ): parent . append ( obj ) def _process_contents ( self , elem , parent ): \"\"\"Process the contents of the given element as children of `parent`. This will process all children of the element, including text and nodes. \"\"\" log . debug ( \"processing contents :: %s %s \" , elem . tag , type ( parent )) # empty elements don't need text processing... if not elem_has_text ( elem , with_children = False ): has_text = False # TextBlock's can hold text directly... elif isinstance ( parent , blocks . TextBlock ): has_text = True # so can TableRow's... elif isinstance ( parent , blocks . TableRow ): has_text = True # otherwise, we need a new parent to hold text... else : has_text = True new_parent = blocks . Paragraph () parent . append ( new_parent ) parent = new_parent if has_text : self . _append_text ( elem . text , parent ) for child in elem : self . _render ( child , parent ) if has_text : self . _append_text ( child . tail , parent ) if isinstance ( parent , blocks . TextBlock ): strip_text_block ( parent ) def _process_list ( self , elem , parent , kind ): \"\"\"Process contents of the given element as a list. :param elem: the element to process :param parent: the parent for list items and nested lists :param kind: a class used to render `<li>` tags \"\"\" list_parent = parent for child in elem : if child . tag == \"li\" : list_parent = kind () self . _render ( child , parent = list_parent ) parent . append ( list_parent ) else : self . _render ( child , list_parent ) def _process_img_data ( self , elem ): import base64 import tempfile log . debug ( \"processing image\" ) # TODO this probably needs more error handling and better flow img_src = elem [ \"src\" ] m = img_data_re . match ( img_src ) if m is None : raise ValueError ( \"Image data missing\" ) img_type = m . groups ()[ 0 ] img_data_enc = m . groups ()[ 1 ] img_data_str = m . groups ()[ 2 ] log . debug ( \"decoding embedded image: %s [ %s ]\" , img_type , img_data_enc ) if img_data_enc == \"base64\" : log . debug ( \"decoding base64 image: %d bytes\" , len ( img_data_str )) img_data_b64 = img_data_str . encode ( \"ascii\" ) img_data = base64 . b64decode ( img_data_b64 ) else : raise ValueError ( f \"Unsupported img encoding: { img_data_enc } \" ) log . debug ( \"preparing %d bytes for image upload\" , len ( img_data )) with tempfile . NamedTemporaryFile ( suffix = f \". { img_type } \" ) as fp : log . debug ( \"using temporary file: %s \" , fp . name ) fp . write ( img_data ) # TODO upload the image to Notion __init__ ( self , base = None ) special Initialize an empty HtmlParser . :param base: the base URL for resolving relative paths Source code in notional/parser.py def __init__ ( self , base = None ): \"\"\"Initialize an empty `HtmlParser`. :param base: the base URL for resolving relative paths \"\"\" super () . __init__ () self . _base_url = base self . meta = {} self . _current_href = None self . _current_text_style = Annotations () parse ( self , data ) Parse the given HTML data. Upon return, the following properties will be available in the parser: title : contents of the <title> element if found content : a list of blocks containing rendered content from the HTML data meta : a dictionary of any <meta> tags that were found Source code in notional/parser.py def parse ( self , data ): \"\"\"Parse the given HTML data. Upon return, the following properties will be available in the parser: `title`: contents of the `<title>` element if found `content`: a list of blocks containing rendered content from the HTML data `meta`: a dictionary of any `<meta>` tags that were found \"\"\" super () . parse ( data ) doc = html5lib . parse ( data , namespaceHTMLElements = False ) self . _render ( doc ) condense_text ( text ) Collapse contiguous whitespace from the given text. Source code in notional/parser.py def condense_text ( text ): \"\"\"Collapse contiguous whitespace from the given text.\"\"\" if text is None : return None return re . sub ( r \"\\s+\" , \" \" , text , flags = re . MULTILINE ) elem_has_text ( elem , with_children = True ) Determine if the element has any visible text. :param elem: the element to examine :param with_children: whether to include children nodes in the search Source code in notional/parser.py def elem_has_text ( elem , with_children = True ): \"\"\"Determine if the element has any visible text. :param elem: the element to examine :param with_children: whether to include children nodes in the search \"\"\" # first, check the direct text of the element... if elem . text is not None and not elem . text . isspace (): return True # now, we need to check the tail of each child... for child in elem : if with_children and elem_has_text ( child ): return True if child . tail is None : continue if not child . tail . isspace (): return True return False gather_text ( elem ) Return all text from the element and children. Source code in notional/parser.py def gather_text ( elem ): \"\"\"Return all text from the element and children.\"\"\" text = \"\" . join ( elem . itertext ()) return normalize_text ( text ) normalize_text ( text ) Remove extra whitespace from the given text. Source code in notional/parser.py def normalize_text ( text ): \"\"\"Remove extra whitespace from the given text.\"\"\" if text is None : return None text = text . strip () return condense_text ( text ) strip_text_block ( block ) Remove leading and trailing whitespace from text in the given block. Source code in notional/parser.py def strip_text_block ( block ): \"\"\"Remove leading and trailing whitespace from text in the given block.\"\"\" if not isinstance ( block , blocks . TextBlock ): return if isinstance ( block , blocks . Code ): return block_text = block . __text__ if block_text is not None and len ( block_text ) > 0 : lstrip ( block_text [ 0 ]) rstrip ( block_text [ - 1 ])","title":"Parser"},{"location":"reference/parser/#notional.parser.CsvParser","text":"A standard CSV parser. Contents of this parser are available as a list of page properties according to the determined schema. Specifically, this content follows the format: ``` [ { column_1_name: entry_1_column_1_data, column_2_name: entry_1_column_2_data, column_3_name: entry_1_column_3_data, ... }, { column_1_name: entry_2_column_1_data, column_2_name: entry_2_column_2_data, column_3_name: entry_2_column_3_data, ... }, ... ] ``` Source code in notional/parser.py class CsvParser ( DocumentParser ): \"\"\"A standard CSV parser. Contents of this parser are available as a list of page properties according to the determined schema. Specifically, this content follows the format: ``` [ { column_1_name: entry_1_column_1_data, column_2_name: entry_1_column_2_data, column_3_name: entry_1_column_3_data, ... }, { column_1_name: entry_2_column_1_data, column_2_name: entry_2_column_2_data, column_3_name: entry_2_column_3_data, ... }, ... ] ``` \"\"\" schema : dict def __init__ ( self , header_row = True , title_column = 0 ): \"\"\"Initialize a new `CsvParser`. :param header_row: indicates that data will have a header row (for the schema) :param title_column: set the column in data to use for page titles \"\"\" super () . __init__ () self . _has_header = header_row self . _title_index = title_column self . schema = {} self . _field_names = [] def parse ( self , data ): \"\"\"Parse the given CSV data. Upon return, the following properties will be available in the parser: `schema`: a computed schema for the supplied data `title`: the name of the CSV file being parsed (if available) `content`: a list of page properties with the tabular data \"\"\" super () . parse ( data ) if isinstance ( data , str ): data = io . StringIO ( data , newline = \"\" ) reader = csv . reader ( data ) self . _process ( reader ) def _process ( self , reader ): # build the schema based on the first row try : header = next ( reader ) except StopIteration : raise ValueError ( \"Invalid CSV: empty data\" ) if self . _has_header : self . _build_schema ( * header ) else : cols = [ str ( num ) for num in range ( len ( header ))] self . _build_schema ( * cols ) self . _build_record ( * header ) # process remaining entries for entry in reader : self . _build_record ( * entry ) def _build_schema ( self , * fields ): if fields is None or len ( fields ) < 1 : raise ValueError ( \"Invalid CSV: empty header\" ) column = 0 for field in fields : field = field . strip () while field in self . _field_names : field = f \" { field } _ { column } \" if column == self . _title_index : self . schema [ field ] = schema . Title () else : self . schema [ field ] = schema . RichText () self . _field_names . append ( field ) column += 1 def _build_record ( self , * fields ): if len ( fields ) != len ( self . _field_names ): raise ValueError ( \"Invalid CSV: incorrect number of fields in data\" ) record = {} column = 0 for col in self . _field_names : value = fields [ column ] if column == self . _title_index : record [ col ] = types . Title [ value ] else : record [ col ] = types . RichText [ value ] column += 1 self . content . append ( record )","title":"CsvParser"},{"location":"reference/parser/#notional.parser.CsvParser.__init__","text":"Initialize a new CsvParser . :param header_row: indicates that data will have a header row (for the schema) :param title_column: set the column in data to use for page titles Source code in notional/parser.py def __init__ ( self , header_row = True , title_column = 0 ): \"\"\"Initialize a new `CsvParser`. :param header_row: indicates that data will have a header row (for the schema) :param title_column: set the column in data to use for page titles \"\"\" super () . __init__ () self . _has_header = header_row self . _title_index = title_column self . schema = {} self . _field_names = []","title":"__init__()"},{"location":"reference/parser/#notional.parser.CsvParser.parse","text":"Parse the given CSV data. Upon return, the following properties will be available in the parser: schema : a computed schema for the supplied data title : the name of the CSV file being parsed (if available) content : a list of page properties with the tabular data Source code in notional/parser.py def parse ( self , data ): \"\"\"Parse the given CSV data. Upon return, the following properties will be available in the parser: `schema`: a computed schema for the supplied data `title`: the name of the CSV file being parsed (if available) `content`: a list of page properties with the tabular data \"\"\" super () . parse ( data ) if isinstance ( data , str ): data = io . StringIO ( data , newline = \"\" ) reader = csv . reader ( data ) self . _process ( reader )","title":"parse()"},{"location":"reference/parser/#notional.parser.DocumentParser","text":"Base class for document parsers. Source code in notional/parser.py class DocumentParser ( ABC ): \"\"\"Base class for document parsers.\"\"\" title : str content : list def __init__ ( self ): \"\"\"Initlize the document parser.\"\"\" self . title = None self . content = [] @abstractmethod def parse ( self , data ): \"\"\"Parse the given data. This method will attempt to determine a default name for the document from the data source. Subclasses should call this method when implemting `parse()` locally. \"\"\" if hasattr ( data , \"name\" ): self . title = basename ( data . name )","title":"DocumentParser"},{"location":"reference/parser/#notional.parser.DocumentParser.__init__","text":"Initlize the document parser. Source code in notional/parser.py def __init__ ( self ): \"\"\"Initlize the document parser.\"\"\" self . title = None self . content = []","title":"__init__()"},{"location":"reference/parser/#notional.parser.DocumentParser.parse","text":"Parse the given data. This method will attempt to determine a default name for the document from the data source. Subclasses should call this method when implemting parse() locally. Source code in notional/parser.py @abstractmethod def parse ( self , data ): \"\"\"Parse the given data. This method will attempt to determine a default name for the document from the data source. Subclasses should call this method when implemting `parse()` locally. \"\"\" if hasattr ( data , \"name\" ): self . title = basename ( data . name )","title":"parse()"},{"location":"reference/parser/#notional.parser.HtmlParser","text":"An HTML parser that leverages the WHATWG HTML spec. Source code in notional/parser.py class HtmlParser ( DocumentParser ): \"\"\"An HTML parser that leverages the WHATWG HTML spec.\"\"\" meta : dict def __init__ ( self , base = None ): \"\"\"Initialize an empty `HtmlParser`. :param base: the base URL for resolving relative paths \"\"\" super () . __init__ () self . _base_url = base self . meta = {} self . _current_href = None self . _current_text_style = Annotations () def parse ( self , data ): \"\"\"Parse the given HTML data. Upon return, the following properties will be available in the parser: `title`: contents of the `<title>` element if found `content`: a list of blocks containing rendered content from the HTML data `meta`: a dictionary of any `<meta>` tags that were found \"\"\" super () . parse ( data ) doc = html5lib . parse ( data , namespaceHTMLElements = False ) self . _render ( doc ) def _render ( self , elem , parent = None ): \"\"\"Render the given element as a child of `parent`. This method will look for an appropriate `render_*` method to handle the given tag name. If there is not an available method, the element will be ignored. :param elem: the ElementTree object to render :param parent: the parent block for the rendered content or `None` \"\"\" log . debug ( \"rendering element - %s :: %s \" , elem . tag , type ( parent )) if parent is None : parent = self . content if hasattr ( self , f \"_render_ { elem . tag } \" ): log . debug ( \"handler func -- _render_ %s \" , elem . tag ) pfunc = getattr ( self , f \"_render_ { elem . tag } \" ) pfunc ( elem , parent ) log . debug ( \"block complete; %d total block(s)\" , len ( self . content )) def _render_a ( self , elem , parent ): self . _current_href = elem . get ( \"href\" ) self . _process_contents ( elem , parent = parent ) self . _current_href = None def _render_b ( self , elem , parent ): self . _current_text_style . bold = True self . _process_contents ( elem , parent = parent ) self . _current_text_style . bold = False def _render_base ( self , elem , parent ): base = elem . get ( \"href\" ) if base is not None : self . _base_url = base def _render_blockquote ( self , elem , parent ): block = blocks . Quote () self . _process_contents ( elem , parent = block ) parent . append ( block ) def _render_body ( self , elem , parent ): self . _process_contents ( elem , parent = parent ) def _render_br ( self , elem , parent ): if isinstance ( parent , blocks . TextBlock ): parent . concat ( \" \\n \" ) def _render_code ( self , elem , parent ): self . _current_text_style . code = True self . _process_contents ( elem , parent = parent ) self . _current_text_style . code = False def _render_dd ( self , elem , parent ): self . _process_contents ( elem , parent = parent ) def _render_del ( self , elem , parent ): self . _current_text_style . strikethrough = True self . _process_contents ( elem , parent = parent ) self . _current_text_style . strikethrough = False def _render_div ( self , elem , parent ): self . _process_contents ( elem , parent ) def _render_dl ( self , elem , parent ): dl = blocks . Paragraph () self . _process_contents ( elem , parent = dl ) parent . append ( dl ) def _render_dt ( self , elem , parent ): self . _process_contents ( elem , parent = parent ) def _render_em ( self , elem , parent ): self . _render_i ( elem , parent ) def _render_h1 ( self , elem , parent ): h1 = blocks . Heading1 () self . _process_contents ( elem , parent = h1 ) parent . append ( h1 ) def _render_h2 ( self , elem , parent ): h2 = blocks . Heading2 () self . _process_contents ( elem , parent = h2 ) parent . append ( h2 ) def _render_h3 ( self , elem , parent ): h3 = blocks . Heading3 () self . _process_contents ( elem , parent = h3 ) parent . append ( h3 ) def _render_h4 ( self , elem , parent ): self . _render_h3 ( elem , parent ) def _render_h5 ( self , elem , parent ): self . _render_h3 ( elem , parent ) def _render_h6 ( self , elem , parent ): self . _render_h3 ( elem , parent ) def _render_head ( self , elem , parent ): self . _process_contents ( elem , parent = parent ) def _render_hgroup ( self , elem , parent ): self . _process_contents ( elem , parent = parent ) def _render_hr ( self , elem , parent ): parent . append ( blocks . Divider ()) def _render_html ( self , elem , parent ): self . _process_contents ( elem , parent = parent ) def _render_i ( self , elem , parent ): self . _current_text_style . italic = True self . _process_contents ( elem , parent = parent ) self . _current_text_style . italic = False def _render_iframe ( self , elem , parent ): src = elem . get ( \"src\" ) if src is not None : block = blocks . Embed [ src ] parent . append ( block ) def _render_img ( self , elem , parent ): src = elem . get ( \"src\" ) # TODO use self._base_url for relative paths # TODO support embedded images (data:image) as HostedFile... if src is not None : file = types . ExternalFile [ src ] img = blocks . Image ( image = file ) parent . append ( img ) def _render_ins ( self , elem , parent ): self . _render_u ( elem , parent ) def _render_kbd ( self , elem , parent ): self . _render_code ( elem , parent ) def _render_li ( self , elem , parent ): self . _process_contents ( elem , parent ) def _render_menu ( self , elem , parent ): self . _render_ul ( elem , parent ) def _render_meta ( self , elem , parent ): name = elem . get ( \"name\" ) value = elem . get ( \"content\" ) if name and value : self . meta [ name ] = value def _render_object ( self , elem , parent ): # XXX support 'data' attribute as an embed or upload? self . _process_contents ( elem , parent = parent ) def _render_ol ( self , elem , parent ): self . _process_list ( elem , parent , blocks . NumberedListItem ) def _render_p ( self , elem , parent ): para = blocks . Paragraph () self . _process_contents ( elem , parent = para ) parent . append ( para ) def _render_pre ( self , elem , parent ): block = blocks . Code () self . _process_contents ( elem , parent = block ) parent . append ( block ) def _render_s ( self , elem , parent ): self . _render_del ( elem , parent ) def _render_samp ( self , elem , parent ): self . _render_code ( elem , parent ) def _render_span ( self , elem , parent ): self . _process_contents ( elem , parent = parent ) def _render_strike ( self , elem , parent ): self . _render_del ( elem , parent ) def _render_strong ( self , elem , parent ): self . _render_b ( elem , parent ) def _render_table ( self , elem , parent ): table = blocks . Table () self . _process_contents ( elem , parent = table ) if table . Width > 0 : parent . append ( table ) def _render_tbody ( self , elem , parent ): self . _process_contents ( elem , parent ) def _render_td ( self , elem , parent ): if not isinstance ( parent , blocks . TableRow ): raise TypeError ( \"Invalid parent for <td>\" ) if elem_has_text ( elem ): self . _process_contents ( elem , parent = parent ) else : self . _append_text ( \"\" , parent ) def _render_tfoot ( self , elem , parent ): self . _process_contents ( elem , parent = parent ) def _render_th ( self , elem , parent ): self . _render_td ( elem , parent = parent ) def _render_thead ( self , elem , parent ): if not isinstance ( parent , blocks . Table ): raise TypeError ( \"Invalid parent for <thead>\" ) parent . table . has_column_header = True self . _process_contents ( elem , parent = parent ) def _render_title ( self , elem , parent ): self . title = gather_text ( elem ) def _render_tr ( self , elem , parent ): if not isinstance ( parent , blocks . Table ): raise TypeError ( \"Invalid parent for <tr>\" ) row = blocks . TableRow () for td in elem . findall ( \"td\" ): self . _render ( td , parent = row ) parent . append ( row ) def _render_tt ( self , elem , parent ): self . _render_pre ( elem , parent = parent ) def _render_u ( self , elem , parent ): self . _current_text_style . underline = True self . _process_contents ( elem , parent = parent ) self . _current_text_style . underline = False def _render_ul ( self , elem , parent ): self . _process_list ( elem , parent , blocks . BulletedListItem ) def _render_var ( self , elem , parent ): self . _render_code ( elem , parent = parent ) def _append_text ( self , text , parent ): \"\"\"Append text to the given parent using current style and link information. If the parent does not support text children, the text will be ignored. When appropriate, whitespace in the text will be removed. \"\"\" log . debug ( \"appending text :: %s => ' %s '\" , parent . type , truncate ( text , 10 )) if not isinstance ( parent , blocks . Code ): text = condense_text ( text ) obj = TextObject [ text , self . _current_href , self . _current_text_style ] if isinstance ( parent , blocks . TextBlock ): if obj is not None : parent . concat ( obj ) elif isinstance ( parent , blocks . TableRow ): parent . append ( obj ) def _process_contents ( self , elem , parent ): \"\"\"Process the contents of the given element as children of `parent`. This will process all children of the element, including text and nodes. \"\"\" log . debug ( \"processing contents :: %s %s \" , elem . tag , type ( parent )) # empty elements don't need text processing... if not elem_has_text ( elem , with_children = False ): has_text = False # TextBlock's can hold text directly... elif isinstance ( parent , blocks . TextBlock ): has_text = True # so can TableRow's... elif isinstance ( parent , blocks . TableRow ): has_text = True # otherwise, we need a new parent to hold text... else : has_text = True new_parent = blocks . Paragraph () parent . append ( new_parent ) parent = new_parent if has_text : self . _append_text ( elem . text , parent ) for child in elem : self . _render ( child , parent ) if has_text : self . _append_text ( child . tail , parent ) if isinstance ( parent , blocks . TextBlock ): strip_text_block ( parent ) def _process_list ( self , elem , parent , kind ): \"\"\"Process contents of the given element as a list. :param elem: the element to process :param parent: the parent for list items and nested lists :param kind: a class used to render `<li>` tags \"\"\" list_parent = parent for child in elem : if child . tag == \"li\" : list_parent = kind () self . _render ( child , parent = list_parent ) parent . append ( list_parent ) else : self . _render ( child , list_parent ) def _process_img_data ( self , elem ): import base64 import tempfile log . debug ( \"processing image\" ) # TODO this probably needs more error handling and better flow img_src = elem [ \"src\" ] m = img_data_re . match ( img_src ) if m is None : raise ValueError ( \"Image data missing\" ) img_type = m . groups ()[ 0 ] img_data_enc = m . groups ()[ 1 ] img_data_str = m . groups ()[ 2 ] log . debug ( \"decoding embedded image: %s [ %s ]\" , img_type , img_data_enc ) if img_data_enc == \"base64\" : log . debug ( \"decoding base64 image: %d bytes\" , len ( img_data_str )) img_data_b64 = img_data_str . encode ( \"ascii\" ) img_data = base64 . b64decode ( img_data_b64 ) else : raise ValueError ( f \"Unsupported img encoding: { img_data_enc } \" ) log . debug ( \"preparing %d bytes for image upload\" , len ( img_data )) with tempfile . NamedTemporaryFile ( suffix = f \". { img_type } \" ) as fp : log . debug ( \"using temporary file: %s \" , fp . name ) fp . write ( img_data ) # TODO upload the image to Notion","title":"HtmlParser"},{"location":"reference/parser/#notional.parser.HtmlParser.__init__","text":"Initialize an empty HtmlParser . :param base: the base URL for resolving relative paths Source code in notional/parser.py def __init__ ( self , base = None ): \"\"\"Initialize an empty `HtmlParser`. :param base: the base URL for resolving relative paths \"\"\" super () . __init__ () self . _base_url = base self . meta = {} self . _current_href = None self . _current_text_style = Annotations ()","title":"__init__()"},{"location":"reference/parser/#notional.parser.HtmlParser.parse","text":"Parse the given HTML data. Upon return, the following properties will be available in the parser: title : contents of the <title> element if found content : a list of blocks containing rendered content from the HTML data meta : a dictionary of any <meta> tags that were found Source code in notional/parser.py def parse ( self , data ): \"\"\"Parse the given HTML data. Upon return, the following properties will be available in the parser: `title`: contents of the `<title>` element if found `content`: a list of blocks containing rendered content from the HTML data `meta`: a dictionary of any `<meta>` tags that were found \"\"\" super () . parse ( data ) doc = html5lib . parse ( data , namespaceHTMLElements = False ) self . _render ( doc )","title":"parse()"},{"location":"reference/parser/#notional.parser.condense_text","text":"Collapse contiguous whitespace from the given text. Source code in notional/parser.py def condense_text ( text ): \"\"\"Collapse contiguous whitespace from the given text.\"\"\" if text is None : return None return re . sub ( r \"\\s+\" , \" \" , text , flags = re . MULTILINE )","title":"condense_text()"},{"location":"reference/parser/#notional.parser.elem_has_text","text":"Determine if the element has any visible text. :param elem: the element to examine :param with_children: whether to include children nodes in the search Source code in notional/parser.py def elem_has_text ( elem , with_children = True ): \"\"\"Determine if the element has any visible text. :param elem: the element to examine :param with_children: whether to include children nodes in the search \"\"\" # first, check the direct text of the element... if elem . text is not None and not elem . text . isspace (): return True # now, we need to check the tail of each child... for child in elem : if with_children and elem_has_text ( child ): return True if child . tail is None : continue if not child . tail . isspace (): return True return False","title":"elem_has_text()"},{"location":"reference/parser/#notional.parser.gather_text","text":"Return all text from the element and children. Source code in notional/parser.py def gather_text ( elem ): \"\"\"Return all text from the element and children.\"\"\" text = \"\" . join ( elem . itertext ()) return normalize_text ( text )","title":"gather_text()"},{"location":"reference/parser/#notional.parser.normalize_text","text":"Remove extra whitespace from the given text. Source code in notional/parser.py def normalize_text ( text ): \"\"\"Remove extra whitespace from the given text.\"\"\" if text is None : return None text = text . strip () return condense_text ( text )","title":"normalize_text()"},{"location":"reference/parser/#notional.parser.strip_text_block","text":"Remove leading and trailing whitespace from text in the given block. Source code in notional/parser.py def strip_text_block ( block ): \"\"\"Remove leading and trailing whitespace from text in the given block.\"\"\" if not isinstance ( block , blocks . TextBlock ): return if isinstance ( block , blocks . Code ): return block_text = block . __text__ if block_text is not None and len ( block_text ) > 0 : lstrip ( block_text [ 0 ]) rstrip ( block_text [ - 1 ])","title":"strip_text_block()"},{"location":"reference/query/","text":"Provides an interactive query builder for Notion databases. CheckboxCondition ( DataObject ) pydantic-model Represents checkbox criteria in Notion. Source code in notional/query.py class CheckboxCondition ( DataObject ): \"\"\"Represents checkbox criteria in Notion.\"\"\" equals : Optional [ bool ] = None does_not_equal : Optional [ bool ] = None CompoundFilter ( QueryFilter ) pydantic-model Represents a compound filter in Notion. Source code in notional/query.py class CompoundFilter ( QueryFilter ): \"\"\"Represents a compound filter in Notion.\"\"\" class Config : \"\"\"Pydantic configuration class to support keyword fields.\"\"\" allow_population_by_field_name = True and_ : Optional [ List [ QueryFilter ]] = Field ( None , alias = \"and\" ) or_ : Optional [ List [ QueryFilter ]] = Field ( None , alias = \"or\" ) Config Pydantic configuration class to support keyword fields. Source code in notional/query.py class Config : \"\"\"Pydantic configuration class to support keyword fields.\"\"\" allow_population_by_field_name = True CreatedTimeFilter ( TimestampFilter ) pydantic-model Represents a created_time filter in Notion. Source code in notional/query.py class CreatedTimeFilter ( TimestampFilter ): \"\"\"Represents a created_time filter in Notion.\"\"\" timestamp : TimestampKind = TimestampKind . CREATED_TIME created_time : DateCondition @classmethod def create ( cls , constraint ): \"\"\"Create a new `CreatedTimeFilter` using the given constraint.\"\"\" return CreatedTimeFilter ( created_time = constraint ) create ( constraint ) classmethod Create a new CreatedTimeFilter using the given constraint. Source code in notional/query.py @classmethod def create ( cls , constraint ): \"\"\"Create a new `CreatedTimeFilter` using the given constraint.\"\"\" return CreatedTimeFilter ( created_time = constraint ) DateCondition ( DataObject ) pydantic-model Represents date criteria in Notion. Source code in notional/query.py class DateCondition ( DataObject ): \"\"\"Represents date criteria in Notion.\"\"\" equals : Optional [ Union [ date , datetime ]] = None before : Optional [ Union [ date , datetime ]] = None after : Optional [ Union [ date , datetime ]] = None on_or_before : Optional [ Union [ date , datetime ]] = None on_or_after : Optional [ Union [ date , datetime ]] = None is_empty : Optional [ bool ] = None is_not_empty : Optional [ bool ] = None past_week : Optional [ Any ] = None past_month : Optional [ Any ] = None past_year : Optional [ Any ] = None next_week : Optional [ Any ] = None next_month : Optional [ Any ] = None next_year : Optional [ Any ] = None FilesCondition ( DataObject ) pydantic-model Represents files criteria in Notion. Source code in notional/query.py class FilesCondition ( DataObject ): \"\"\"Represents files criteria in Notion.\"\"\" is_empty : Optional [ bool ] = None is_not_empty : Optional [ bool ] = None FormulaCondition ( DataObject ) pydantic-model Represents formula criteria in Notion. Source code in notional/query.py class FormulaCondition ( DataObject ): \"\"\"Represents formula criteria in Notion.\"\"\" text : Optional [ TextCondition ] = None checkbox : Optional [ CheckboxCondition ] = None number : Optional [ NumberCondition ] = None date : Optional [ DateCondition ] = None LastEditedTimeFilter ( TimestampFilter ) pydantic-model Represents a last_edited_time filter in Notion. Source code in notional/query.py class LastEditedTimeFilter ( TimestampFilter ): \"\"\"Represents a last_edited_time filter in Notion.\"\"\" timestamp : TimestampKind = TimestampKind . LAST_EDITED_TIME last_edited_time : DateCondition @classmethod def create ( cls , constraint ): \"\"\"Create a new `LastEditedTimeFilter` using the given constraint.\"\"\" return LastEditedTimeFilter ( last_edited_time = constraint ) create ( constraint ) classmethod Create a new LastEditedTimeFilter using the given constraint. Source code in notional/query.py @classmethod def create ( cls , constraint ): \"\"\"Create a new `LastEditedTimeFilter` using the given constraint.\"\"\" return LastEditedTimeFilter ( last_edited_time = constraint ) MultiSelectCondition ( DataObject ) pydantic-model Represents a multi_select criteria in Notion. Source code in notional/query.py class MultiSelectCondition ( DataObject ): \"\"\"Represents a multi_select criteria in Notion.\"\"\" contains : Optional [ str ] = None does_not_contains : Optional [ str ] = None is_empty : Optional [ bool ] = None is_not_empty : Optional [ bool ] = None NumberCondition ( DataObject ) pydantic-model Represents number criteria in Notion. Source code in notional/query.py class NumberCondition ( DataObject ): \"\"\"Represents number criteria in Notion.\"\"\" equals : Optional [ Union [ float , int ]] = None does_not_equal : Optional [ Union [ float , int ]] = None greater_than : Optional [ Union [ float , int ]] = None less_than : Optional [ Union [ float , int ]] = None greater_than_or_equal_to : Optional [ Union [ float , int ]] = None less_than_or_equal_to : Optional [ Union [ float , int ]] = None is_empty : Optional [ bool ] = None is_not_empty : Optional [ bool ] = None PeopleCondition ( DataObject ) pydantic-model Represents people criteria in Notion. Source code in notional/query.py class PeopleCondition ( DataObject ): \"\"\"Represents people criteria in Notion.\"\"\" contains : Optional [ UUID ] = None does_not_contain : Optional [ UUID ] = None is_empty : Optional [ bool ] = None is_not_empty : Optional [ bool ] = None PropertyFilter ( QueryFilter ) pydantic-model Represents a database property filter in Notion. Source code in notional/query.py class PropertyFilter ( QueryFilter ): \"\"\"Represents a database property filter in Notion.\"\"\" property : str rich_text : Optional [ TextCondition ] = None phone_number : Optional [ TextCondition ] = None number : Optional [ NumberCondition ] = None checkbox : Optional [ CheckboxCondition ] = None select : Optional [ SelectCondition ] = None multi_select : Optional [ MultiSelectCondition ] = None date : Optional [ DateCondition ] = None people : Optional [ PeopleCondition ] = None files : Optional [ FilesCondition ] = None relation : Optional [ RelationCondition ] = None formula : Optional [ FormulaCondition ] = None PropertySort ( DataObject ) pydantic-model Represents a sort instruction in Notion. Source code in notional/query.py class PropertySort ( DataObject ): \"\"\"Represents a sort instruction in Notion.\"\"\" property : Optional [ str ] = None timestamp : Optional [ TimestampKind ] = None direction : Optional [ SortDirection ] = None Query ( DataObject ) pydantic-model Represents a query object in Notion. Source code in notional/query.py class Query ( DataObject ): \"\"\"Represents a query object in Notion.\"\"\" sorts : Optional [ List [ PropertySort ]] = None filter : Optional [ QueryFilter ] = None start_cursor : Optional [ UUID ] = None page_size : int = 100 @validator ( \"page_size\" ) def valid_page_size ( cls , value ): \"\"\"Validate that the given page size meets the Notion API requirements.\"\"\" assert value > 0 , \"size must be greater than zero\" assert value <= 100 , \"size must be less than or equal to 100\" return value valid_page_size ( value ) classmethod Validate that the given page size meets the Notion API requirements. Source code in notional/query.py @validator ( \"page_size\" ) def valid_page_size ( cls , value ): \"\"\"Validate that the given page size meets the Notion API requirements.\"\"\" assert value > 0 , \"size must be greater than zero\" assert value <= 100 , \"size must be less than or equal to 100\" return value QueryBuilder A query builder for the Notion API. :param endpoint: the session endpoint used to execute the query :param cls: an optional DataObject class for parsing results :param params: optional params that will be passed to the query Source code in notional/query.py class QueryBuilder : \"\"\"A query builder for the Notion API. :param endpoint: the session endpoint used to execute the query :param cls: an optional DataObject class for parsing results :param params: optional params that will be passed to the query \"\"\" def __init__ ( self , endpoint , cls = None , ** params ): \"\"\"Initialize a new `QueryBuilder` for the given endpoint.\"\"\" self . endpoint = endpoint self . params = params self . cls = cls self . query = Query () def filter ( self , filter = None , ** kwargs ): \"\"\"Add the given filter to the query.\"\"\" if filter is None : if \"property\" in kwargs : filter = PropertyFilter . parse_obj ( kwargs ) elif \"timestamp\" in kwargs and kwargs [ \"timestamp\" ] == \"created_time\" : filter = CreatedTimeFilter . parse_obj ( kwargs ) elif \"timestamp\" in kwargs and kwargs [ \"timestamp\" ] == \"last_edited_time\" : filter = LastEditedTimeFilter . parse_obj ( kwargs ) else : raise ValueError ( \"unrecognized filter\" ) elif not isinstance ( filter , QueryFilter ): raise ValueError ( \"filter must be of type QueryFilter\" ) # use CompoundFilter when necessary... if self . query . filter is None : self . query . filter = filter elif isinstance ( self . query . filter , CompoundFilter ): self . query . filter . and_ . append ( filter ) else : old_filter = self . query . filter self . query . filter = CompoundFilter ( and_ = [ old_filter , filter ]) return self def sort ( self , sort = None , ** kwargs ): \"\"\"Add the given sort elements to the query.\"\"\" # XXX should this support ORM properties also? # e.g. - query.sort(property=Task.Title) # but users won't always use ORM for queries... if sort is None : sort = PropertySort ( ** kwargs ) elif not isinstance ( filter , PropertySort ): raise ValueError ( \"sort must be of type PropertySort\" ) # use multiple sorts when necessary if self . query . sorts is None : self . query . sorts = [ sort ] else : self . query . sorts . append ( sort ) return self def start_at ( self , page_id ): \"\"\"Set the start cursor to a specific page ID.\"\"\" self . query . start_cursor = page_id return self def limit ( self , page_size ): \"\"\"Limit the number of results to the given page size.\"\"\" self . query . page_size = page_size return self def execute ( self ): \"\"\"Execute the current query and return an iterator for the results.\"\"\" if self . endpoint is None : raise ValueError ( \"cannot execute query; no endpoint provided\" ) log . debug ( \"executing query - %s \" , self . query ) query = self . query . to_api () if self . params : query . update ( self . params ) exec = EndpointIterator ( endpoint = self . endpoint , ** query ) return ResultSet ( exec = exec , cls = self . cls ) def first ( self ): \"\"\"Execute the current query and return the first result only.\"\"\" try : return next ( self . execute ()) except StopIteration : log . debug ( \"iterator returned empty result set\" ) return None __init__ ( self , endpoint , cls = None , ** params ) special Initialize a new QueryBuilder for the given endpoint. Source code in notional/query.py def __init__ ( self , endpoint , cls = None , ** params ): \"\"\"Initialize a new `QueryBuilder` for the given endpoint.\"\"\" self . endpoint = endpoint self . params = params self . cls = cls self . query = Query () execute ( self ) Execute the current query and return an iterator for the results. Source code in notional/query.py def execute ( self ): \"\"\"Execute the current query and return an iterator for the results.\"\"\" if self . endpoint is None : raise ValueError ( \"cannot execute query; no endpoint provided\" ) log . debug ( \"executing query - %s \" , self . query ) query = self . query . to_api () if self . params : query . update ( self . params ) exec = EndpointIterator ( endpoint = self . endpoint , ** query ) return ResultSet ( exec = exec , cls = self . cls ) filter ( self , filter = None , ** kwargs ) Add the given filter to the query. Source code in notional/query.py def filter ( self , filter = None , ** kwargs ): \"\"\"Add the given filter to the query.\"\"\" if filter is None : if \"property\" in kwargs : filter = PropertyFilter . parse_obj ( kwargs ) elif \"timestamp\" in kwargs and kwargs [ \"timestamp\" ] == \"created_time\" : filter = CreatedTimeFilter . parse_obj ( kwargs ) elif \"timestamp\" in kwargs and kwargs [ \"timestamp\" ] == \"last_edited_time\" : filter = LastEditedTimeFilter . parse_obj ( kwargs ) else : raise ValueError ( \"unrecognized filter\" ) elif not isinstance ( filter , QueryFilter ): raise ValueError ( \"filter must be of type QueryFilter\" ) # use CompoundFilter when necessary... if self . query . filter is None : self . query . filter = filter elif isinstance ( self . query . filter , CompoundFilter ): self . query . filter . and_ . append ( filter ) else : old_filter = self . query . filter self . query . filter = CompoundFilter ( and_ = [ old_filter , filter ]) return self first ( self ) Execute the current query and return the first result only. Source code in notional/query.py def first ( self ): \"\"\"Execute the current query and return the first result only.\"\"\" try : return next ( self . execute ()) except StopIteration : log . debug ( \"iterator returned empty result set\" ) return None limit ( self , page_size ) Limit the number of results to the given page size. Source code in notional/query.py def limit ( self , page_size ): \"\"\"Limit the number of results to the given page size.\"\"\" self . query . page_size = page_size return self sort ( self , sort = None , ** kwargs ) Add the given sort elements to the query. Source code in notional/query.py def sort ( self , sort = None , ** kwargs ): \"\"\"Add the given sort elements to the query.\"\"\" # XXX should this support ORM properties also? # e.g. - query.sort(property=Task.Title) # but users won't always use ORM for queries... if sort is None : sort = PropertySort ( ** kwargs ) elif not isinstance ( filter , PropertySort ): raise ValueError ( \"sort must be of type PropertySort\" ) # use multiple sorts when necessary if self . query . sorts is None : self . query . sorts = [ sort ] else : self . query . sorts . append ( sort ) return self start_at ( self , page_id ) Set the start cursor to a specific page ID. Source code in notional/query.py def start_at ( self , page_id ): \"\"\"Set the start cursor to a specific page ID.\"\"\" self . query . start_cursor = page_id return self QueryFilter ( DataObject ) pydantic-model Base class for query filters. Source code in notional/query.py class QueryFilter ( DataObject ): \"\"\"Base class for query filters.\"\"\" RelationCondition ( DataObject ) pydantic-model Represents relation criteria in Notion. Source code in notional/query.py class RelationCondition ( DataObject ): \"\"\"Represents relation criteria in Notion.\"\"\" contains : Optional [ UUID ] = None does_not_contain : Optional [ UUID ] = None is_empty : Optional [ bool ] = None is_not_empty : Optional [ bool ] = None ResultSet A result for a specific query. Source code in notional/query.py class ResultSet : \"\"\"A result for a specific query.\"\"\" def __init__ ( self , exec , cls = None ): \"\"\"Initialize a new `ResultSet`.\"\"\" self . source = exec self . cls = cls def __iter__ ( self ): \"\"\"Return an iterator for this `ResultSet`.\"\"\" return self def __next__ ( self ): \"\"\"Return the next item from this `ResultSet`.\"\"\" item = next ( self . source ) if self . cls is not None : item = self . cls . parse_obj ( item ) elif \"object\" in item : if item [ \"object\" ] == \"page\" : item = Page . parse_obj ( item ) elif item [ \"object\" ] == \"database\" : item = Database . parse_obj ( item ) elif item [ \"object\" ] == \"block\" : item = Block . parse_obj ( item ) else : item = Record . parse_obj ( item ) return item __init__ ( self , exec , cls = None ) special Initialize a new ResultSet . Source code in notional/query.py def __init__ ( self , exec , cls = None ): \"\"\"Initialize a new `ResultSet`.\"\"\" self . source = exec self . cls = cls __iter__ ( self ) special Return an iterator for this ResultSet . Source code in notional/query.py def __iter__ ( self ): \"\"\"Return an iterator for this `ResultSet`.\"\"\" return self __next__ ( self ) special Return the next item from this ResultSet . Source code in notional/query.py def __next__ ( self ): \"\"\"Return the next item from this `ResultSet`.\"\"\" item = next ( self . source ) if self . cls is not None : item = self . cls . parse_obj ( item ) elif \"object\" in item : if item [ \"object\" ] == \"page\" : item = Page . parse_obj ( item ) elif item [ \"object\" ] == \"database\" : item = Database . parse_obj ( item ) elif item [ \"object\" ] == \"block\" : item = Block . parse_obj ( item ) else : item = Record . parse_obj ( item ) return item SelectCondition ( DataObject ) pydantic-model Represents select criteria in Notion. Source code in notional/query.py class SelectCondition ( DataObject ): \"\"\"Represents select criteria in Notion.\"\"\" equals : Optional [ str ] = None does_not_equal : Optional [ str ] = None is_empty : Optional [ bool ] = None is_not_empty : Optional [ bool ] = None SortDirection ( str , Enum ) Sort direction options. Source code in notional/query.py class SortDirection ( str , Enum ): \"\"\"Sort direction options.\"\"\" ASCENDING = \"ascending\" DESCENDING = \"descending\" TextCondition ( DataObject ) pydantic-model Represents text criteria in Notion. Source code in notional/query.py class TextCondition ( DataObject ): \"\"\"Represents text criteria in Notion.\"\"\" equals : Optional [ str ] = None does_not_equal : Optional [ str ] = None contains : Optional [ str ] = None does_not_contain : Optional [ str ] = None starts_with : Optional [ str ] = None ends_with : Optional [ str ] = None is_empty : Optional [ bool ] = None is_not_empty : Optional [ bool ] = None TimestampFilter ( QueryFilter ) pydantic-model Represents a timestamp filter in Notion. Source code in notional/query.py class TimestampFilter ( QueryFilter ): \"\"\"Represents a timestamp filter in Notion.\"\"\" timestamp : TimestampKind @classmethod def create ( cls , kind , constraint ): \"\"\"Create a new `TimeStampFilter` using the given constraint.\"\"\" if kind == TimestampKind . CREATED_TIME : return CreatedTimeFilter . create ( constraint ) if kind == TimestampKind . LAST_EDITED_TIME : return LastEditedTimeFilter . create ( constraint ) raise ValueError ( \"Unsupported kind for timestamp\" ) create ( kind , constraint ) classmethod Create a new TimeStampFilter using the given constraint. Source code in notional/query.py @classmethod def create ( cls , kind , constraint ): \"\"\"Create a new `TimeStampFilter` using the given constraint.\"\"\" if kind == TimestampKind . CREATED_TIME : return CreatedTimeFilter . create ( constraint ) if kind == TimestampKind . LAST_EDITED_TIME : return LastEditedTimeFilter . create ( constraint ) raise ValueError ( \"Unsupported kind for timestamp\" ) TimestampKind ( str , Enum ) Possible timestamp types. Source code in notional/query.py class TimestampKind ( str , Enum ): \"\"\"Possible timestamp types.\"\"\" CREATED_TIME = \"created_time\" LAST_EDITED_TIME = \"last_edited_time\" get_target_id ( target ) Examine the given target and returns the appropriate ID as a string. Source code in notional/query.py def get_target_id ( target ): \"\"\"Examine the given target and returns the appropriate ID as a string.\"\"\" if isinstance ( target , str ): return target if isinstance ( target , UUID ): return target . hex if isinstance ( target , Record ): return target . id . hex if isinstance ( target , ParentRef ): return target () . hex if isclass ( target ) and issubclass ( target , ConnectedPage ): return target . _notional__database raise ValueError ( \"unsupported query target\" )","title":"Query"},{"location":"reference/query/#notional.query.CheckboxCondition","text":"Represents checkbox criteria in Notion. Source code in notional/query.py class CheckboxCondition ( DataObject ): \"\"\"Represents checkbox criteria in Notion.\"\"\" equals : Optional [ bool ] = None does_not_equal : Optional [ bool ] = None","title":"CheckboxCondition"},{"location":"reference/query/#notional.query.CompoundFilter","text":"Represents a compound filter in Notion. Source code in notional/query.py class CompoundFilter ( QueryFilter ): \"\"\"Represents a compound filter in Notion.\"\"\" class Config : \"\"\"Pydantic configuration class to support keyword fields.\"\"\" allow_population_by_field_name = True and_ : Optional [ List [ QueryFilter ]] = Field ( None , alias = \"and\" ) or_ : Optional [ List [ QueryFilter ]] = Field ( None , alias = \"or\" )","title":"CompoundFilter"},{"location":"reference/query/#notional.query.CompoundFilter.Config","text":"Pydantic configuration class to support keyword fields. Source code in notional/query.py class Config : \"\"\"Pydantic configuration class to support keyword fields.\"\"\" allow_population_by_field_name = True","title":"Config"},{"location":"reference/query/#notional.query.CreatedTimeFilter","text":"Represents a created_time filter in Notion. Source code in notional/query.py class CreatedTimeFilter ( TimestampFilter ): \"\"\"Represents a created_time filter in Notion.\"\"\" timestamp : TimestampKind = TimestampKind . CREATED_TIME created_time : DateCondition @classmethod def create ( cls , constraint ): \"\"\"Create a new `CreatedTimeFilter` using the given constraint.\"\"\" return CreatedTimeFilter ( created_time = constraint )","title":"CreatedTimeFilter"},{"location":"reference/query/#notional.query.CreatedTimeFilter.create","text":"Create a new CreatedTimeFilter using the given constraint. Source code in notional/query.py @classmethod def create ( cls , constraint ): \"\"\"Create a new `CreatedTimeFilter` using the given constraint.\"\"\" return CreatedTimeFilter ( created_time = constraint )","title":"create()"},{"location":"reference/query/#notional.query.DateCondition","text":"Represents date criteria in Notion. Source code in notional/query.py class DateCondition ( DataObject ): \"\"\"Represents date criteria in Notion.\"\"\" equals : Optional [ Union [ date , datetime ]] = None before : Optional [ Union [ date , datetime ]] = None after : Optional [ Union [ date , datetime ]] = None on_or_before : Optional [ Union [ date , datetime ]] = None on_or_after : Optional [ Union [ date , datetime ]] = None is_empty : Optional [ bool ] = None is_not_empty : Optional [ bool ] = None past_week : Optional [ Any ] = None past_month : Optional [ Any ] = None past_year : Optional [ Any ] = None next_week : Optional [ Any ] = None next_month : Optional [ Any ] = None next_year : Optional [ Any ] = None","title":"DateCondition"},{"location":"reference/query/#notional.query.FilesCondition","text":"Represents files criteria in Notion. Source code in notional/query.py class FilesCondition ( DataObject ): \"\"\"Represents files criteria in Notion.\"\"\" is_empty : Optional [ bool ] = None is_not_empty : Optional [ bool ] = None","title":"FilesCondition"},{"location":"reference/query/#notional.query.FormulaCondition","text":"Represents formula criteria in Notion. Source code in notional/query.py class FormulaCondition ( DataObject ): \"\"\"Represents formula criteria in Notion.\"\"\" text : Optional [ TextCondition ] = None checkbox : Optional [ CheckboxCondition ] = None number : Optional [ NumberCondition ] = None date : Optional [ DateCondition ] = None","title":"FormulaCondition"},{"location":"reference/query/#notional.query.LastEditedTimeFilter","text":"Represents a last_edited_time filter in Notion. Source code in notional/query.py class LastEditedTimeFilter ( TimestampFilter ): \"\"\"Represents a last_edited_time filter in Notion.\"\"\" timestamp : TimestampKind = TimestampKind . LAST_EDITED_TIME last_edited_time : DateCondition @classmethod def create ( cls , constraint ): \"\"\"Create a new `LastEditedTimeFilter` using the given constraint.\"\"\" return LastEditedTimeFilter ( last_edited_time = constraint )","title":"LastEditedTimeFilter"},{"location":"reference/query/#notional.query.LastEditedTimeFilter.create","text":"Create a new LastEditedTimeFilter using the given constraint. Source code in notional/query.py @classmethod def create ( cls , constraint ): \"\"\"Create a new `LastEditedTimeFilter` using the given constraint.\"\"\" return LastEditedTimeFilter ( last_edited_time = constraint )","title":"create()"},{"location":"reference/query/#notional.query.MultiSelectCondition","text":"Represents a multi_select criteria in Notion. Source code in notional/query.py class MultiSelectCondition ( DataObject ): \"\"\"Represents a multi_select criteria in Notion.\"\"\" contains : Optional [ str ] = None does_not_contains : Optional [ str ] = None is_empty : Optional [ bool ] = None is_not_empty : Optional [ bool ] = None","title":"MultiSelectCondition"},{"location":"reference/query/#notional.query.NumberCondition","text":"Represents number criteria in Notion. Source code in notional/query.py class NumberCondition ( DataObject ): \"\"\"Represents number criteria in Notion.\"\"\" equals : Optional [ Union [ float , int ]] = None does_not_equal : Optional [ Union [ float , int ]] = None greater_than : Optional [ Union [ float , int ]] = None less_than : Optional [ Union [ float , int ]] = None greater_than_or_equal_to : Optional [ Union [ float , int ]] = None less_than_or_equal_to : Optional [ Union [ float , int ]] = None is_empty : Optional [ bool ] = None is_not_empty : Optional [ bool ] = None","title":"NumberCondition"},{"location":"reference/query/#notional.query.PeopleCondition","text":"Represents people criteria in Notion. Source code in notional/query.py class PeopleCondition ( DataObject ): \"\"\"Represents people criteria in Notion.\"\"\" contains : Optional [ UUID ] = None does_not_contain : Optional [ UUID ] = None is_empty : Optional [ bool ] = None is_not_empty : Optional [ bool ] = None","title":"PeopleCondition"},{"location":"reference/query/#notional.query.PropertyFilter","text":"Represents a database property filter in Notion. Source code in notional/query.py class PropertyFilter ( QueryFilter ): \"\"\"Represents a database property filter in Notion.\"\"\" property : str rich_text : Optional [ TextCondition ] = None phone_number : Optional [ TextCondition ] = None number : Optional [ NumberCondition ] = None checkbox : Optional [ CheckboxCondition ] = None select : Optional [ SelectCondition ] = None multi_select : Optional [ MultiSelectCondition ] = None date : Optional [ DateCondition ] = None people : Optional [ PeopleCondition ] = None files : Optional [ FilesCondition ] = None relation : Optional [ RelationCondition ] = None formula : Optional [ FormulaCondition ] = None","title":"PropertyFilter"},{"location":"reference/query/#notional.query.PropertySort","text":"Represents a sort instruction in Notion. Source code in notional/query.py class PropertySort ( DataObject ): \"\"\"Represents a sort instruction in Notion.\"\"\" property : Optional [ str ] = None timestamp : Optional [ TimestampKind ] = None direction : Optional [ SortDirection ] = None","title":"PropertySort"},{"location":"reference/query/#notional.query.Query","text":"Represents a query object in Notion. Source code in notional/query.py class Query ( DataObject ): \"\"\"Represents a query object in Notion.\"\"\" sorts : Optional [ List [ PropertySort ]] = None filter : Optional [ QueryFilter ] = None start_cursor : Optional [ UUID ] = None page_size : int = 100 @validator ( \"page_size\" ) def valid_page_size ( cls , value ): \"\"\"Validate that the given page size meets the Notion API requirements.\"\"\" assert value > 0 , \"size must be greater than zero\" assert value <= 100 , \"size must be less than or equal to 100\" return value","title":"Query"},{"location":"reference/query/#notional.query.Query.valid_page_size","text":"Validate that the given page size meets the Notion API requirements. Source code in notional/query.py @validator ( \"page_size\" ) def valid_page_size ( cls , value ): \"\"\"Validate that the given page size meets the Notion API requirements.\"\"\" assert value > 0 , \"size must be greater than zero\" assert value <= 100 , \"size must be less than or equal to 100\" return value","title":"valid_page_size()"},{"location":"reference/query/#notional.query.QueryBuilder","text":"A query builder for the Notion API. :param endpoint: the session endpoint used to execute the query :param cls: an optional DataObject class for parsing results :param params: optional params that will be passed to the query Source code in notional/query.py class QueryBuilder : \"\"\"A query builder for the Notion API. :param endpoint: the session endpoint used to execute the query :param cls: an optional DataObject class for parsing results :param params: optional params that will be passed to the query \"\"\" def __init__ ( self , endpoint , cls = None , ** params ): \"\"\"Initialize a new `QueryBuilder` for the given endpoint.\"\"\" self . endpoint = endpoint self . params = params self . cls = cls self . query = Query () def filter ( self , filter = None , ** kwargs ): \"\"\"Add the given filter to the query.\"\"\" if filter is None : if \"property\" in kwargs : filter = PropertyFilter . parse_obj ( kwargs ) elif \"timestamp\" in kwargs and kwargs [ \"timestamp\" ] == \"created_time\" : filter = CreatedTimeFilter . parse_obj ( kwargs ) elif \"timestamp\" in kwargs and kwargs [ \"timestamp\" ] == \"last_edited_time\" : filter = LastEditedTimeFilter . parse_obj ( kwargs ) else : raise ValueError ( \"unrecognized filter\" ) elif not isinstance ( filter , QueryFilter ): raise ValueError ( \"filter must be of type QueryFilter\" ) # use CompoundFilter when necessary... if self . query . filter is None : self . query . filter = filter elif isinstance ( self . query . filter , CompoundFilter ): self . query . filter . and_ . append ( filter ) else : old_filter = self . query . filter self . query . filter = CompoundFilter ( and_ = [ old_filter , filter ]) return self def sort ( self , sort = None , ** kwargs ): \"\"\"Add the given sort elements to the query.\"\"\" # XXX should this support ORM properties also? # e.g. - query.sort(property=Task.Title) # but users won't always use ORM for queries... if sort is None : sort = PropertySort ( ** kwargs ) elif not isinstance ( filter , PropertySort ): raise ValueError ( \"sort must be of type PropertySort\" ) # use multiple sorts when necessary if self . query . sorts is None : self . query . sorts = [ sort ] else : self . query . sorts . append ( sort ) return self def start_at ( self , page_id ): \"\"\"Set the start cursor to a specific page ID.\"\"\" self . query . start_cursor = page_id return self def limit ( self , page_size ): \"\"\"Limit the number of results to the given page size.\"\"\" self . query . page_size = page_size return self def execute ( self ): \"\"\"Execute the current query and return an iterator for the results.\"\"\" if self . endpoint is None : raise ValueError ( \"cannot execute query; no endpoint provided\" ) log . debug ( \"executing query - %s \" , self . query ) query = self . query . to_api () if self . params : query . update ( self . params ) exec = EndpointIterator ( endpoint = self . endpoint , ** query ) return ResultSet ( exec = exec , cls = self . cls ) def first ( self ): \"\"\"Execute the current query and return the first result only.\"\"\" try : return next ( self . execute ()) except StopIteration : log . debug ( \"iterator returned empty result set\" ) return None","title":"QueryBuilder"},{"location":"reference/query/#notional.query.QueryBuilder.__init__","text":"Initialize a new QueryBuilder for the given endpoint. Source code in notional/query.py def __init__ ( self , endpoint , cls = None , ** params ): \"\"\"Initialize a new `QueryBuilder` for the given endpoint.\"\"\" self . endpoint = endpoint self . params = params self . cls = cls self . query = Query ()","title":"__init__()"},{"location":"reference/query/#notional.query.QueryBuilder.execute","text":"Execute the current query and return an iterator for the results. Source code in notional/query.py def execute ( self ): \"\"\"Execute the current query and return an iterator for the results.\"\"\" if self . endpoint is None : raise ValueError ( \"cannot execute query; no endpoint provided\" ) log . debug ( \"executing query - %s \" , self . query ) query = self . query . to_api () if self . params : query . update ( self . params ) exec = EndpointIterator ( endpoint = self . endpoint , ** query ) return ResultSet ( exec = exec , cls = self . cls )","title":"execute()"},{"location":"reference/query/#notional.query.QueryBuilder.filter","text":"Add the given filter to the query. Source code in notional/query.py def filter ( self , filter = None , ** kwargs ): \"\"\"Add the given filter to the query.\"\"\" if filter is None : if \"property\" in kwargs : filter = PropertyFilter . parse_obj ( kwargs ) elif \"timestamp\" in kwargs and kwargs [ \"timestamp\" ] == \"created_time\" : filter = CreatedTimeFilter . parse_obj ( kwargs ) elif \"timestamp\" in kwargs and kwargs [ \"timestamp\" ] == \"last_edited_time\" : filter = LastEditedTimeFilter . parse_obj ( kwargs ) else : raise ValueError ( \"unrecognized filter\" ) elif not isinstance ( filter , QueryFilter ): raise ValueError ( \"filter must be of type QueryFilter\" ) # use CompoundFilter when necessary... if self . query . filter is None : self . query . filter = filter elif isinstance ( self . query . filter , CompoundFilter ): self . query . filter . and_ . append ( filter ) else : old_filter = self . query . filter self . query . filter = CompoundFilter ( and_ = [ old_filter , filter ]) return self","title":"filter()"},{"location":"reference/query/#notional.query.QueryBuilder.first","text":"Execute the current query and return the first result only. Source code in notional/query.py def first ( self ): \"\"\"Execute the current query and return the first result only.\"\"\" try : return next ( self . execute ()) except StopIteration : log . debug ( \"iterator returned empty result set\" ) return None","title":"first()"},{"location":"reference/query/#notional.query.QueryBuilder.limit","text":"Limit the number of results to the given page size. Source code in notional/query.py def limit ( self , page_size ): \"\"\"Limit the number of results to the given page size.\"\"\" self . query . page_size = page_size return self","title":"limit()"},{"location":"reference/query/#notional.query.QueryBuilder.sort","text":"Add the given sort elements to the query. Source code in notional/query.py def sort ( self , sort = None , ** kwargs ): \"\"\"Add the given sort elements to the query.\"\"\" # XXX should this support ORM properties also? # e.g. - query.sort(property=Task.Title) # but users won't always use ORM for queries... if sort is None : sort = PropertySort ( ** kwargs ) elif not isinstance ( filter , PropertySort ): raise ValueError ( \"sort must be of type PropertySort\" ) # use multiple sorts when necessary if self . query . sorts is None : self . query . sorts = [ sort ] else : self . query . sorts . append ( sort ) return self","title":"sort()"},{"location":"reference/query/#notional.query.QueryBuilder.start_at","text":"Set the start cursor to a specific page ID. Source code in notional/query.py def start_at ( self , page_id ): \"\"\"Set the start cursor to a specific page ID.\"\"\" self . query . start_cursor = page_id return self","title":"start_at()"},{"location":"reference/query/#notional.query.QueryFilter","text":"Base class for query filters. Source code in notional/query.py class QueryFilter ( DataObject ): \"\"\"Base class for query filters.\"\"\"","title":"QueryFilter"},{"location":"reference/query/#notional.query.RelationCondition","text":"Represents relation criteria in Notion. Source code in notional/query.py class RelationCondition ( DataObject ): \"\"\"Represents relation criteria in Notion.\"\"\" contains : Optional [ UUID ] = None does_not_contain : Optional [ UUID ] = None is_empty : Optional [ bool ] = None is_not_empty : Optional [ bool ] = None","title":"RelationCondition"},{"location":"reference/query/#notional.query.ResultSet","text":"A result for a specific query. Source code in notional/query.py class ResultSet : \"\"\"A result for a specific query.\"\"\" def __init__ ( self , exec , cls = None ): \"\"\"Initialize a new `ResultSet`.\"\"\" self . source = exec self . cls = cls def __iter__ ( self ): \"\"\"Return an iterator for this `ResultSet`.\"\"\" return self def __next__ ( self ): \"\"\"Return the next item from this `ResultSet`.\"\"\" item = next ( self . source ) if self . cls is not None : item = self . cls . parse_obj ( item ) elif \"object\" in item : if item [ \"object\" ] == \"page\" : item = Page . parse_obj ( item ) elif item [ \"object\" ] == \"database\" : item = Database . parse_obj ( item ) elif item [ \"object\" ] == \"block\" : item = Block . parse_obj ( item ) else : item = Record . parse_obj ( item ) return item","title":"ResultSet"},{"location":"reference/query/#notional.query.ResultSet.__init__","text":"Initialize a new ResultSet . Source code in notional/query.py def __init__ ( self , exec , cls = None ): \"\"\"Initialize a new `ResultSet`.\"\"\" self . source = exec self . cls = cls","title":"__init__()"},{"location":"reference/query/#notional.query.ResultSet.__iter__","text":"Return an iterator for this ResultSet . Source code in notional/query.py def __iter__ ( self ): \"\"\"Return an iterator for this `ResultSet`.\"\"\" return self","title":"__iter__()"},{"location":"reference/query/#notional.query.ResultSet.__next__","text":"Return the next item from this ResultSet . Source code in notional/query.py def __next__ ( self ): \"\"\"Return the next item from this `ResultSet`.\"\"\" item = next ( self . source ) if self . cls is not None : item = self . cls . parse_obj ( item ) elif \"object\" in item : if item [ \"object\" ] == \"page\" : item = Page . parse_obj ( item ) elif item [ \"object\" ] == \"database\" : item = Database . parse_obj ( item ) elif item [ \"object\" ] == \"block\" : item = Block . parse_obj ( item ) else : item = Record . parse_obj ( item ) return item","title":"__next__()"},{"location":"reference/query/#notional.query.SelectCondition","text":"Represents select criteria in Notion. Source code in notional/query.py class SelectCondition ( DataObject ): \"\"\"Represents select criteria in Notion.\"\"\" equals : Optional [ str ] = None does_not_equal : Optional [ str ] = None is_empty : Optional [ bool ] = None is_not_empty : Optional [ bool ] = None","title":"SelectCondition"},{"location":"reference/query/#notional.query.SortDirection","text":"Sort direction options. Source code in notional/query.py class SortDirection ( str , Enum ): \"\"\"Sort direction options.\"\"\" ASCENDING = \"ascending\" DESCENDING = \"descending\"","title":"SortDirection"},{"location":"reference/query/#notional.query.TextCondition","text":"Represents text criteria in Notion. Source code in notional/query.py class TextCondition ( DataObject ): \"\"\"Represents text criteria in Notion.\"\"\" equals : Optional [ str ] = None does_not_equal : Optional [ str ] = None contains : Optional [ str ] = None does_not_contain : Optional [ str ] = None starts_with : Optional [ str ] = None ends_with : Optional [ str ] = None is_empty : Optional [ bool ] = None is_not_empty : Optional [ bool ] = None","title":"TextCondition"},{"location":"reference/query/#notional.query.TimestampFilter","text":"Represents a timestamp filter in Notion. Source code in notional/query.py class TimestampFilter ( QueryFilter ): \"\"\"Represents a timestamp filter in Notion.\"\"\" timestamp : TimestampKind @classmethod def create ( cls , kind , constraint ): \"\"\"Create a new `TimeStampFilter` using the given constraint.\"\"\" if kind == TimestampKind . CREATED_TIME : return CreatedTimeFilter . create ( constraint ) if kind == TimestampKind . LAST_EDITED_TIME : return LastEditedTimeFilter . create ( constraint ) raise ValueError ( \"Unsupported kind for timestamp\" )","title":"TimestampFilter"},{"location":"reference/query/#notional.query.TimestampFilter.create","text":"Create a new TimeStampFilter using the given constraint. Source code in notional/query.py @classmethod def create ( cls , kind , constraint ): \"\"\"Create a new `TimeStampFilter` using the given constraint.\"\"\" if kind == TimestampKind . CREATED_TIME : return CreatedTimeFilter . create ( constraint ) if kind == TimestampKind . LAST_EDITED_TIME : return LastEditedTimeFilter . create ( constraint ) raise ValueError ( \"Unsupported kind for timestamp\" )","title":"create()"},{"location":"reference/query/#notional.query.TimestampKind","text":"Possible timestamp types. Source code in notional/query.py class TimestampKind ( str , Enum ): \"\"\"Possible timestamp types.\"\"\" CREATED_TIME = \"created_time\" LAST_EDITED_TIME = \"last_edited_time\"","title":"TimestampKind"},{"location":"reference/query/#notional.query.get_target_id","text":"Examine the given target and returns the appropriate ID as a string. Source code in notional/query.py def get_target_id ( target ): \"\"\"Examine the given target and returns the appropriate ID as a string.\"\"\" if isinstance ( target , str ): return target if isinstance ( target , UUID ): return target . hex if isinstance ( target , Record ): return target . id . hex if isinstance ( target , ParentRef ): return target () . hex if isclass ( target ) and issubclass ( target , ConnectedPage ): return target . _notional__database raise ValueError ( \"unsupported query target\" )","title":"get_target_id()"},{"location":"reference/records/","text":"Wrapper for Notion API data types. These objects provide both access to the primitive data structure returned by the API as well as higher-level access methods. In general, attributes in lower case represent the primitive data structure, where capitalized attributes provide higher-level access. BlockRef ( ParentRef ) pydantic-model Reference a block. Source code in notional/records.py class BlockRef ( ParentRef , type = \"block_id\" ): \"\"\"Reference a block.\"\"\" block_id : UUID Database ( Record ) pydantic-model A database record type. Source code in notional/records.py class Database ( Record , object = \"database\" ): \"\"\"A database record type.\"\"\" title : List [ RichTextObject ] = None url : str = None parent : ParentRef = None icon : Optional [ Union [ FileObject , EmojiObject ]] = None cover : Optional [ FileObject ] = None properties : Dict [ str , PropertyObject ] = {} @property def Title ( self ): \"\"\"Return the title of this database as plain text.\"\"\" if self . title is None or len ( self . title ) == 0 : return None return plain_text ( * self . title ) Title property readonly Return the title of this database as plain text. DatabaseRef ( ParentRef ) pydantic-model Reference a database. Source code in notional/records.py class DatabaseRef ( ParentRef , type = \"database_id\" ): \"\"\"Reference a database.\"\"\" database_id : UUID Page ( Record ) pydantic-model A standard Notion page object. Source code in notional/records.py class Page ( Record , object = \"page\" ): \"\"\"A standard Notion page object.\"\"\" url : str = None parent : ParentRef = None icon : Optional [ Union [ FileObject , EmojiObject ]] = None cover : Optional [ FileObject ] = None properties : Dict [ str , PropertyValue ] = {} def __getitem__ ( self , name ): \"\"\"Indexer for the given property name. :param name: the name of the property to get from the internal properties \"\"\" log . debug ( \"get property :: { %s } [ %s ]\" , self . id , name ) if self . properties is None : raise AttributeError ( \"No properties in Page\" ) prop = self . properties . get ( name ) if prop is None : raise AttributeError ( f \"No such property: { name } \" ) return prop def __setitem__ ( self , name , value ): \"\"\"Set the object data for the given property. If `value` is `None`, the property data will be deleted from the page. This does not affect the schema of the page, only the contents of the property. :param name: the name of the property to set in the internal properties :param prop: the PropertyValue for the named property :param value: the new value for the given property \"\"\" log . debug ( \"set property :: { %s } [ %s ] => %s \" , self . id , name , value ) if value is None : self . properties . pop ( name , None ) elif not isinstance ( value , PropertyValue ): raise ValueError ( f \"Unable to set { name } :: unsupported value type\" ) else : self . properties [ name ] = value @property def Title ( self ): \"\"\"Return the title of this page as a string. The title of a page is stored in its properties. This method will examine the page properties, looking for the appropriate `title` entry and return as a string. \"\"\" if self . properties is None or len ( self . properties ) == 0 : return None for prop in self . properties . values (): if prop . id == \"title\" : return prop . Value or None return None Title property readonly Return the title of this page as a string. The title of a page is stored in its properties. This method will examine the page properties, looking for the appropriate title entry and return as a string. __getitem__ ( self , name ) special Indexer for the given property name. :param name: the name of the property to get from the internal properties Source code in notional/records.py def __getitem__ ( self , name ): \"\"\"Indexer for the given property name. :param name: the name of the property to get from the internal properties \"\"\" log . debug ( \"get property :: { %s } [ %s ]\" , self . id , name ) if self . properties is None : raise AttributeError ( \"No properties in Page\" ) prop = self . properties . get ( name ) if prop is None : raise AttributeError ( f \"No such property: { name } \" ) return prop __setitem__ ( self , name , value ) special Set the object data for the given property. If value is None , the property data will be deleted from the page. This does not affect the schema of the page, only the contents of the property. :param name: the name of the property to set in the internal properties :param prop: the PropertyValue for the named property :param value: the new value for the given property Source code in notional/records.py def __setitem__ ( self , name , value ): \"\"\"Set the object data for the given property. If `value` is `None`, the property data will be deleted from the page. This does not affect the schema of the page, only the contents of the property. :param name: the name of the property to set in the internal properties :param prop: the PropertyValue for the named property :param value: the new value for the given property \"\"\" log . debug ( \"set property :: { %s } [ %s ] => %s \" , self . id , name , value ) if value is None : self . properties . pop ( name , None ) elif not isinstance ( value , PropertyValue ): raise ValueError ( f \"Unable to set { name } :: unsupported value type\" ) else : self . properties [ name ] = value PageRef ( ParentRef ) pydantic-model Reference a page. Source code in notional/records.py class PageRef ( ParentRef , type = \"page_id\" ): \"\"\"Reference a page.\"\"\" page_id : UUID ParentRef ( TypedObject ) pydantic-model Reference another block. Source code in notional/records.py class ParentRef ( TypedObject ): \"\"\"Reference another block.\"\"\" # XXX Notion does not handle parent references consistently in the API... # in some cases, the `type` is accepted and in others it is not. eventually # these should all by TypedObject's with the appropriate fields @classmethod def __compose__ ( cls , record ): \"\"\"Return the correct parent ID based on the object type.\"\"\" if isinstance ( record , ParentRef ): return record if isinstance ( record , Page ): return PageRef ( page_id = record . id ) if isinstance ( record , Database ): return DatabaseRef ( database_id = record . id ) raise ValueError ( \"Unrecognized 'parent' attribute\" ) __compose__ ( record ) classmethod special Return the correct parent ID based on the object type. Source code in notional/records.py @classmethod def __compose__ ( cls , record ): \"\"\"Return the correct parent ID based on the object type.\"\"\" if isinstance ( record , ParentRef ): return record if isinstance ( record , Page ): return PageRef ( page_id = record . id ) if isinstance ( record , Database ): return DatabaseRef ( database_id = record . id ) raise ValueError ( \"Unrecognized 'parent' attribute\" ) Record ( NamedObject ) pydantic-model The base type for Notion API records. Source code in notional/records.py class Record ( NamedObject ): \"\"\"The base type for Notion API records.\"\"\" id : UUID = None created_time : datetime = None last_edited_time : datetime = None has_children : bool = False archived : bool = False WorkspaceParent ( ParentRef ) pydantic-model Reference the workspace. Source code in notional/records.py class WorkspaceParent ( ParentRef , type = \"workspace\" ): \"\"\"Reference the workspace.\"\"\" workspace : bool = True","title":"Records"},{"location":"reference/records/#notional.records.BlockRef","text":"Reference a block. Source code in notional/records.py class BlockRef ( ParentRef , type = \"block_id\" ): \"\"\"Reference a block.\"\"\" block_id : UUID","title":"BlockRef"},{"location":"reference/records/#notional.records.Database","text":"A database record type. Source code in notional/records.py class Database ( Record , object = \"database\" ): \"\"\"A database record type.\"\"\" title : List [ RichTextObject ] = None url : str = None parent : ParentRef = None icon : Optional [ Union [ FileObject , EmojiObject ]] = None cover : Optional [ FileObject ] = None properties : Dict [ str , PropertyObject ] = {} @property def Title ( self ): \"\"\"Return the title of this database as plain text.\"\"\" if self . title is None or len ( self . title ) == 0 : return None return plain_text ( * self . title )","title":"Database"},{"location":"reference/records/#notional.records.Database.Title","text":"Return the title of this database as plain text.","title":"Title"},{"location":"reference/records/#notional.records.DatabaseRef","text":"Reference a database. Source code in notional/records.py class DatabaseRef ( ParentRef , type = \"database_id\" ): \"\"\"Reference a database.\"\"\" database_id : UUID","title":"DatabaseRef"},{"location":"reference/records/#notional.records.Page","text":"A standard Notion page object. Source code in notional/records.py class Page ( Record , object = \"page\" ): \"\"\"A standard Notion page object.\"\"\" url : str = None parent : ParentRef = None icon : Optional [ Union [ FileObject , EmojiObject ]] = None cover : Optional [ FileObject ] = None properties : Dict [ str , PropertyValue ] = {} def __getitem__ ( self , name ): \"\"\"Indexer for the given property name. :param name: the name of the property to get from the internal properties \"\"\" log . debug ( \"get property :: { %s } [ %s ]\" , self . id , name ) if self . properties is None : raise AttributeError ( \"No properties in Page\" ) prop = self . properties . get ( name ) if prop is None : raise AttributeError ( f \"No such property: { name } \" ) return prop def __setitem__ ( self , name , value ): \"\"\"Set the object data for the given property. If `value` is `None`, the property data will be deleted from the page. This does not affect the schema of the page, only the contents of the property. :param name: the name of the property to set in the internal properties :param prop: the PropertyValue for the named property :param value: the new value for the given property \"\"\" log . debug ( \"set property :: { %s } [ %s ] => %s \" , self . id , name , value ) if value is None : self . properties . pop ( name , None ) elif not isinstance ( value , PropertyValue ): raise ValueError ( f \"Unable to set { name } :: unsupported value type\" ) else : self . properties [ name ] = value @property def Title ( self ): \"\"\"Return the title of this page as a string. The title of a page is stored in its properties. This method will examine the page properties, looking for the appropriate `title` entry and return as a string. \"\"\" if self . properties is None or len ( self . properties ) == 0 : return None for prop in self . properties . values (): if prop . id == \"title\" : return prop . Value or None return None","title":"Page"},{"location":"reference/records/#notional.records.Page.Title","text":"Return the title of this page as a string. The title of a page is stored in its properties. This method will examine the page properties, looking for the appropriate title entry and return as a string.","title":"Title"},{"location":"reference/records/#notional.records.Page.__getitem__","text":"Indexer for the given property name. :param name: the name of the property to get from the internal properties Source code in notional/records.py def __getitem__ ( self , name ): \"\"\"Indexer for the given property name. :param name: the name of the property to get from the internal properties \"\"\" log . debug ( \"get property :: { %s } [ %s ]\" , self . id , name ) if self . properties is None : raise AttributeError ( \"No properties in Page\" ) prop = self . properties . get ( name ) if prop is None : raise AttributeError ( f \"No such property: { name } \" ) return prop","title":"__getitem__()"},{"location":"reference/records/#notional.records.Page.__setitem__","text":"Set the object data for the given property. If value is None , the property data will be deleted from the page. This does not affect the schema of the page, only the contents of the property. :param name: the name of the property to set in the internal properties :param prop: the PropertyValue for the named property :param value: the new value for the given property Source code in notional/records.py def __setitem__ ( self , name , value ): \"\"\"Set the object data for the given property. If `value` is `None`, the property data will be deleted from the page. This does not affect the schema of the page, only the contents of the property. :param name: the name of the property to set in the internal properties :param prop: the PropertyValue for the named property :param value: the new value for the given property \"\"\" log . debug ( \"set property :: { %s } [ %s ] => %s \" , self . id , name , value ) if value is None : self . properties . pop ( name , None ) elif not isinstance ( value , PropertyValue ): raise ValueError ( f \"Unable to set { name } :: unsupported value type\" ) else : self . properties [ name ] = value","title":"__setitem__()"},{"location":"reference/records/#notional.records.PageRef","text":"Reference a page. Source code in notional/records.py class PageRef ( ParentRef , type = \"page_id\" ): \"\"\"Reference a page.\"\"\" page_id : UUID","title":"PageRef"},{"location":"reference/records/#notional.records.ParentRef","text":"Reference another block. Source code in notional/records.py class ParentRef ( TypedObject ): \"\"\"Reference another block.\"\"\" # XXX Notion does not handle parent references consistently in the API... # in some cases, the `type` is accepted and in others it is not. eventually # these should all by TypedObject's with the appropriate fields @classmethod def __compose__ ( cls , record ): \"\"\"Return the correct parent ID based on the object type.\"\"\" if isinstance ( record , ParentRef ): return record if isinstance ( record , Page ): return PageRef ( page_id = record . id ) if isinstance ( record , Database ): return DatabaseRef ( database_id = record . id ) raise ValueError ( \"Unrecognized 'parent' attribute\" )","title":"ParentRef"},{"location":"reference/records/#notional.records.ParentRef.__compose__","text":"Return the correct parent ID based on the object type. Source code in notional/records.py @classmethod def __compose__ ( cls , record ): \"\"\"Return the correct parent ID based on the object type.\"\"\" if isinstance ( record , ParentRef ): return record if isinstance ( record , Page ): return PageRef ( page_id = record . id ) if isinstance ( record , Database ): return DatabaseRef ( database_id = record . id ) raise ValueError ( \"Unrecognized 'parent' attribute\" )","title":"__compose__()"},{"location":"reference/records/#notional.records.Record","text":"The base type for Notion API records. Source code in notional/records.py class Record ( NamedObject ): \"\"\"The base type for Notion API records.\"\"\" id : UUID = None created_time : datetime = None last_edited_time : datetime = None has_children : bool = False archived : bool = False","title":"Record"},{"location":"reference/records/#notional.records.WorkspaceParent","text":"Reference the workspace. Source code in notional/records.py class WorkspaceParent ( ParentRef , type = \"workspace\" ): \"\"\"Reference the workspace.\"\"\" workspace : bool = True","title":"WorkspaceParent"},{"location":"reference/schema/","text":"Objects representing a database schema. Checkbox ( PropertyObject ) pydantic-model Defines the checkbox configuration for a database property. Source code in notional/schema.py class Checkbox ( PropertyObject , type = \"checkbox\" ): \"\"\"Defines the checkbox configuration for a database property.\"\"\" checkbox : Any = {} CreatedBy ( PropertyObject ) pydantic-model Defines the created-by configuration for a database property. Source code in notional/schema.py class CreatedBy ( PropertyObject , type = \"created_by\" ): \"\"\"Defines the created-by configuration for a database property.\"\"\" created_by : Any = {} CreatedTime ( PropertyObject ) pydantic-model Defines the created-time configuration for a database property. Source code in notional/schema.py class CreatedTime ( PropertyObject , type = \"created_time\" ): \"\"\"Defines the created-time configuration for a database property.\"\"\" created_time : Any = {} Date ( PropertyObject ) pydantic-model Defines the date configuration for a database property. Source code in notional/schema.py class Date ( PropertyObject , type = \"date\" ): \"\"\"Defines the date configuration for a database property.\"\"\" date : Any = {} Email ( PropertyObject ) pydantic-model Defines the email configuration for a database property. Source code in notional/schema.py class Email ( PropertyObject , type = \"email\" ): \"\"\"Defines the email configuration for a database property.\"\"\" email : Any = {} Files ( PropertyObject ) pydantic-model Defines the files configuration for a database property. Source code in notional/schema.py class Files ( PropertyObject , type = \"files\" ): \"\"\"Defines the files configuration for a database property.\"\"\" files : Any = {} Formula ( PropertyObject ) pydantic-model Defines the formula configuration for a database property. Source code in notional/schema.py class Formula ( PropertyObject , type = \"formula\" ): \"\"\"Defines the formula configuration for a database property.\"\"\" class _NestedData ( NestedObject ): expression : str = None formula : _NestedData = _NestedData () Function ( str , Enum ) Standard aggregation functions. Source code in notional/schema.py class Function ( str , Enum ): \"\"\"Standard aggregation functions.\"\"\" COUNT_ALL = \"count_all\" COUNT_VALUES = \"count_values\" COUNT_UNIQUE_VALUES = \"count_unique_values\" COUNT_EMPTY = \"count_empty\" COUNT_NOT_EMPTY = \"count_not_empty\" PERCENT_EMPTY = \"percent_empty\" PERCENT_NOT_EMPTY = \"percent_not_empty\" AVERAGE = \"average\" MIN = \"min\" MAX = \"max\" MEDIAN = \"median\" RANGE = \"range\" SUM = \"sum\" EARLIEST_DATE = \"earliest_date\" LATEST_DATE = \"latest_date\" SHOW_ORIGINAL = \"show_original\" LastEditedBy ( PropertyObject ) pydantic-model Defines the last-edited-by configuration for a database property. Source code in notional/schema.py class LastEditedBy ( PropertyObject , type = \"last_edited_by\" ): \"\"\"Defines the last-edited-by configuration for a database property.\"\"\" last_edited_by : Any = {} LastEditedTime ( PropertyObject ) pydantic-model Defines the last-edited-time configuration for a database property. Source code in notional/schema.py class LastEditedTime ( PropertyObject , type = \"last_edited_time\" ): \"\"\"Defines the last-edited-time configuration for a database property.\"\"\" last_edited_time : Any = {} MultiSelect ( PropertyObject ) pydantic-model Defines the multi-select configuration for a database property. Source code in notional/schema.py class MultiSelect ( PropertyObject , type = \"multi_select\" ): \"\"\"Defines the multi-select configuration for a database property.\"\"\" class _NestedData ( NestedObject ): options : List [ SelectOption ] = [] multi_select : _NestedData = _NestedData () Number ( PropertyObject ) pydantic-model Defines the number configuration for a database property. Source code in notional/schema.py class Number ( PropertyObject , type = \"number\" ): \"\"\"Defines the number configuration for a database property.\"\"\" class _NestedData ( NestedObject ): format : NumberFormat = NumberFormat . NUMBER number : _NestedData = _NestedData () @classmethod def __compose__ ( cls , format ): \"\"\"Create a `Number` object with the expected format.\"\"\" return cls ( number = cls . _NestedData ( format = format )) __compose__ ( format ) classmethod special Create a Number object with the expected format. Source code in notional/schema.py @classmethod def __compose__ ( cls , format ): \"\"\"Create a `Number` object with the expected format.\"\"\" return cls ( number = cls . _NestedData ( format = format )) NumberFormat ( str , Enum ) Available number formats in Notion. Source code in notional/schema.py class NumberFormat ( str , Enum ): \"\"\"Available number formats in Notion.\"\"\" NUMBER = \"number\" NUMBER_WITH_COMMAS = \"number_with_commas\" PERCENT = \"percent\" DOLLAR = \"dollar\" CANADIAN_DOLLAR = \"canadian_dollar\" EURO = \"euro\" POUND = \"pound\" YEN = \"yen\" RUBLE = \"ruble\" RUPEE = \"rupee\" WON = \"won\" YUAN = \"yuan\" REAL = \"real\" LIRA = \"lira\" RUPIAH = \"rupiah\" FRANC = \"franc\" HONG_KONG_DOLLAR = \"hong_kong_dollar\" NEW_ZEALAND_DOLLAR = \"new_zealand_dollar\" KRONA = \"krona\" NORWEGIAN_KRONE = \"norwegian_krone\" MEXICAN_PESO = \"mexican_peso\" RAND = \"rand\" NEW_TAIWAN_DOLLAR = \"new_taiwan_dollar\" DANISH_KRONE = \"danish_krone\" ZLOTY = \"zloty\" BAHT = \"baht\" FORINT = \"forint\" KORUNA = \"koruna\" SHEKEL = \"shekel\" CHILEAN_PESO = \"chilean_peso\" PHILIPPINE_PESO = \"philippine_peso\" DIRHAM = \"dirham\" COLOMBIAN_PESO = \"colombian_peso\" RIYAL = \"riyal\" RINGGIT = \"ringgit\" LEU = \"leu\" People ( PropertyObject ) pydantic-model Defines the people configuration for a database property. Source code in notional/schema.py class People ( PropertyObject , type = \"people\" ): \"\"\"Defines the people configuration for a database property.\"\"\" people : Any = {} PhoneNumber ( PropertyObject ) pydantic-model Defines the phone number configuration for a database property. Source code in notional/schema.py class PhoneNumber ( PropertyObject , type = \"phone_number\" ): \"\"\"Defines the phone number configuration for a database property.\"\"\" phone_number : Any = {} PropertyObject ( TypedObject ) pydantic-model Base class for Notion property objects. Source code in notional/schema.py class PropertyObject ( TypedObject ): \"\"\"Base class for Notion property objects.\"\"\" id : Optional [ str ] = None name : Optional [ str ] = None Relation ( PropertyObject ) pydantic-model Defines the relation configuration for a database property. Source code in notional/schema.py class Relation ( PropertyObject , type = \"relation\" ): \"\"\"Defines the relation configuration for a database property.\"\"\" class _NestedData ( NestedObject ): database_id : UUID = None relation : _NestedData = _NestedData () @classmethod def __compose__ ( cls , database_id ): \"\"\"Create a `Relation` property using the target database ID.\"\"\" return cls ( relation = cls . _NestedData ( database_id = database_id )) __compose__ ( database_id ) classmethod special Create a Relation property using the target database ID. Source code in notional/schema.py @classmethod def __compose__ ( cls , database_id ): \"\"\"Create a `Relation` property using the target database ID.\"\"\" return cls ( relation = cls . _NestedData ( database_id = database_id )) RichText ( PropertyObject ) pydantic-model Defines the rich text configuration for a database property. Source code in notional/schema.py class RichText ( PropertyObject , type = \"rich_text\" ): \"\"\"Defines the rich text configuration for a database property.\"\"\" rich_text : Any = {} Rollup ( PropertyObject ) pydantic-model Defines the rollup configuration for a database property. Source code in notional/schema.py class Rollup ( PropertyObject , type = \"rollup\" ): \"\"\"Defines the rollup configuration for a database property.\"\"\" class _NestedData ( NestedObject ): function : Function = Function . COUNT_ALL relation_property_name : Optional [ str ] = None relation_property_id : Optional [ str ] = None rollup_property_name : Optional [ str ] = None rollup_property_id : Optional [ str ] = None rollup : _NestedData = _NestedData () Select ( PropertyObject ) pydantic-model Defines the select configuration for a database property. Source code in notional/schema.py class Select ( PropertyObject , type = \"select\" ): \"\"\"Defines the select configuration for a database property.\"\"\" class _NestedData ( NestedObject ): options : List [ SelectOption ] = [] select : _NestedData = _NestedData () @classmethod def __compose__ ( cls , options ): \"\"\"Create a `Select` object from the list of `SelectOption`'s.\"\"\" return cls ( select = cls . _NestedData ( options = options )) __compose__ ( options ) classmethod special Create a Select object from the list of SelectOption 's. Source code in notional/schema.py @classmethod def __compose__ ( cls , options ): \"\"\"Create a `Select` object from the list of `SelectOption`'s.\"\"\" return cls ( select = cls . _NestedData ( options = options )) SelectOption ( DataObject ) pydantic-model Options for select & multi-select objects. Source code in notional/schema.py class SelectOption ( DataObject ): \"\"\"Options for select & multi-select objects.\"\"\" name : str id : str = None color : str = Color . DEFAULT @classmethod def __compose__ ( cls , name , color = Color . DEFAULT ): \"\"\"Create a `SelectOption` object from the given name and color.\"\"\" return cls ( name = name , color = color ) __compose__ ( name , color =< Color . DEFAULT : 'default' > ) classmethod special Create a SelectOption object from the given name and color. Source code in notional/schema.py @classmethod def __compose__ ( cls , name , color = Color . DEFAULT ): \"\"\"Create a `SelectOption` object from the given name and color.\"\"\" return cls ( name = name , color = color ) Title ( PropertyObject ) pydantic-model Defines the title configuration for a database property. Source code in notional/schema.py class Title ( PropertyObject , type = \"title\" ): \"\"\"Defines the title configuration for a database property.\"\"\" title : Any = {} URL ( PropertyObject ) pydantic-model Defines the URL configuration for a database property. Source code in notional/schema.py class URL ( PropertyObject , type = \"url\" ): \"\"\"Defines the URL configuration for a database property.\"\"\" url : Any = {}","title":"Schema"},{"location":"reference/schema/#notional.schema.Checkbox","text":"Defines the checkbox configuration for a database property. Source code in notional/schema.py class Checkbox ( PropertyObject , type = \"checkbox\" ): \"\"\"Defines the checkbox configuration for a database property.\"\"\" checkbox : Any = {}","title":"Checkbox"},{"location":"reference/schema/#notional.schema.CreatedBy","text":"Defines the created-by configuration for a database property. Source code in notional/schema.py class CreatedBy ( PropertyObject , type = \"created_by\" ): \"\"\"Defines the created-by configuration for a database property.\"\"\" created_by : Any = {}","title":"CreatedBy"},{"location":"reference/schema/#notional.schema.CreatedTime","text":"Defines the created-time configuration for a database property. Source code in notional/schema.py class CreatedTime ( PropertyObject , type = \"created_time\" ): \"\"\"Defines the created-time configuration for a database property.\"\"\" created_time : Any = {}","title":"CreatedTime"},{"location":"reference/schema/#notional.schema.Date","text":"Defines the date configuration for a database property. Source code in notional/schema.py class Date ( PropertyObject , type = \"date\" ): \"\"\"Defines the date configuration for a database property.\"\"\" date : Any = {}","title":"Date"},{"location":"reference/schema/#notional.schema.Email","text":"Defines the email configuration for a database property. Source code in notional/schema.py class Email ( PropertyObject , type = \"email\" ): \"\"\"Defines the email configuration for a database property.\"\"\" email : Any = {}","title":"Email"},{"location":"reference/schema/#notional.schema.Files","text":"Defines the files configuration for a database property. Source code in notional/schema.py class Files ( PropertyObject , type = \"files\" ): \"\"\"Defines the files configuration for a database property.\"\"\" files : Any = {}","title":"Files"},{"location":"reference/schema/#notional.schema.Formula","text":"Defines the formula configuration for a database property. Source code in notional/schema.py class Formula ( PropertyObject , type = \"formula\" ): \"\"\"Defines the formula configuration for a database property.\"\"\" class _NestedData ( NestedObject ): expression : str = None formula : _NestedData = _NestedData ()","title":"Formula"},{"location":"reference/schema/#notional.schema.Function","text":"Standard aggregation functions. Source code in notional/schema.py class Function ( str , Enum ): \"\"\"Standard aggregation functions.\"\"\" COUNT_ALL = \"count_all\" COUNT_VALUES = \"count_values\" COUNT_UNIQUE_VALUES = \"count_unique_values\" COUNT_EMPTY = \"count_empty\" COUNT_NOT_EMPTY = \"count_not_empty\" PERCENT_EMPTY = \"percent_empty\" PERCENT_NOT_EMPTY = \"percent_not_empty\" AVERAGE = \"average\" MIN = \"min\" MAX = \"max\" MEDIAN = \"median\" RANGE = \"range\" SUM = \"sum\" EARLIEST_DATE = \"earliest_date\" LATEST_DATE = \"latest_date\" SHOW_ORIGINAL = \"show_original\"","title":"Function"},{"location":"reference/schema/#notional.schema.LastEditedBy","text":"Defines the last-edited-by configuration for a database property. Source code in notional/schema.py class LastEditedBy ( PropertyObject , type = \"last_edited_by\" ): \"\"\"Defines the last-edited-by configuration for a database property.\"\"\" last_edited_by : Any = {}","title":"LastEditedBy"},{"location":"reference/schema/#notional.schema.LastEditedTime","text":"Defines the last-edited-time configuration for a database property. Source code in notional/schema.py class LastEditedTime ( PropertyObject , type = \"last_edited_time\" ): \"\"\"Defines the last-edited-time configuration for a database property.\"\"\" last_edited_time : Any = {}","title":"LastEditedTime"},{"location":"reference/schema/#notional.schema.MultiSelect","text":"Defines the multi-select configuration for a database property. Source code in notional/schema.py class MultiSelect ( PropertyObject , type = \"multi_select\" ): \"\"\"Defines the multi-select configuration for a database property.\"\"\" class _NestedData ( NestedObject ): options : List [ SelectOption ] = [] multi_select : _NestedData = _NestedData ()","title":"MultiSelect"},{"location":"reference/schema/#notional.schema.Number","text":"Defines the number configuration for a database property. Source code in notional/schema.py class Number ( PropertyObject , type = \"number\" ): \"\"\"Defines the number configuration for a database property.\"\"\" class _NestedData ( NestedObject ): format : NumberFormat = NumberFormat . NUMBER number : _NestedData = _NestedData () @classmethod def __compose__ ( cls , format ): \"\"\"Create a `Number` object with the expected format.\"\"\" return cls ( number = cls . _NestedData ( format = format ))","title":"Number"},{"location":"reference/schema/#notional.schema.Number.__compose__","text":"Create a Number object with the expected format. Source code in notional/schema.py @classmethod def __compose__ ( cls , format ): \"\"\"Create a `Number` object with the expected format.\"\"\" return cls ( number = cls . _NestedData ( format = format ))","title":"__compose__()"},{"location":"reference/schema/#notional.schema.NumberFormat","text":"Available number formats in Notion. Source code in notional/schema.py class NumberFormat ( str , Enum ): \"\"\"Available number formats in Notion.\"\"\" NUMBER = \"number\" NUMBER_WITH_COMMAS = \"number_with_commas\" PERCENT = \"percent\" DOLLAR = \"dollar\" CANADIAN_DOLLAR = \"canadian_dollar\" EURO = \"euro\" POUND = \"pound\" YEN = \"yen\" RUBLE = \"ruble\" RUPEE = \"rupee\" WON = \"won\" YUAN = \"yuan\" REAL = \"real\" LIRA = \"lira\" RUPIAH = \"rupiah\" FRANC = \"franc\" HONG_KONG_DOLLAR = \"hong_kong_dollar\" NEW_ZEALAND_DOLLAR = \"new_zealand_dollar\" KRONA = \"krona\" NORWEGIAN_KRONE = \"norwegian_krone\" MEXICAN_PESO = \"mexican_peso\" RAND = \"rand\" NEW_TAIWAN_DOLLAR = \"new_taiwan_dollar\" DANISH_KRONE = \"danish_krone\" ZLOTY = \"zloty\" BAHT = \"baht\" FORINT = \"forint\" KORUNA = \"koruna\" SHEKEL = \"shekel\" CHILEAN_PESO = \"chilean_peso\" PHILIPPINE_PESO = \"philippine_peso\" DIRHAM = \"dirham\" COLOMBIAN_PESO = \"colombian_peso\" RIYAL = \"riyal\" RINGGIT = \"ringgit\" LEU = \"leu\"","title":"NumberFormat"},{"location":"reference/schema/#notional.schema.People","text":"Defines the people configuration for a database property. Source code in notional/schema.py class People ( PropertyObject , type = \"people\" ): \"\"\"Defines the people configuration for a database property.\"\"\" people : Any = {}","title":"People"},{"location":"reference/schema/#notional.schema.PhoneNumber","text":"Defines the phone number configuration for a database property. Source code in notional/schema.py class PhoneNumber ( PropertyObject , type = \"phone_number\" ): \"\"\"Defines the phone number configuration for a database property.\"\"\" phone_number : Any = {}","title":"PhoneNumber"},{"location":"reference/schema/#notional.schema.PropertyObject","text":"Base class for Notion property objects. Source code in notional/schema.py class PropertyObject ( TypedObject ): \"\"\"Base class for Notion property objects.\"\"\" id : Optional [ str ] = None name : Optional [ str ] = None","title":"PropertyObject"},{"location":"reference/schema/#notional.schema.Relation","text":"Defines the relation configuration for a database property. Source code in notional/schema.py class Relation ( PropertyObject , type = \"relation\" ): \"\"\"Defines the relation configuration for a database property.\"\"\" class _NestedData ( NestedObject ): database_id : UUID = None relation : _NestedData = _NestedData () @classmethod def __compose__ ( cls , database_id ): \"\"\"Create a `Relation` property using the target database ID.\"\"\" return cls ( relation = cls . _NestedData ( database_id = database_id ))","title":"Relation"},{"location":"reference/schema/#notional.schema.Relation.__compose__","text":"Create a Relation property using the target database ID. Source code in notional/schema.py @classmethod def __compose__ ( cls , database_id ): \"\"\"Create a `Relation` property using the target database ID.\"\"\" return cls ( relation = cls . _NestedData ( database_id = database_id ))","title":"__compose__()"},{"location":"reference/schema/#notional.schema.RichText","text":"Defines the rich text configuration for a database property. Source code in notional/schema.py class RichText ( PropertyObject , type = \"rich_text\" ): \"\"\"Defines the rich text configuration for a database property.\"\"\" rich_text : Any = {}","title":"RichText"},{"location":"reference/schema/#notional.schema.Rollup","text":"Defines the rollup configuration for a database property. Source code in notional/schema.py class Rollup ( PropertyObject , type = \"rollup\" ): \"\"\"Defines the rollup configuration for a database property.\"\"\" class _NestedData ( NestedObject ): function : Function = Function . COUNT_ALL relation_property_name : Optional [ str ] = None relation_property_id : Optional [ str ] = None rollup_property_name : Optional [ str ] = None rollup_property_id : Optional [ str ] = None rollup : _NestedData = _NestedData ()","title":"Rollup"},{"location":"reference/schema/#notional.schema.Select","text":"Defines the select configuration for a database property. Source code in notional/schema.py class Select ( PropertyObject , type = \"select\" ): \"\"\"Defines the select configuration for a database property.\"\"\" class _NestedData ( NestedObject ): options : List [ SelectOption ] = [] select : _NestedData = _NestedData () @classmethod def __compose__ ( cls , options ): \"\"\"Create a `Select` object from the list of `SelectOption`'s.\"\"\" return cls ( select = cls . _NestedData ( options = options ))","title":"Select"},{"location":"reference/schema/#notional.schema.Select.__compose__","text":"Create a Select object from the list of SelectOption 's. Source code in notional/schema.py @classmethod def __compose__ ( cls , options ): \"\"\"Create a `Select` object from the list of `SelectOption`'s.\"\"\" return cls ( select = cls . _NestedData ( options = options ))","title":"__compose__()"},{"location":"reference/schema/#notional.schema.SelectOption","text":"Options for select & multi-select objects. Source code in notional/schema.py class SelectOption ( DataObject ): \"\"\"Options for select & multi-select objects.\"\"\" name : str id : str = None color : str = Color . DEFAULT @classmethod def __compose__ ( cls , name , color = Color . DEFAULT ): \"\"\"Create a `SelectOption` object from the given name and color.\"\"\" return cls ( name = name , color = color )","title":"SelectOption"},{"location":"reference/schema/#notional.schema.SelectOption.__compose__","text":"Create a SelectOption object from the given name and color. Source code in notional/schema.py @classmethod def __compose__ ( cls , name , color = Color . DEFAULT ): \"\"\"Create a `SelectOption` object from the given name and color.\"\"\" return cls ( name = name , color = color )","title":"__compose__()"},{"location":"reference/schema/#notional.schema.Title","text":"Defines the title configuration for a database property. Source code in notional/schema.py class Title ( PropertyObject , type = \"title\" ): \"\"\"Defines the title configuration for a database property.\"\"\" title : Any = {}","title":"Title"},{"location":"reference/schema/#notional.schema.URL","text":"Defines the URL configuration for a database property. Source code in notional/schema.py class URL ( PropertyObject , type = \"url\" ): \"\"\"Defines the URL configuration for a database property.\"\"\" url : Any = {}","title":"URL"},{"location":"reference/session/","text":"Provides direct access to the Notion API. BlocksEndpoint ( Endpoint ) Notional interface to the API 'blocks' endpoint. Source code in notional/session.py class BlocksEndpoint ( Endpoint ): \"\"\"Notional interface to the API 'blocks' endpoint.\"\"\" class ChildrenEndpoint ( Endpoint ): \"\"\"Notional interface to the API 'blocks/children' endpoint.\"\"\" def __call__ ( self ): \"\"\"Return the underlying endpoint in the Notion SDK.\"\"\" return self . session . client . blocks . children # https://developers.notion.com/reference/patch-block-children def append ( self , parent , * blocks ): \"\"\"Add the given blocks as children of the specified parent. The blocks info will be refreshed based on returned data. \"\"\" parent_id = get_target_id ( parent ) children = [ block . to_api () for block in blocks if block is not None ] log . info ( \"Appending %d blocks to %s ...\" , len ( children ), parent_id ) data = self () . append ( block_id = parent_id , children = children ) if \"results\" in data : if len ( blocks ) == len ( data [ \"results\" ]): for idx in range ( len ( blocks )): block = blocks [ idx ] result = data [ \"results\" ][ idx ] block . refresh ( ** result ) else : log . warning ( \"Unable to refresh results; size mismatch\" ) else : log . warning ( \"Unable to refresh results; not provided\" ) return parent # https://developers.notion.com/reference/get-block-children def list ( self , parent ): \"\"\"Return all Blocks contained by the specified parent.\"\"\" parent_id = get_target_id ( parent ) blocks = EndpointIterator ( endpoint = self () . list , block_id = parent_id ) log . info ( \"Listing blocks for %s ...\" , parent_id ) return ResultSet ( exec = blocks , cls = Block ) def __init__ ( self , * args , ** kwargs ): \"\"\"Initialize the `blocks` endpoint for the Notion API.\"\"\" super () . __init__ ( * args , ** kwargs ) self . children = BlocksEndpoint . ChildrenEndpoint ( * args , ** kwargs ) def __call__ ( self ): \"\"\"Return the underlying endpoint in the Notion SDK.\"\"\" return self . session . client . blocks # https://developers.notion.com/reference/delete-a-block def delete ( self , block ): \"\"\"Delete (archive) the specified Block.\"\"\" log . info ( \"Deleting block :: %s \" , block . id ) data = self () . delete ( block . id . hex ) return block . refresh ( ** data ) def restore ( self , block ): \"\"\"Restore (unarchive) the specified Block.\"\"\" log . info ( \"Restoring block :: %s \" , block . id ) data = self () . update ( block . id . hex , archived = False ) return block . refresh ( ** data ) # https://developers.notion.com/reference/retrieve-a-block def retrieve ( self , block_id ): \"\"\"Return the Block with the given ID.\"\"\" log . info ( \"Retrieving block :: %s \" , block_id ) data = self () . retrieve ( block_id ) return Block . parse_obj ( data ) # https://developers.notion.com/reference/update-a-block def update ( self , block ): \"\"\"Update the block content on the server. The block info will be refreshed to the latest version from the server. \"\"\" log . info ( \"Updating block :: %s \" , block . id ) data = self () . update ( block . id . hex , ** block . to_api ()) return block . refresh ( ** data ) ChildrenEndpoint ( Endpoint ) Notional interface to the API 'blocks/children' endpoint. Source code in notional/session.py class ChildrenEndpoint ( Endpoint ): \"\"\"Notional interface to the API 'blocks/children' endpoint.\"\"\" def __call__ ( self ): \"\"\"Return the underlying endpoint in the Notion SDK.\"\"\" return self . session . client . blocks . children # https://developers.notion.com/reference/patch-block-children def append ( self , parent , * blocks ): \"\"\"Add the given blocks as children of the specified parent. The blocks info will be refreshed based on returned data. \"\"\" parent_id = get_target_id ( parent ) children = [ block . to_api () for block in blocks if block is not None ] log . info ( \"Appending %d blocks to %s ...\" , len ( children ), parent_id ) data = self () . append ( block_id = parent_id , children = children ) if \"results\" in data : if len ( blocks ) == len ( data [ \"results\" ]): for idx in range ( len ( blocks )): block = blocks [ idx ] result = data [ \"results\" ][ idx ] block . refresh ( ** result ) else : log . warning ( \"Unable to refresh results; size mismatch\" ) else : log . warning ( \"Unable to refresh results; not provided\" ) return parent # https://developers.notion.com/reference/get-block-children def list ( self , parent ): \"\"\"Return all Blocks contained by the specified parent.\"\"\" parent_id = get_target_id ( parent ) blocks = EndpointIterator ( endpoint = self () . list , block_id = parent_id ) log . info ( \"Listing blocks for %s ...\" , parent_id ) return ResultSet ( exec = blocks , cls = Block ) __call__ ( self ) special Return the underlying endpoint in the Notion SDK. Source code in notional/session.py def __call__ ( self ): \"\"\"Return the underlying endpoint in the Notion SDK.\"\"\" return self . session . client . blocks . children append ( self , parent , * blocks ) Add the given blocks as children of the specified parent. The blocks info will be refreshed based on returned data. Source code in notional/session.py def append ( self , parent , * blocks ): \"\"\"Add the given blocks as children of the specified parent. The blocks info will be refreshed based on returned data. \"\"\" parent_id = get_target_id ( parent ) children = [ block . to_api () for block in blocks if block is not None ] log . info ( \"Appending %d blocks to %s ...\" , len ( children ), parent_id ) data = self () . append ( block_id = parent_id , children = children ) if \"results\" in data : if len ( blocks ) == len ( data [ \"results\" ]): for idx in range ( len ( blocks )): block = blocks [ idx ] result = data [ \"results\" ][ idx ] block . refresh ( ** result ) else : log . warning ( \"Unable to refresh results; size mismatch\" ) else : log . warning ( \"Unable to refresh results; not provided\" ) return parent list ( self , parent ) Return all Blocks contained by the specified parent. Source code in notional/session.py def list ( self , parent ): \"\"\"Return all Blocks contained by the specified parent.\"\"\" parent_id = get_target_id ( parent ) blocks = EndpointIterator ( endpoint = self () . list , block_id = parent_id ) log . info ( \"Listing blocks for %s ...\" , parent_id ) return ResultSet ( exec = blocks , cls = Block ) __call__ ( self ) special Return the underlying endpoint in the Notion SDK. Source code in notional/session.py def __call__ ( self ): \"\"\"Return the underlying endpoint in the Notion SDK.\"\"\" return self . session . client . blocks __init__ ( self , * args , ** kwargs ) special Initialize the blocks endpoint for the Notion API. Source code in notional/session.py def __init__ ( self , * args , ** kwargs ): \"\"\"Initialize the `blocks` endpoint for the Notion API.\"\"\" super () . __init__ ( * args , ** kwargs ) self . children = BlocksEndpoint . ChildrenEndpoint ( * args , ** kwargs ) delete ( self , block ) Delete (archive) the specified Block. Source code in notional/session.py def delete ( self , block ): \"\"\"Delete (archive) the specified Block.\"\"\" log . info ( \"Deleting block :: %s \" , block . id ) data = self () . delete ( block . id . hex ) return block . refresh ( ** data ) restore ( self , block ) Restore (unarchive) the specified Block. Source code in notional/session.py def restore ( self , block ): \"\"\"Restore (unarchive) the specified Block.\"\"\" log . info ( \"Restoring block :: %s \" , block . id ) data = self () . update ( block . id . hex , archived = False ) return block . refresh ( ** data ) retrieve ( self , block_id ) Return the Block with the given ID. Source code in notional/session.py def retrieve ( self , block_id ): \"\"\"Return the Block with the given ID.\"\"\" log . info ( \"Retrieving block :: %s \" , block_id ) data = self () . retrieve ( block_id ) return Block . parse_obj ( data ) update ( self , block ) Update the block content on the server. The block info will be refreshed to the latest version from the server. Source code in notional/session.py def update ( self , block ): \"\"\"Update the block content on the server. The block info will be refreshed to the latest version from the server. \"\"\" log . info ( \"Updating block :: %s \" , block . id ) data = self () . update ( block . id . hex , ** block . to_api ()) return block . refresh ( ** data ) DatabasesEndpoint ( Endpoint ) Notional interface to the API 'databases' endpoint. Source code in notional/session.py class DatabasesEndpoint ( Endpoint ): \"\"\"Notional interface to the API 'databases' endpoint.\"\"\" def __call__ ( self ): \"\"\"Return the underlying endpoint in the Notion SDK.\"\"\" return self . session . client . databases def _build_request ( self , parent = None , schema = None , title = None ): \"\"\"Build a request payload from the given items. *NOTE* this method does not anticipate what the request will be used for and as such does not validate the inputs for any particular requests. \"\"\" request = {} if parent is not None : ref = ParentRef [ parent ] request [ \"parent\" ] = ref . to_api () if isinstance ( title , TextObject ): request [ \"title\" ] = [ title . to_api ()] elif isinstance ( title , list ): request [ \"title\" ] = [ prop . to_api () for prop in title if prop is not None ] elif isinstance ( title , str ): prop = TextObject [ title ] request [ \"title\" ] = [ prop . to_api ()] elif title is not None : raise ValueError ( \"Unrecognized data in 'title'\" ) if schema is not None : request [ \"properties\" ] = { name : value . to_api () if value is not None else None for name , value in schema . items () } return request # https://developers.notion.com/reference/create-a-database def create ( self , parent , schema , title = None ): \"\"\"Add a database to the given Page parent.\"\"\" log . info ( \"Creating database %s - %s \" , parent , title ) request = self . _build_request ( parent , schema , title ) data = self () . create ( ** request ) return Database . parse_obj ( data ) # https://developers.notion.com/reference/get-databases def list ( self ): \"\"\"Return an iterator for all Database objects in the integration scope.\"\"\" # DEPRECATED ENDPOINT ### log . info ( \"Listing known databases...\" ) databases = EndpointIterator ( endpoint = self () . list ) return ResultSet ( exec = databases , cls = Database ) # https://developers.notion.com/reference/retrieve-a-database def retrieve ( self , database_id ): \"\"\"Return the Database with the given ID.\"\"\" log . info ( \"Retrieving database :: %s \" , database_id ) data = self () . retrieve ( database_id ) return Database . parse_obj ( data ) # https://developers.notion.com/reference/update-a-database def update ( self , database , title = None , schema = None ): \"\"\"Update the Database object on the server. The database info will be refreshed to the latest version from the server. \"\"\" dbid = get_target_id ( database ) log . info ( \"Updating database info :: \" , dbid ) request = self . _build_request ( schema = schema , title = title ) if request : data = self () . update ( dbid , ** request ) database = database . refresh ( ** data ) return database def delete ( self , database ): \"\"\"Delete (archive) the specified Database.\"\"\" log . info ( \"Deleting database :: %s \" , database . id ) return self . session . blocks . delete ( database ) def restore ( self , database ): \"\"\"Restore (unarchive) the specified Database.\"\"\" log . info ( \"Restoring database :: %s \" , database . id ) return self . session . blocks . restore ( database ) # https://developers.notion.com/reference/post-database-query def query ( self , target ): \"\"\"Initialize a new Query object with the target data class. :param target: either a string with the database ID or an ORM class \"\"\" log . info ( \"Initializing database query :: { %s }\" , get_target_id ( target )) database_id = get_target_id ( target ) cls = None if isclass ( target ) and issubclass ( target , ConnectedPage ): cls = target if cls . _notional__session != self . session : raise ValueError ( \"ConnectedPage belongs to a different session\" ) return QueryBuilder ( endpoint = self () . query , cls = cls , database_id = database_id ) __call__ ( self ) special Return the underlying endpoint in the Notion SDK. Source code in notional/session.py def __call__ ( self ): \"\"\"Return the underlying endpoint in the Notion SDK.\"\"\" return self . session . client . databases create ( self , parent , schema , title = None ) Add a database to the given Page parent. Source code in notional/session.py def create ( self , parent , schema , title = None ): \"\"\"Add a database to the given Page parent.\"\"\" log . info ( \"Creating database %s - %s \" , parent , title ) request = self . _build_request ( parent , schema , title ) data = self () . create ( ** request ) return Database . parse_obj ( data ) delete ( self , database ) Delete (archive) the specified Database. Source code in notional/session.py def delete ( self , database ): \"\"\"Delete (archive) the specified Database.\"\"\" log . info ( \"Deleting database :: %s \" , database . id ) return self . session . blocks . delete ( database ) list ( self ) Return an iterator for all Database objects in the integration scope. Source code in notional/session.py def list ( self ): \"\"\"Return an iterator for all Database objects in the integration scope.\"\"\" # DEPRECATED ENDPOINT ### log . info ( \"Listing known databases...\" ) databases = EndpointIterator ( endpoint = self () . list ) return ResultSet ( exec = databases , cls = Database ) query ( self , target ) Initialize a new Query object with the target data class. :param target: either a string with the database ID or an ORM class Source code in notional/session.py def query ( self , target ): \"\"\"Initialize a new Query object with the target data class. :param target: either a string with the database ID or an ORM class \"\"\" log . info ( \"Initializing database query :: { %s }\" , get_target_id ( target )) database_id = get_target_id ( target ) cls = None if isclass ( target ) and issubclass ( target , ConnectedPage ): cls = target if cls . _notional__session != self . session : raise ValueError ( \"ConnectedPage belongs to a different session\" ) return QueryBuilder ( endpoint = self () . query , cls = cls , database_id = database_id ) restore ( self , database ) Restore (unarchive) the specified Database. Source code in notional/session.py def restore ( self , database ): \"\"\"Restore (unarchive) the specified Database.\"\"\" log . info ( \"Restoring database :: %s \" , database . id ) return self . session . blocks . restore ( database ) retrieve ( self , database_id ) Return the Database with the given ID. Source code in notional/session.py def retrieve ( self , database_id ): \"\"\"Return the Database with the given ID.\"\"\" log . info ( \"Retrieving database :: %s \" , database_id ) data = self () . retrieve ( database_id ) return Database . parse_obj ( data ) update ( self , database , title = None , schema = None ) Update the Database object on the server. The database info will be refreshed to the latest version from the server. Source code in notional/session.py def update ( self , database , title = None , schema = None ): \"\"\"Update the Database object on the server. The database info will be refreshed to the latest version from the server. \"\"\" dbid = get_target_id ( database ) log . info ( \"Updating database info :: \" , dbid ) request = self . _build_request ( schema = schema , title = title ) if request : data = self () . update ( dbid , ** request ) database = database . refresh ( ** data ) return database Endpoint Notional wrapper for the API endpoints. Source code in notional/session.py class Endpoint ( object ): \"\"\"Notional wrapper for the API endpoints.\"\"\" def __init__ ( self , session ): \"\"\"Initialize the `Endpoint` for the supplied session.\"\"\" self . session = session __init__ ( self , session ) special Initialize the Endpoint for the supplied session. Source code in notional/session.py def __init__ ( self , session ): \"\"\"Initialize the `Endpoint` for the supplied session.\"\"\" self . session = session PagesEndpoint ( Endpoint ) Notional interface to the API 'pages' endpoint. Source code in notional/session.py class PagesEndpoint ( Endpoint ): \"\"\"Notional interface to the API 'pages' endpoint.\"\"\" def __call__ ( self ): \"\"\"Return the underlying endpoint in the Notion SDK.\"\"\" return self . session . client . pages # https://developers.notion.com/reference/post-page def create ( self , parent , title = None , properties = None , children = None ): \"\"\"Add a page to the given parent (Page or Database).\"\"\" if parent is None : raise ValueError ( \"'parent' must be provided\" ) parent = ParentRef [ parent ] request = { \"parent\" : parent . to_api ()} # the API requires a properties object, even if empty if properties is None : properties = {} if title is not None : properties [ \"title\" ] = Title [ title ] request [ \"properties\" ] = { name : prop . to_api () if prop is not None else None for name , prop in properties . items () } if children is not None : request [ \"children\" ] = [ child . to_api () for child in children if child is not None ] log . info ( \"Creating page :: %s => %s \" , parent , title ) data = self () . create ( ** request ) return Page . parse_obj ( data ) def delete ( self , page ): \"\"\"Delete (archive) the specified Page.\"\"\" return self . set ( page , archived = True ) def restore ( self , page ): \"\"\"Restore (unarchive) the specified Page.\"\"\" return self . set ( page , archived = False ) # https://developers.notion.com/reference/retrieve-a-page def retrieve ( self , page_id ): \"\"\"Return the Page with the given ID.\"\"\" log . info ( \"Retrieving page :: %s \" , page_id ) data = self () . retrieve ( page_id ) return Page . parse_obj ( data ) # https://developers.notion.com/reference/patch-page def update ( self , page , ** properties ): \"\"\"Update the Page object properties on the server. If `properties` are provided, only those values will be updated. If `properties` is empty, all page properties will be updated. `properties` are specified as `\"name\"`: `PropertyValue` pairs. The page info will be refreshed to the latest version from the server. \"\"\" log . info ( \"Updating page info :: %s \" , page . id ) if not properties : properties = page . properties props = { name : value . to_api () if value is not None else None for name , value in properties . items () } data = self () . update ( page . id . hex , properties = props ) return page . refresh ( ** data ) def set ( self , page , cover = False , icon = False , archived = None ): \"\"\"Set specific page attributes (such as cover, icon, etc) on the server. To remove an attribute, set its value to None. \"\"\" if cover is None : log . info ( \"Removing page cover :: %s \" , page . id ) data = self () . update ( page . id . hex , cover = {}) elif cover is not False : log . info ( \"Setting page cover :: %s => %s \" , page . id , cover ) data = self () . update ( page . id . hex , cover = cover . to_api ()) if icon is None : log . info ( \"Removing page icon :: %s \" , page . id ) data = self () . update ( page . id . hex , icon = {}) elif icon is not False : log . info ( \"Setting page icon :: %s => %s \" , page . id , icon ) data = self () . update ( page . id . hex , icon = icon . to_api ()) if archived is False : log . info ( \"Restoring page :: %s \" , page . id ) data = self () . update ( page . id . hex , archived = False ) elif archived is True : log . info ( \"Archiving page :: %s \" , page . id ) data = self () . update ( page . id . hex , archived = True ) return page . refresh ( ** data ) __call__ ( self ) special Return the underlying endpoint in the Notion SDK. Source code in notional/session.py def __call__ ( self ): \"\"\"Return the underlying endpoint in the Notion SDK.\"\"\" return self . session . client . pages create ( self , parent , title = None , properties = None , children = None ) Add a page to the given parent (Page or Database). Source code in notional/session.py def create ( self , parent , title = None , properties = None , children = None ): \"\"\"Add a page to the given parent (Page or Database).\"\"\" if parent is None : raise ValueError ( \"'parent' must be provided\" ) parent = ParentRef [ parent ] request = { \"parent\" : parent . to_api ()} # the API requires a properties object, even if empty if properties is None : properties = {} if title is not None : properties [ \"title\" ] = Title [ title ] request [ \"properties\" ] = { name : prop . to_api () if prop is not None else None for name , prop in properties . items () } if children is not None : request [ \"children\" ] = [ child . to_api () for child in children if child is not None ] log . info ( \"Creating page :: %s => %s \" , parent , title ) data = self () . create ( ** request ) return Page . parse_obj ( data ) delete ( self , page ) Delete (archive) the specified Page. Source code in notional/session.py def delete ( self , page ): \"\"\"Delete (archive) the specified Page.\"\"\" return self . set ( page , archived = True ) restore ( self , page ) Restore (unarchive) the specified Page. Source code in notional/session.py def restore ( self , page ): \"\"\"Restore (unarchive) the specified Page.\"\"\" return self . set ( page , archived = False ) retrieve ( self , page_id ) Return the Page with the given ID. Source code in notional/session.py def retrieve ( self , page_id ): \"\"\"Return the Page with the given ID.\"\"\" log . info ( \"Retrieving page :: %s \" , page_id ) data = self () . retrieve ( page_id ) return Page . parse_obj ( data ) set ( self , page , cover = False , icon = False , archived = None ) Set specific page attributes (such as cover, icon, etc) on the server. To remove an attribute, set its value to None. Source code in notional/session.py def set ( self , page , cover = False , icon = False , archived = None ): \"\"\"Set specific page attributes (such as cover, icon, etc) on the server. To remove an attribute, set its value to None. \"\"\" if cover is None : log . info ( \"Removing page cover :: %s \" , page . id ) data = self () . update ( page . id . hex , cover = {}) elif cover is not False : log . info ( \"Setting page cover :: %s => %s \" , page . id , cover ) data = self () . update ( page . id . hex , cover = cover . to_api ()) if icon is None : log . info ( \"Removing page icon :: %s \" , page . id ) data = self () . update ( page . id . hex , icon = {}) elif icon is not False : log . info ( \"Setting page icon :: %s => %s \" , page . id , icon ) data = self () . update ( page . id . hex , icon = icon . to_api ()) if archived is False : log . info ( \"Restoring page :: %s \" , page . id ) data = self () . update ( page . id . hex , archived = False ) elif archived is True : log . info ( \"Archiving page :: %s \" , page . id ) data = self () . update ( page . id . hex , archived = True ) return page . refresh ( ** data ) update ( self , page , ** properties ) Update the Page object properties on the server. If properties are provided, only those values will be updated. If properties is empty, all page properties will be updated. properties are specified as \"name\" : PropertyValue pairs. The page info will be refreshed to the latest version from the server. Source code in notional/session.py def update ( self , page , ** properties ): \"\"\"Update the Page object properties on the server. If `properties` are provided, only those values will be updated. If `properties` is empty, all page properties will be updated. `properties` are specified as `\"name\"`: `PropertyValue` pairs. The page info will be refreshed to the latest version from the server. \"\"\" log . info ( \"Updating page info :: %s \" , page . id ) if not properties : properties = page . properties props = { name : value . to_api () if value is not None else None for name , value in properties . items () } data = self () . update ( page . id . hex , properties = props ) return page . refresh ( ** data ) SearchEndpoint ( Endpoint ) Notional interface to the API 'search' endpoint. Source code in notional/session.py class SearchEndpoint ( Endpoint ): \"\"\"Notional interface to the API 'search' endpoint.\"\"\" # https://developers.notion.com/reference/post-search def __call__ ( self , text = None ): \"\"\"Perform a search with the optional text. If specified, the call will perform a search with the given text. :return: a `QueryBuilder` with the requested search :rtype: query.QueryBuilder \"\"\" params = {} if text is not None : params [ \"query\" ] = text return QueryBuilder ( endpoint = self . session . client . search , ** params ) __call__ ( self , text = None ) special Perform a search with the optional text. If specified, the call will perform a search with the given text. :return: a QueryBuilder with the requested search :rtype: query.QueryBuilder Source code in notional/session.py def __call__ ( self , text = None ): \"\"\"Perform a search with the optional text. If specified, the call will perform a search with the given text. :return: a `QueryBuilder` with the requested search :rtype: query.QueryBuilder \"\"\" params = {} if text is not None : params [ \"query\" ] = text return QueryBuilder ( endpoint = self . session . client . search , ** params ) Session An active session with the Notion SDK. Source code in notional/session.py class Session ( object ): \"\"\"An active session with the Notion SDK.\"\"\" def __init__ ( self , ** kwargs ): \"\"\"Initialize the `Session` object and the endpoints. `kwargs` will be passed direction to the Notion SDK Client. For more details, see the (full docs)[https://ramnes.github.io/notion-sdk-py/reference/client/]. :param auth: bearer token for authentication \"\"\" self . client = notion_client . Client ( ** kwargs ) self . blocks = BlocksEndpoint ( self ) self . databases = DatabasesEndpoint ( self ) self . pages = PagesEndpoint ( self ) self . search = SearchEndpoint ( self ) self . users = UsersEndpoint ( self ) log . info ( \"Initialized Notion SDK client\" ) @property def IsActive ( self ): \"\"\"Determine if the current session is active. The session is considered \"active\" if it has not been closed. This does not determine if the session can connect to the Notion API. \"\"\" return self . client is not None def close ( self ): \"\"\"Close the session and release resources.\"\"\" if self . client is None : raise SessionError ( \"Session is not active.\" ) self . client . close () self . client = None def ping ( self ): \"\"\"Confirm that the session is active and able to connect to Notion. Raises SessionError if there is a problem, otherwise returns True. \"\"\" if self . IsActive is False : return False error = None try : me = self . users . me () if me is None : raise SessionError ( \"Unable to get current user\" ) except ConnectError : error = \"Unable to connect to Notion\" except APIResponseError as err : error = str ( err ) if error is not None : raise SessionError ( error ) return True IsActive property readonly Determine if the current session is active. The session is considered \"active\" if it has not been closed. This does not determine if the session can connect to the Notion API. __init__ ( self , ** kwargs ) special Initialize the Session object and the endpoints. kwargs will be passed direction to the Notion SDK Client. For more details, see the (full docs)[https://ramnes.github.io/notion-sdk-py/reference/client/]. :param auth: bearer token for authentication Source code in notional/session.py def __init__ ( self , ** kwargs ): \"\"\"Initialize the `Session` object and the endpoints. `kwargs` will be passed direction to the Notion SDK Client. For more details, see the (full docs)[https://ramnes.github.io/notion-sdk-py/reference/client/]. :param auth: bearer token for authentication \"\"\" self . client = notion_client . Client ( ** kwargs ) self . blocks = BlocksEndpoint ( self ) self . databases = DatabasesEndpoint ( self ) self . pages = PagesEndpoint ( self ) self . search = SearchEndpoint ( self ) self . users = UsersEndpoint ( self ) log . info ( \"Initialized Notion SDK client\" ) close ( self ) Close the session and release resources. Source code in notional/session.py def close ( self ): \"\"\"Close the session and release resources.\"\"\" if self . client is None : raise SessionError ( \"Session is not active.\" ) self . client . close () self . client = None ping ( self ) Confirm that the session is active and able to connect to Notion. Raises SessionError if there is a problem, otherwise returns True. Source code in notional/session.py def ping ( self ): \"\"\"Confirm that the session is active and able to connect to Notion. Raises SessionError if there is a problem, otherwise returns True. \"\"\" if self . IsActive is False : return False error = None try : me = self . users . me () if me is None : raise SessionError ( \"Unable to get current user\" ) except ConnectError : error = \"Unable to connect to Notion\" except APIResponseError as err : error = str ( err ) if error is not None : raise SessionError ( error ) return True SessionError ( Exception ) Raised when there are issues with the Notion session. Source code in notional/session.py class SessionError ( Exception ): \"\"\"Raised when there are issues with the Notion session.\"\"\" def __init__ ( self , message ): \"\"\"Initialize the `SessionError` with a supplied message..\"\"\" super () . __init__ ( message ) __init__ ( self , message ) special Initialize the SessionError with a supplied message.. Source code in notional/session.py def __init__ ( self , message ): \"\"\"Initialize the `SessionError` with a supplied message..\"\"\" super () . __init__ ( message ) UsersEndpoint ( Endpoint ) Notional interface to the API 'users' endpoint. Source code in notional/session.py class UsersEndpoint ( Endpoint ): \"\"\"Notional interface to the API 'users' endpoint.\"\"\" def __call__ ( self ): \"\"\"Return the underlying endpoint in the Notion SDK.\"\"\" return self . session . client . users # https://developers.notion.com/reference/get-users def list ( self ): \"\"\"Return an iterator for all users in the workspace.\"\"\" users = EndpointIterator ( endpoint = self () . list ) log . info ( \"Listing known users...\" ) return ResultSet ( exec = users , cls = User ) # https://developers.notion.com/reference/get-user def retrieve ( self , user_id ): \"\"\"Return the User with the given ID.\"\"\" log . info ( \"Retrieving user :: %s \" , user_id ) data = self () . retrieve ( user_id ) return User . parse_obj ( data ) # https://developers.notion.com/reference/get-self def me ( self ): \"\"\"Return the current bot User.\"\"\" log . info ( \"Retrieving current integration bot\" ) data = self () . me () return User . parse_obj ( data ) __call__ ( self ) special Return the underlying endpoint in the Notion SDK. Source code in notional/session.py def __call__ ( self ): \"\"\"Return the underlying endpoint in the Notion SDK.\"\"\" return self . session . client . users list ( self ) Return an iterator for all users in the workspace. Source code in notional/session.py def list ( self ): \"\"\"Return an iterator for all users in the workspace.\"\"\" users = EndpointIterator ( endpoint = self () . list ) log . info ( \"Listing known users...\" ) return ResultSet ( exec = users , cls = User ) me ( self ) Return the current bot User. Source code in notional/session.py def me ( self ): \"\"\"Return the current bot User.\"\"\" log . info ( \"Retrieving current integration bot\" ) data = self () . me () return User . parse_obj ( data ) retrieve ( self , user_id ) Return the User with the given ID. Source code in notional/session.py def retrieve ( self , user_id ): \"\"\"Return the User with the given ID.\"\"\" log . info ( \"Retrieving user :: %s \" , user_id ) data = self () . retrieve ( user_id ) return User . parse_obj ( data )","title":"Session"},{"location":"reference/session/#notional.session.BlocksEndpoint","text":"Notional interface to the API 'blocks' endpoint. Source code in notional/session.py class BlocksEndpoint ( Endpoint ): \"\"\"Notional interface to the API 'blocks' endpoint.\"\"\" class ChildrenEndpoint ( Endpoint ): \"\"\"Notional interface to the API 'blocks/children' endpoint.\"\"\" def __call__ ( self ): \"\"\"Return the underlying endpoint in the Notion SDK.\"\"\" return self . session . client . blocks . children # https://developers.notion.com/reference/patch-block-children def append ( self , parent , * blocks ): \"\"\"Add the given blocks as children of the specified parent. The blocks info will be refreshed based on returned data. \"\"\" parent_id = get_target_id ( parent ) children = [ block . to_api () for block in blocks if block is not None ] log . info ( \"Appending %d blocks to %s ...\" , len ( children ), parent_id ) data = self () . append ( block_id = parent_id , children = children ) if \"results\" in data : if len ( blocks ) == len ( data [ \"results\" ]): for idx in range ( len ( blocks )): block = blocks [ idx ] result = data [ \"results\" ][ idx ] block . refresh ( ** result ) else : log . warning ( \"Unable to refresh results; size mismatch\" ) else : log . warning ( \"Unable to refresh results; not provided\" ) return parent # https://developers.notion.com/reference/get-block-children def list ( self , parent ): \"\"\"Return all Blocks contained by the specified parent.\"\"\" parent_id = get_target_id ( parent ) blocks = EndpointIterator ( endpoint = self () . list , block_id = parent_id ) log . info ( \"Listing blocks for %s ...\" , parent_id ) return ResultSet ( exec = blocks , cls = Block ) def __init__ ( self , * args , ** kwargs ): \"\"\"Initialize the `blocks` endpoint for the Notion API.\"\"\" super () . __init__ ( * args , ** kwargs ) self . children = BlocksEndpoint . ChildrenEndpoint ( * args , ** kwargs ) def __call__ ( self ): \"\"\"Return the underlying endpoint in the Notion SDK.\"\"\" return self . session . client . blocks # https://developers.notion.com/reference/delete-a-block def delete ( self , block ): \"\"\"Delete (archive) the specified Block.\"\"\" log . info ( \"Deleting block :: %s \" , block . id ) data = self () . delete ( block . id . hex ) return block . refresh ( ** data ) def restore ( self , block ): \"\"\"Restore (unarchive) the specified Block.\"\"\" log . info ( \"Restoring block :: %s \" , block . id ) data = self () . update ( block . id . hex , archived = False ) return block . refresh ( ** data ) # https://developers.notion.com/reference/retrieve-a-block def retrieve ( self , block_id ): \"\"\"Return the Block with the given ID.\"\"\" log . info ( \"Retrieving block :: %s \" , block_id ) data = self () . retrieve ( block_id ) return Block . parse_obj ( data ) # https://developers.notion.com/reference/update-a-block def update ( self , block ): \"\"\"Update the block content on the server. The block info will be refreshed to the latest version from the server. \"\"\" log . info ( \"Updating block :: %s \" , block . id ) data = self () . update ( block . id . hex , ** block . to_api ()) return block . refresh ( ** data )","title":"BlocksEndpoint"},{"location":"reference/session/#notional.session.BlocksEndpoint.ChildrenEndpoint","text":"Notional interface to the API 'blocks/children' endpoint. Source code in notional/session.py class ChildrenEndpoint ( Endpoint ): \"\"\"Notional interface to the API 'blocks/children' endpoint.\"\"\" def __call__ ( self ): \"\"\"Return the underlying endpoint in the Notion SDK.\"\"\" return self . session . client . blocks . children # https://developers.notion.com/reference/patch-block-children def append ( self , parent , * blocks ): \"\"\"Add the given blocks as children of the specified parent. The blocks info will be refreshed based on returned data. \"\"\" parent_id = get_target_id ( parent ) children = [ block . to_api () for block in blocks if block is not None ] log . info ( \"Appending %d blocks to %s ...\" , len ( children ), parent_id ) data = self () . append ( block_id = parent_id , children = children ) if \"results\" in data : if len ( blocks ) == len ( data [ \"results\" ]): for idx in range ( len ( blocks )): block = blocks [ idx ] result = data [ \"results\" ][ idx ] block . refresh ( ** result ) else : log . warning ( \"Unable to refresh results; size mismatch\" ) else : log . warning ( \"Unable to refresh results; not provided\" ) return parent # https://developers.notion.com/reference/get-block-children def list ( self , parent ): \"\"\"Return all Blocks contained by the specified parent.\"\"\" parent_id = get_target_id ( parent ) blocks = EndpointIterator ( endpoint = self () . list , block_id = parent_id ) log . info ( \"Listing blocks for %s ...\" , parent_id ) return ResultSet ( exec = blocks , cls = Block )","title":"ChildrenEndpoint"},{"location":"reference/session/#notional.session.BlocksEndpoint.ChildrenEndpoint.__call__","text":"Return the underlying endpoint in the Notion SDK. Source code in notional/session.py def __call__ ( self ): \"\"\"Return the underlying endpoint in the Notion SDK.\"\"\" return self . session . client . blocks . children","title":"__call__()"},{"location":"reference/session/#notional.session.BlocksEndpoint.ChildrenEndpoint.append","text":"Add the given blocks as children of the specified parent. The blocks info will be refreshed based on returned data. Source code in notional/session.py def append ( self , parent , * blocks ): \"\"\"Add the given blocks as children of the specified parent. The blocks info will be refreshed based on returned data. \"\"\" parent_id = get_target_id ( parent ) children = [ block . to_api () for block in blocks if block is not None ] log . info ( \"Appending %d blocks to %s ...\" , len ( children ), parent_id ) data = self () . append ( block_id = parent_id , children = children ) if \"results\" in data : if len ( blocks ) == len ( data [ \"results\" ]): for idx in range ( len ( blocks )): block = blocks [ idx ] result = data [ \"results\" ][ idx ] block . refresh ( ** result ) else : log . warning ( \"Unable to refresh results; size mismatch\" ) else : log . warning ( \"Unable to refresh results; not provided\" ) return parent","title":"append()"},{"location":"reference/session/#notional.session.BlocksEndpoint.ChildrenEndpoint.list","text":"Return all Blocks contained by the specified parent. Source code in notional/session.py def list ( self , parent ): \"\"\"Return all Blocks contained by the specified parent.\"\"\" parent_id = get_target_id ( parent ) blocks = EndpointIterator ( endpoint = self () . list , block_id = parent_id ) log . info ( \"Listing blocks for %s ...\" , parent_id ) return ResultSet ( exec = blocks , cls = Block )","title":"list()"},{"location":"reference/session/#notional.session.BlocksEndpoint.__call__","text":"Return the underlying endpoint in the Notion SDK. Source code in notional/session.py def __call__ ( self ): \"\"\"Return the underlying endpoint in the Notion SDK.\"\"\" return self . session . client . blocks","title":"__call__()"},{"location":"reference/session/#notional.session.BlocksEndpoint.__init__","text":"Initialize the blocks endpoint for the Notion API. Source code in notional/session.py def __init__ ( self , * args , ** kwargs ): \"\"\"Initialize the `blocks` endpoint for the Notion API.\"\"\" super () . __init__ ( * args , ** kwargs ) self . children = BlocksEndpoint . ChildrenEndpoint ( * args , ** kwargs )","title":"__init__()"},{"location":"reference/session/#notional.session.BlocksEndpoint.delete","text":"Delete (archive) the specified Block. Source code in notional/session.py def delete ( self , block ): \"\"\"Delete (archive) the specified Block.\"\"\" log . info ( \"Deleting block :: %s \" , block . id ) data = self () . delete ( block . id . hex ) return block . refresh ( ** data )","title":"delete()"},{"location":"reference/session/#notional.session.BlocksEndpoint.restore","text":"Restore (unarchive) the specified Block. Source code in notional/session.py def restore ( self , block ): \"\"\"Restore (unarchive) the specified Block.\"\"\" log . info ( \"Restoring block :: %s \" , block . id ) data = self () . update ( block . id . hex , archived = False ) return block . refresh ( ** data )","title":"restore()"},{"location":"reference/session/#notional.session.BlocksEndpoint.retrieve","text":"Return the Block with the given ID. Source code in notional/session.py def retrieve ( self , block_id ): \"\"\"Return the Block with the given ID.\"\"\" log . info ( \"Retrieving block :: %s \" , block_id ) data = self () . retrieve ( block_id ) return Block . parse_obj ( data )","title":"retrieve()"},{"location":"reference/session/#notional.session.BlocksEndpoint.update","text":"Update the block content on the server. The block info will be refreshed to the latest version from the server. Source code in notional/session.py def update ( self , block ): \"\"\"Update the block content on the server. The block info will be refreshed to the latest version from the server. \"\"\" log . info ( \"Updating block :: %s \" , block . id ) data = self () . update ( block . id . hex , ** block . to_api ()) return block . refresh ( ** data )","title":"update()"},{"location":"reference/session/#notional.session.DatabasesEndpoint","text":"Notional interface to the API 'databases' endpoint. Source code in notional/session.py class DatabasesEndpoint ( Endpoint ): \"\"\"Notional interface to the API 'databases' endpoint.\"\"\" def __call__ ( self ): \"\"\"Return the underlying endpoint in the Notion SDK.\"\"\" return self . session . client . databases def _build_request ( self , parent = None , schema = None , title = None ): \"\"\"Build a request payload from the given items. *NOTE* this method does not anticipate what the request will be used for and as such does not validate the inputs for any particular requests. \"\"\" request = {} if parent is not None : ref = ParentRef [ parent ] request [ \"parent\" ] = ref . to_api () if isinstance ( title , TextObject ): request [ \"title\" ] = [ title . to_api ()] elif isinstance ( title , list ): request [ \"title\" ] = [ prop . to_api () for prop in title if prop is not None ] elif isinstance ( title , str ): prop = TextObject [ title ] request [ \"title\" ] = [ prop . to_api ()] elif title is not None : raise ValueError ( \"Unrecognized data in 'title'\" ) if schema is not None : request [ \"properties\" ] = { name : value . to_api () if value is not None else None for name , value in schema . items () } return request # https://developers.notion.com/reference/create-a-database def create ( self , parent , schema , title = None ): \"\"\"Add a database to the given Page parent.\"\"\" log . info ( \"Creating database %s - %s \" , parent , title ) request = self . _build_request ( parent , schema , title ) data = self () . create ( ** request ) return Database . parse_obj ( data ) # https://developers.notion.com/reference/get-databases def list ( self ): \"\"\"Return an iterator for all Database objects in the integration scope.\"\"\" # DEPRECATED ENDPOINT ### log . info ( \"Listing known databases...\" ) databases = EndpointIterator ( endpoint = self () . list ) return ResultSet ( exec = databases , cls = Database ) # https://developers.notion.com/reference/retrieve-a-database def retrieve ( self , database_id ): \"\"\"Return the Database with the given ID.\"\"\" log . info ( \"Retrieving database :: %s \" , database_id ) data = self () . retrieve ( database_id ) return Database . parse_obj ( data ) # https://developers.notion.com/reference/update-a-database def update ( self , database , title = None , schema = None ): \"\"\"Update the Database object on the server. The database info will be refreshed to the latest version from the server. \"\"\" dbid = get_target_id ( database ) log . info ( \"Updating database info :: \" , dbid ) request = self . _build_request ( schema = schema , title = title ) if request : data = self () . update ( dbid , ** request ) database = database . refresh ( ** data ) return database def delete ( self , database ): \"\"\"Delete (archive) the specified Database.\"\"\" log . info ( \"Deleting database :: %s \" , database . id ) return self . session . blocks . delete ( database ) def restore ( self , database ): \"\"\"Restore (unarchive) the specified Database.\"\"\" log . info ( \"Restoring database :: %s \" , database . id ) return self . session . blocks . restore ( database ) # https://developers.notion.com/reference/post-database-query def query ( self , target ): \"\"\"Initialize a new Query object with the target data class. :param target: either a string with the database ID or an ORM class \"\"\" log . info ( \"Initializing database query :: { %s }\" , get_target_id ( target )) database_id = get_target_id ( target ) cls = None if isclass ( target ) and issubclass ( target , ConnectedPage ): cls = target if cls . _notional__session != self . session : raise ValueError ( \"ConnectedPage belongs to a different session\" ) return QueryBuilder ( endpoint = self () . query , cls = cls , database_id = database_id )","title":"DatabasesEndpoint"},{"location":"reference/session/#notional.session.DatabasesEndpoint.__call__","text":"Return the underlying endpoint in the Notion SDK. Source code in notional/session.py def __call__ ( self ): \"\"\"Return the underlying endpoint in the Notion SDK.\"\"\" return self . session . client . databases","title":"__call__()"},{"location":"reference/session/#notional.session.DatabasesEndpoint.create","text":"Add a database to the given Page parent. Source code in notional/session.py def create ( self , parent , schema , title = None ): \"\"\"Add a database to the given Page parent.\"\"\" log . info ( \"Creating database %s - %s \" , parent , title ) request = self . _build_request ( parent , schema , title ) data = self () . create ( ** request ) return Database . parse_obj ( data )","title":"create()"},{"location":"reference/session/#notional.session.DatabasesEndpoint.delete","text":"Delete (archive) the specified Database. Source code in notional/session.py def delete ( self , database ): \"\"\"Delete (archive) the specified Database.\"\"\" log . info ( \"Deleting database :: %s \" , database . id ) return self . session . blocks . delete ( database )","title":"delete()"},{"location":"reference/session/#notional.session.DatabasesEndpoint.list","text":"Return an iterator for all Database objects in the integration scope. Source code in notional/session.py def list ( self ): \"\"\"Return an iterator for all Database objects in the integration scope.\"\"\" # DEPRECATED ENDPOINT ### log . info ( \"Listing known databases...\" ) databases = EndpointIterator ( endpoint = self () . list ) return ResultSet ( exec = databases , cls = Database )","title":"list()"},{"location":"reference/session/#notional.session.DatabasesEndpoint.query","text":"Initialize a new Query object with the target data class. :param target: either a string with the database ID or an ORM class Source code in notional/session.py def query ( self , target ): \"\"\"Initialize a new Query object with the target data class. :param target: either a string with the database ID or an ORM class \"\"\" log . info ( \"Initializing database query :: { %s }\" , get_target_id ( target )) database_id = get_target_id ( target ) cls = None if isclass ( target ) and issubclass ( target , ConnectedPage ): cls = target if cls . _notional__session != self . session : raise ValueError ( \"ConnectedPage belongs to a different session\" ) return QueryBuilder ( endpoint = self () . query , cls = cls , database_id = database_id )","title":"query()"},{"location":"reference/session/#notional.session.DatabasesEndpoint.restore","text":"Restore (unarchive) the specified Database. Source code in notional/session.py def restore ( self , database ): \"\"\"Restore (unarchive) the specified Database.\"\"\" log . info ( \"Restoring database :: %s \" , database . id ) return self . session . blocks . restore ( database )","title":"restore()"},{"location":"reference/session/#notional.session.DatabasesEndpoint.retrieve","text":"Return the Database with the given ID. Source code in notional/session.py def retrieve ( self , database_id ): \"\"\"Return the Database with the given ID.\"\"\" log . info ( \"Retrieving database :: %s \" , database_id ) data = self () . retrieve ( database_id ) return Database . parse_obj ( data )","title":"retrieve()"},{"location":"reference/session/#notional.session.DatabasesEndpoint.update","text":"Update the Database object on the server. The database info will be refreshed to the latest version from the server. Source code in notional/session.py def update ( self , database , title = None , schema = None ): \"\"\"Update the Database object on the server. The database info will be refreshed to the latest version from the server. \"\"\" dbid = get_target_id ( database ) log . info ( \"Updating database info :: \" , dbid ) request = self . _build_request ( schema = schema , title = title ) if request : data = self () . update ( dbid , ** request ) database = database . refresh ( ** data ) return database","title":"update()"},{"location":"reference/session/#notional.session.Endpoint","text":"Notional wrapper for the API endpoints. Source code in notional/session.py class Endpoint ( object ): \"\"\"Notional wrapper for the API endpoints.\"\"\" def __init__ ( self , session ): \"\"\"Initialize the `Endpoint` for the supplied session.\"\"\" self . session = session","title":"Endpoint"},{"location":"reference/session/#notional.session.Endpoint.__init__","text":"Initialize the Endpoint for the supplied session. Source code in notional/session.py def __init__ ( self , session ): \"\"\"Initialize the `Endpoint` for the supplied session.\"\"\" self . session = session","title":"__init__()"},{"location":"reference/session/#notional.session.PagesEndpoint","text":"Notional interface to the API 'pages' endpoint. Source code in notional/session.py class PagesEndpoint ( Endpoint ): \"\"\"Notional interface to the API 'pages' endpoint.\"\"\" def __call__ ( self ): \"\"\"Return the underlying endpoint in the Notion SDK.\"\"\" return self . session . client . pages # https://developers.notion.com/reference/post-page def create ( self , parent , title = None , properties = None , children = None ): \"\"\"Add a page to the given parent (Page or Database).\"\"\" if parent is None : raise ValueError ( \"'parent' must be provided\" ) parent = ParentRef [ parent ] request = { \"parent\" : parent . to_api ()} # the API requires a properties object, even if empty if properties is None : properties = {} if title is not None : properties [ \"title\" ] = Title [ title ] request [ \"properties\" ] = { name : prop . to_api () if prop is not None else None for name , prop in properties . items () } if children is not None : request [ \"children\" ] = [ child . to_api () for child in children if child is not None ] log . info ( \"Creating page :: %s => %s \" , parent , title ) data = self () . create ( ** request ) return Page . parse_obj ( data ) def delete ( self , page ): \"\"\"Delete (archive) the specified Page.\"\"\" return self . set ( page , archived = True ) def restore ( self , page ): \"\"\"Restore (unarchive) the specified Page.\"\"\" return self . set ( page , archived = False ) # https://developers.notion.com/reference/retrieve-a-page def retrieve ( self , page_id ): \"\"\"Return the Page with the given ID.\"\"\" log . info ( \"Retrieving page :: %s \" , page_id ) data = self () . retrieve ( page_id ) return Page . parse_obj ( data ) # https://developers.notion.com/reference/patch-page def update ( self , page , ** properties ): \"\"\"Update the Page object properties on the server. If `properties` are provided, only those values will be updated. If `properties` is empty, all page properties will be updated. `properties` are specified as `\"name\"`: `PropertyValue` pairs. The page info will be refreshed to the latest version from the server. \"\"\" log . info ( \"Updating page info :: %s \" , page . id ) if not properties : properties = page . properties props = { name : value . to_api () if value is not None else None for name , value in properties . items () } data = self () . update ( page . id . hex , properties = props ) return page . refresh ( ** data ) def set ( self , page , cover = False , icon = False , archived = None ): \"\"\"Set specific page attributes (such as cover, icon, etc) on the server. To remove an attribute, set its value to None. \"\"\" if cover is None : log . info ( \"Removing page cover :: %s \" , page . id ) data = self () . update ( page . id . hex , cover = {}) elif cover is not False : log . info ( \"Setting page cover :: %s => %s \" , page . id , cover ) data = self () . update ( page . id . hex , cover = cover . to_api ()) if icon is None : log . info ( \"Removing page icon :: %s \" , page . id ) data = self () . update ( page . id . hex , icon = {}) elif icon is not False : log . info ( \"Setting page icon :: %s => %s \" , page . id , icon ) data = self () . update ( page . id . hex , icon = icon . to_api ()) if archived is False : log . info ( \"Restoring page :: %s \" , page . id ) data = self () . update ( page . id . hex , archived = False ) elif archived is True : log . info ( \"Archiving page :: %s \" , page . id ) data = self () . update ( page . id . hex , archived = True ) return page . refresh ( ** data )","title":"PagesEndpoint"},{"location":"reference/session/#notional.session.PagesEndpoint.__call__","text":"Return the underlying endpoint in the Notion SDK. Source code in notional/session.py def __call__ ( self ): \"\"\"Return the underlying endpoint in the Notion SDK.\"\"\" return self . session . client . pages","title":"__call__()"},{"location":"reference/session/#notional.session.PagesEndpoint.create","text":"Add a page to the given parent (Page or Database). Source code in notional/session.py def create ( self , parent , title = None , properties = None , children = None ): \"\"\"Add a page to the given parent (Page or Database).\"\"\" if parent is None : raise ValueError ( \"'parent' must be provided\" ) parent = ParentRef [ parent ] request = { \"parent\" : parent . to_api ()} # the API requires a properties object, even if empty if properties is None : properties = {} if title is not None : properties [ \"title\" ] = Title [ title ] request [ \"properties\" ] = { name : prop . to_api () if prop is not None else None for name , prop in properties . items () } if children is not None : request [ \"children\" ] = [ child . to_api () for child in children if child is not None ] log . info ( \"Creating page :: %s => %s \" , parent , title ) data = self () . create ( ** request ) return Page . parse_obj ( data )","title":"create()"},{"location":"reference/session/#notional.session.PagesEndpoint.delete","text":"Delete (archive) the specified Page. Source code in notional/session.py def delete ( self , page ): \"\"\"Delete (archive) the specified Page.\"\"\" return self . set ( page , archived = True )","title":"delete()"},{"location":"reference/session/#notional.session.PagesEndpoint.restore","text":"Restore (unarchive) the specified Page. Source code in notional/session.py def restore ( self , page ): \"\"\"Restore (unarchive) the specified Page.\"\"\" return self . set ( page , archived = False )","title":"restore()"},{"location":"reference/session/#notional.session.PagesEndpoint.retrieve","text":"Return the Page with the given ID. Source code in notional/session.py def retrieve ( self , page_id ): \"\"\"Return the Page with the given ID.\"\"\" log . info ( \"Retrieving page :: %s \" , page_id ) data = self () . retrieve ( page_id ) return Page . parse_obj ( data )","title":"retrieve()"},{"location":"reference/session/#notional.session.PagesEndpoint.set","text":"Set specific page attributes (such as cover, icon, etc) on the server. To remove an attribute, set its value to None. Source code in notional/session.py def set ( self , page , cover = False , icon = False , archived = None ): \"\"\"Set specific page attributes (such as cover, icon, etc) on the server. To remove an attribute, set its value to None. \"\"\" if cover is None : log . info ( \"Removing page cover :: %s \" , page . id ) data = self () . update ( page . id . hex , cover = {}) elif cover is not False : log . info ( \"Setting page cover :: %s => %s \" , page . id , cover ) data = self () . update ( page . id . hex , cover = cover . to_api ()) if icon is None : log . info ( \"Removing page icon :: %s \" , page . id ) data = self () . update ( page . id . hex , icon = {}) elif icon is not False : log . info ( \"Setting page icon :: %s => %s \" , page . id , icon ) data = self () . update ( page . id . hex , icon = icon . to_api ()) if archived is False : log . info ( \"Restoring page :: %s \" , page . id ) data = self () . update ( page . id . hex , archived = False ) elif archived is True : log . info ( \"Archiving page :: %s \" , page . id ) data = self () . update ( page . id . hex , archived = True ) return page . refresh ( ** data )","title":"set()"},{"location":"reference/session/#notional.session.PagesEndpoint.update","text":"Update the Page object properties on the server. If properties are provided, only those values will be updated. If properties is empty, all page properties will be updated. properties are specified as \"name\" : PropertyValue pairs. The page info will be refreshed to the latest version from the server. Source code in notional/session.py def update ( self , page , ** properties ): \"\"\"Update the Page object properties on the server. If `properties` are provided, only those values will be updated. If `properties` is empty, all page properties will be updated. `properties` are specified as `\"name\"`: `PropertyValue` pairs. The page info will be refreshed to the latest version from the server. \"\"\" log . info ( \"Updating page info :: %s \" , page . id ) if not properties : properties = page . properties props = { name : value . to_api () if value is not None else None for name , value in properties . items () } data = self () . update ( page . id . hex , properties = props ) return page . refresh ( ** data )","title":"update()"},{"location":"reference/session/#notional.session.SearchEndpoint","text":"Notional interface to the API 'search' endpoint. Source code in notional/session.py class SearchEndpoint ( Endpoint ): \"\"\"Notional interface to the API 'search' endpoint.\"\"\" # https://developers.notion.com/reference/post-search def __call__ ( self , text = None ): \"\"\"Perform a search with the optional text. If specified, the call will perform a search with the given text. :return: a `QueryBuilder` with the requested search :rtype: query.QueryBuilder \"\"\" params = {} if text is not None : params [ \"query\" ] = text return QueryBuilder ( endpoint = self . session . client . search , ** params )","title":"SearchEndpoint"},{"location":"reference/session/#notional.session.SearchEndpoint.__call__","text":"Perform a search with the optional text. If specified, the call will perform a search with the given text. :return: a QueryBuilder with the requested search :rtype: query.QueryBuilder Source code in notional/session.py def __call__ ( self , text = None ): \"\"\"Perform a search with the optional text. If specified, the call will perform a search with the given text. :return: a `QueryBuilder` with the requested search :rtype: query.QueryBuilder \"\"\" params = {} if text is not None : params [ \"query\" ] = text return QueryBuilder ( endpoint = self . session . client . search , ** params )","title":"__call__()"},{"location":"reference/session/#notional.session.Session","text":"An active session with the Notion SDK. Source code in notional/session.py class Session ( object ): \"\"\"An active session with the Notion SDK.\"\"\" def __init__ ( self , ** kwargs ): \"\"\"Initialize the `Session` object and the endpoints. `kwargs` will be passed direction to the Notion SDK Client. For more details, see the (full docs)[https://ramnes.github.io/notion-sdk-py/reference/client/]. :param auth: bearer token for authentication \"\"\" self . client = notion_client . Client ( ** kwargs ) self . blocks = BlocksEndpoint ( self ) self . databases = DatabasesEndpoint ( self ) self . pages = PagesEndpoint ( self ) self . search = SearchEndpoint ( self ) self . users = UsersEndpoint ( self ) log . info ( \"Initialized Notion SDK client\" ) @property def IsActive ( self ): \"\"\"Determine if the current session is active. The session is considered \"active\" if it has not been closed. This does not determine if the session can connect to the Notion API. \"\"\" return self . client is not None def close ( self ): \"\"\"Close the session and release resources.\"\"\" if self . client is None : raise SessionError ( \"Session is not active.\" ) self . client . close () self . client = None def ping ( self ): \"\"\"Confirm that the session is active and able to connect to Notion. Raises SessionError if there is a problem, otherwise returns True. \"\"\" if self . IsActive is False : return False error = None try : me = self . users . me () if me is None : raise SessionError ( \"Unable to get current user\" ) except ConnectError : error = \"Unable to connect to Notion\" except APIResponseError as err : error = str ( err ) if error is not None : raise SessionError ( error ) return True","title":"Session"},{"location":"reference/session/#notional.session.Session.IsActive","text":"Determine if the current session is active. The session is considered \"active\" if it has not been closed. This does not determine if the session can connect to the Notion API.","title":"IsActive"},{"location":"reference/session/#notional.session.Session.__init__","text":"Initialize the Session object and the endpoints. kwargs will be passed direction to the Notion SDK Client. For more details, see the (full docs)[https://ramnes.github.io/notion-sdk-py/reference/client/]. :param auth: bearer token for authentication Source code in notional/session.py def __init__ ( self , ** kwargs ): \"\"\"Initialize the `Session` object and the endpoints. `kwargs` will be passed direction to the Notion SDK Client. For more details, see the (full docs)[https://ramnes.github.io/notion-sdk-py/reference/client/]. :param auth: bearer token for authentication \"\"\" self . client = notion_client . Client ( ** kwargs ) self . blocks = BlocksEndpoint ( self ) self . databases = DatabasesEndpoint ( self ) self . pages = PagesEndpoint ( self ) self . search = SearchEndpoint ( self ) self . users = UsersEndpoint ( self ) log . info ( \"Initialized Notion SDK client\" )","title":"__init__()"},{"location":"reference/session/#notional.session.Session.close","text":"Close the session and release resources. Source code in notional/session.py def close ( self ): \"\"\"Close the session and release resources.\"\"\" if self . client is None : raise SessionError ( \"Session is not active.\" ) self . client . close () self . client = None","title":"close()"},{"location":"reference/session/#notional.session.Session.ping","text":"Confirm that the session is active and able to connect to Notion. Raises SessionError if there is a problem, otherwise returns True. Source code in notional/session.py def ping ( self ): \"\"\"Confirm that the session is active and able to connect to Notion. Raises SessionError if there is a problem, otherwise returns True. \"\"\" if self . IsActive is False : return False error = None try : me = self . users . me () if me is None : raise SessionError ( \"Unable to get current user\" ) except ConnectError : error = \"Unable to connect to Notion\" except APIResponseError as err : error = str ( err ) if error is not None : raise SessionError ( error ) return True","title":"ping()"},{"location":"reference/session/#notional.session.SessionError","text":"Raised when there are issues with the Notion session. Source code in notional/session.py class SessionError ( Exception ): \"\"\"Raised when there are issues with the Notion session.\"\"\" def __init__ ( self , message ): \"\"\"Initialize the `SessionError` with a supplied message..\"\"\" super () . __init__ ( message )","title":"SessionError"},{"location":"reference/session/#notional.session.SessionError.__init__","text":"Initialize the SessionError with a supplied message.. Source code in notional/session.py def __init__ ( self , message ): \"\"\"Initialize the `SessionError` with a supplied message..\"\"\" super () . __init__ ( message )","title":"__init__()"},{"location":"reference/session/#notional.session.UsersEndpoint","text":"Notional interface to the API 'users' endpoint. Source code in notional/session.py class UsersEndpoint ( Endpoint ): \"\"\"Notional interface to the API 'users' endpoint.\"\"\" def __call__ ( self ): \"\"\"Return the underlying endpoint in the Notion SDK.\"\"\" return self . session . client . users # https://developers.notion.com/reference/get-users def list ( self ): \"\"\"Return an iterator for all users in the workspace.\"\"\" users = EndpointIterator ( endpoint = self () . list ) log . info ( \"Listing known users...\" ) return ResultSet ( exec = users , cls = User ) # https://developers.notion.com/reference/get-user def retrieve ( self , user_id ): \"\"\"Return the User with the given ID.\"\"\" log . info ( \"Retrieving user :: %s \" , user_id ) data = self () . retrieve ( user_id ) return User . parse_obj ( data ) # https://developers.notion.com/reference/get-self def me ( self ): \"\"\"Return the current bot User.\"\"\" log . info ( \"Retrieving current integration bot\" ) data = self () . me () return User . parse_obj ( data )","title":"UsersEndpoint"},{"location":"reference/session/#notional.session.UsersEndpoint.__call__","text":"Return the underlying endpoint in the Notion SDK. Source code in notional/session.py def __call__ ( self ): \"\"\"Return the underlying endpoint in the Notion SDK.\"\"\" return self . session . client . users","title":"__call__()"},{"location":"reference/session/#notional.session.UsersEndpoint.list","text":"Return an iterator for all users in the workspace. Source code in notional/session.py def list ( self ): \"\"\"Return an iterator for all users in the workspace.\"\"\" users = EndpointIterator ( endpoint = self () . list ) log . info ( \"Listing known users...\" ) return ResultSet ( exec = users , cls = User )","title":"list()"},{"location":"reference/session/#notional.session.UsersEndpoint.me","text":"Return the current bot User. Source code in notional/session.py def me ( self ): \"\"\"Return the current bot User.\"\"\" log . info ( \"Retrieving current integration bot\" ) data = self () . me () return User . parse_obj ( data )","title":"me()"},{"location":"reference/session/#notional.session.UsersEndpoint.retrieve","text":"Return the User with the given ID. Source code in notional/session.py def retrieve ( self , user_id ): \"\"\"Return the User with the given ID.\"\"\" log . info ( \"Retrieving user :: %s \" , user_id ) data = self () . retrieve ( user_id ) return User . parse_obj ( data )","title":"retrieve()"},{"location":"reference/text/","text":"Utilities for working text, markdown & Rich Text in Notion. Annotations ( DataObject ) pydantic-model Style information for RichTextObject's. Source code in notional/text.py class Annotations ( DataObject ): \"\"\"Style information for RichTextObject's.\"\"\" bold : bool = False italic : bool = False strikethrough : bool = False underline : bool = False code : bool = False color : FullColor = None @property def is_plain ( self ): \"\"\"Determine if any flags are set in this `Annotations` object. If all flags match their defaults, this is considered a \"plain\" style. \"\"\" # XXX a better approach here would be to just compate all fields to defaults if self . bold : return False if self . italic : return False if self . strikethrough : return False if self . underline : return False if self . code : return False if self . color is not None : return False return True is_plain property readonly Determine if any flags are set in this Annotations object. If all flags match their defaults, this is considered a \"plain\" style. CodingLanguage ( str , Enum ) Available coding languages. Source code in notional/text.py class CodingLanguage ( str , Enum ): \"\"\"Available coding languages.\"\"\" ABAP = \"abap\" ARDUION = \"arduino\" BASH = \"bash\" BASIC = \"basic\" C = \"c\" CLOJURE = \"clojure\" COFFEESCRIPT = \"coffeescript\" CPP = \"c++\" CSHARP = \"c#\" CSS = \"css\" DART = \"dart\" DIFF = \"diff\" DOCKER = \"docker\" ELIXIR = \"elixir\" ELM = \"elm\" ERLANG = \"erlang\" FLOW = \"flow\" FORTRAN = \"fortran\" FSHARP = \"f#\" GHERKIN = \"gherkin\" GLSL = \"glsl\" GO = \"go\" GRAPHQL = \"graphql\" GROOVY = \"groovy\" HASKELL = \"haskell\" HTML = \"html\" JAVA = \"java\" JAVASCRIPT = \"javascript\" JSON = \"json\" JULIA = \"julia\" KOTLIN = \"kotlin\" LATEX = \"latex\" LESS = \"less\" LISP = \"lisp\" LIVESCRIPT = \"livescript\" LUA = \"lua\" MAKEFILE = \"makefile\" MARKDOWN = \"markdown\" MARKUP = \"markup\" MATLAB = \"matlab\" MERMAID = \"mermaid\" NIX = \"nix\" OBJECTIVE_C = \"objective-c\" OCAML = \"ocaml\" PASCAL = \"pascal\" PERL = \"perl\" PHP = \"php\" PLAIN_TEXT = \"plain text\" POWERSHELL = \"powershell\" PROLOG = \"prolog\" PROTOBUF = \"protobuf\" PYTHON = \"python\" R = \"r\" REASON = \"reason\" RUBY = \"ruby\" RUST = \"rust\" SASS = \"sass\" SCALA = \"scala\" SCHEME = \"scheme\" SCSS = \"scss\" SHELL = \"shell\" SQL = \"sql\" SWIFT = \"swift\" TYPESCRIPT = \"typescript\" VB_NET = \"vb.net\" VERILOG = \"verilog\" VHDL = \"vhdl\" VISUAL_BASIC = \"visual basic\" WEBASSEMBLY = \"webassembly\" XML = \"xml\" YAML = \"yaml\" MISC = \"java/c/c++/c#\" Color ( str , Enum ) Basic color values. Source code in notional/text.py class Color ( str , Enum ): \"\"\"Basic color values.\"\"\" DEFAULT = \"default\" GRAY = \"gray\" BROWN = \"brown\" ORANGE = \"orange\" YELLOW = \"yellow\" GREEN = \"green\" BLUE = \"blue\" PURPLE = \"purple\" PINK = \"pink\" RED = \"red\" FullColor ( str , Enum ) Extended color values, including backgounds. Source code in notional/text.py class FullColor ( str , Enum ): \"\"\"Extended color values, including backgounds.\"\"\" DEFAULT = \"default\" GRAY = \"gray\" BROWN = \"brown\" ORANGE = \"orange\" YELLOW = \"yellow\" GREEN = \"green\" BLUE = \"blue\" PURPLE = \"purple\" PINK = \"pink\" RED = \"red\" GRAY_BACKGROUND = \"gray_background\" BROWN_BACKGROUND = \"brown_background\" ORANGE_BACKGROUND = \"orange_background\" YELLOW_BACKGROUND = \"yellow_background\" GREEN_BACKGROUND = \"green_background\" BLUE_BACKGROUND = \"blue_background\" PURPLE_BACKGROUND = \"purple_background\" PINK_BACKGROUND = \"pink_background\" RED_BACKGROUND = \"red_background\" LinkObject ( DataObject ) pydantic-model Reference a URL. Source code in notional/text.py class LinkObject ( DataObject ): \"\"\"Reference a URL.\"\"\" type : str = \"url\" url : str = None RichTextObject ( TypedObject ) pydantic-model Base class for Notion rich text elements. Source code in notional/text.py class RichTextObject ( TypedObject ): \"\"\"Base class for Notion rich text elements.\"\"\" plain_text : str href : Optional [ str ] = None annotations : Optional [ Annotations ] = None def __str__ ( self ): \"\"\"Return a string representation of this object.\"\"\" if self . href is None : text = self . plain_text or \"\" elif self . plain_text is None or len ( self . plain_text ) == 0 : text = f \"( { self . href } )\" else : text = f \"[ { self . plain_text } ]( { self . href } )\" if self . annotations : if self . annotations . bold : text = f \"* { text } *\" if self . annotations . italic : text = f \"** { text } **\" if self . annotations . underline : text = f \"_ { text } _\" if self . annotations . strikethrough : text = f \"~ { text } ~\" if self . annotations . code : text = f \"` { text } `\" return text __str__ ( self ) special Return a string representation of this object. Source code in notional/text.py def __str__ ( self ): \"\"\"Return a string representation of this object.\"\"\" if self . href is None : text = self . plain_text or \"\" elif self . plain_text is None or len ( self . plain_text ) == 0 : text = f \"( { self . href } )\" else : text = f \"[ { self . plain_text } ]( { self . href } )\" if self . annotations : if self . annotations . bold : text = f \"* { text } *\" if self . annotations . italic : text = f \"** { text } **\" if self . annotations . underline : text = f \"_ { text } _\" if self . annotations . strikethrough : text = f \"~ { text } ~\" if self . annotations . code : text = f \"` { text } `\" return text TextObject ( RichTextObject ) pydantic-model Notion text element. Source code in notional/text.py class TextObject ( RichTextObject , type = \"text\" ): \"\"\"Notion text element.\"\"\" class _NestedData ( NestedObject ): content : str = None link : Optional [ LinkObject ] = None text : _NestedData = _NestedData () @classmethod def __compose__ ( cls , text , href = None , style = None ): \"\"\"Compose a TextObject from the given properties. :param text: the plain text of this object :param href: an optional link for this object :param style: an optional Annotations object for this text \"\"\" if text is None : return None # TODO convert markdown in text:str to RichText? link = LinkObject ( url = href ) if href else None nested = TextObject . _NestedData ( content = text , link = link ) style = deepcopy ( style ) return TextObject ( plain_text = text , text = nested , href = href , annotations = style , ) __compose__ ( text , href = None , style = None ) classmethod special Compose a TextObject from the given properties. :param text: the plain text of this object :param href: an optional link for this object :param style: an optional Annotations object for this text Source code in notional/text.py @classmethod def __compose__ ( cls , text , href = None , style = None ): \"\"\"Compose a TextObject from the given properties. :param text: the plain text of this object :param href: an optional link for this object :param style: an optional Annotations object for this text \"\"\" if text is None : return None # TODO convert markdown in text:str to RichText? link = LinkObject ( url = href ) if href else None nested = TextObject . _NestedData ( content = text , link = link ) style = deepcopy ( style ) return TextObject ( plain_text = text , text = nested , href = href , annotations = style , ) chunky ( text , length = 2000 ) Break the given text into chunks of at most length size. Source code in notional/text.py def chunky ( text , length = MAX_TEXT_OBJECT_SIZE ): \"\"\"Break the given `text` into chunks of at most `length` size.\"\"\" return ( text [ idx : idx + length ] for idx in range ( 0 , len ( text ), length )) lstrip ( * rtf ) Remove leading whitespace from each TextObject in the list. Source code in notional/text.py def lstrip ( * rtf ): \"\"\"Remove leading whitespace from each `TextObject` in the list.\"\"\" if rtf is None or len ( rtf ) < 1 : return for obj in rtf : if not isinstance ( obj , TextObject ): raise AttributeError ( \"invalid object in rtf\" ) if obj . text and obj . text . content : strip_text = obj . text . content . lstrip () obj . text . content = strip_text obj . plain_text = strip_text make_safe_python_name ( name ) Make the given string safe for use as a Python identifier. This will remove any leading characters that are not valid and change all invalid interior sequences to underscore. Source code in notional/text.py def make_safe_python_name ( name ): \"\"\"Make the given string safe for use as a Python identifier. This will remove any leading characters that are not valid and change all invalid interior sequences to underscore. \"\"\" s = re . sub ( r \"[^0-9a-zA-Z_]+\" , \"_\" , name ) s = re . sub ( r \"^[^a-zA-Z]+\" , \"\" , s ) # remove trailing underscores return s . rstrip ( \"_\" ) markdown ( * rtf ) Return text as markdown from the list of RichText objects. Source code in notional/text.py def markdown ( * rtf ): \"\"\"Return text as markdown from the list of RichText objects.\"\"\" return \"\" . join ( str ( text ) for text in rtf if text ) plain_text ( * rtf ) Return the combined plain text from the list of RichText objects. Source code in notional/text.py def plain_text ( * rtf ): \"\"\"Return the combined plain text from the list of RichText objects.\"\"\" return \"\" . join ( text . plain_text for text in rtf if text ) rstrip ( * rtf ) Remove trailing whitespace from each TextObject in the list. Source code in notional/text.py def rstrip ( * rtf ): \"\"\"Remove trailing whitespace from each `TextObject` in the list.\"\"\" if rtf is None or len ( rtf ) < 1 : return for obj in rtf : if not isinstance ( obj , TextObject ): raise AttributeError ( \"invalid object in rtf\" ) if obj . text and obj . text . content : strip_text = obj . text . content . rstrip () obj . text . content = strip_text obj . plain_text = strip_text strip ( * rtf ) Remove leading and trailing whitespace from each TextObject in the list. This is functionally equivalent to: lstrip ( * rtf ) rstrip ( * rtf ) :param rtf: a list of TextObject 's Source code in notional/text.py def strip ( * rtf ): \"\"\"Remove leading and trailing whitespace from each `TextObject` in the list. This is functionally equivalent to: ```python lstrip(*rtf) rstrip(*rtf) ``` :param rtf: a list of `TextObject`'s \"\"\" lstrip ( * rtf ) rstrip ( * rtf ) truncate ( text , length =- 1 , trail = '...' ) Truncate the given text, using a supplied tail as a placeholder. Source code in notional/text.py def truncate ( text , length =- 1 , trail = \"...\" ): \"\"\"Truncate the given text, using a supplied tail as a placeholder.\"\"\" if text is None : return None # repr() includes open and close quotes... literal = repr ( text )[ 1 : - 1 ] if 0 < length < len ( literal ): literal = literal [: length ] if trail is not None : literal += trail return literal","title":"Text"},{"location":"reference/text/#notional.text.Annotations","text":"Style information for RichTextObject's. Source code in notional/text.py class Annotations ( DataObject ): \"\"\"Style information for RichTextObject's.\"\"\" bold : bool = False italic : bool = False strikethrough : bool = False underline : bool = False code : bool = False color : FullColor = None @property def is_plain ( self ): \"\"\"Determine if any flags are set in this `Annotations` object. If all flags match their defaults, this is considered a \"plain\" style. \"\"\" # XXX a better approach here would be to just compate all fields to defaults if self . bold : return False if self . italic : return False if self . strikethrough : return False if self . underline : return False if self . code : return False if self . color is not None : return False return True","title":"Annotations"},{"location":"reference/text/#notional.text.Annotations.is_plain","text":"Determine if any flags are set in this Annotations object. If all flags match their defaults, this is considered a \"plain\" style.","title":"is_plain"},{"location":"reference/text/#notional.text.CodingLanguage","text":"Available coding languages. Source code in notional/text.py class CodingLanguage ( str , Enum ): \"\"\"Available coding languages.\"\"\" ABAP = \"abap\" ARDUION = \"arduino\" BASH = \"bash\" BASIC = \"basic\" C = \"c\" CLOJURE = \"clojure\" COFFEESCRIPT = \"coffeescript\" CPP = \"c++\" CSHARP = \"c#\" CSS = \"css\" DART = \"dart\" DIFF = \"diff\" DOCKER = \"docker\" ELIXIR = \"elixir\" ELM = \"elm\" ERLANG = \"erlang\" FLOW = \"flow\" FORTRAN = \"fortran\" FSHARP = \"f#\" GHERKIN = \"gherkin\" GLSL = \"glsl\" GO = \"go\" GRAPHQL = \"graphql\" GROOVY = \"groovy\" HASKELL = \"haskell\" HTML = \"html\" JAVA = \"java\" JAVASCRIPT = \"javascript\" JSON = \"json\" JULIA = \"julia\" KOTLIN = \"kotlin\" LATEX = \"latex\" LESS = \"less\" LISP = \"lisp\" LIVESCRIPT = \"livescript\" LUA = \"lua\" MAKEFILE = \"makefile\" MARKDOWN = \"markdown\" MARKUP = \"markup\" MATLAB = \"matlab\" MERMAID = \"mermaid\" NIX = \"nix\" OBJECTIVE_C = \"objective-c\" OCAML = \"ocaml\" PASCAL = \"pascal\" PERL = \"perl\" PHP = \"php\" PLAIN_TEXT = \"plain text\" POWERSHELL = \"powershell\" PROLOG = \"prolog\" PROTOBUF = \"protobuf\" PYTHON = \"python\" R = \"r\" REASON = \"reason\" RUBY = \"ruby\" RUST = \"rust\" SASS = \"sass\" SCALA = \"scala\" SCHEME = \"scheme\" SCSS = \"scss\" SHELL = \"shell\" SQL = \"sql\" SWIFT = \"swift\" TYPESCRIPT = \"typescript\" VB_NET = \"vb.net\" VERILOG = \"verilog\" VHDL = \"vhdl\" VISUAL_BASIC = \"visual basic\" WEBASSEMBLY = \"webassembly\" XML = \"xml\" YAML = \"yaml\" MISC = \"java/c/c++/c#\"","title":"CodingLanguage"},{"location":"reference/text/#notional.text.Color","text":"Basic color values. Source code in notional/text.py class Color ( str , Enum ): \"\"\"Basic color values.\"\"\" DEFAULT = \"default\" GRAY = \"gray\" BROWN = \"brown\" ORANGE = \"orange\" YELLOW = \"yellow\" GREEN = \"green\" BLUE = \"blue\" PURPLE = \"purple\" PINK = \"pink\" RED = \"red\"","title":"Color"},{"location":"reference/text/#notional.text.FullColor","text":"Extended color values, including backgounds. Source code in notional/text.py class FullColor ( str , Enum ): \"\"\"Extended color values, including backgounds.\"\"\" DEFAULT = \"default\" GRAY = \"gray\" BROWN = \"brown\" ORANGE = \"orange\" YELLOW = \"yellow\" GREEN = \"green\" BLUE = \"blue\" PURPLE = \"purple\" PINK = \"pink\" RED = \"red\" GRAY_BACKGROUND = \"gray_background\" BROWN_BACKGROUND = \"brown_background\" ORANGE_BACKGROUND = \"orange_background\" YELLOW_BACKGROUND = \"yellow_background\" GREEN_BACKGROUND = \"green_background\" BLUE_BACKGROUND = \"blue_background\" PURPLE_BACKGROUND = \"purple_background\" PINK_BACKGROUND = \"pink_background\" RED_BACKGROUND = \"red_background\"","title":"FullColor"},{"location":"reference/text/#notional.text.LinkObject","text":"Reference a URL. Source code in notional/text.py class LinkObject ( DataObject ): \"\"\"Reference a URL.\"\"\" type : str = \"url\" url : str = None","title":"LinkObject"},{"location":"reference/text/#notional.text.RichTextObject","text":"Base class for Notion rich text elements. Source code in notional/text.py class RichTextObject ( TypedObject ): \"\"\"Base class for Notion rich text elements.\"\"\" plain_text : str href : Optional [ str ] = None annotations : Optional [ Annotations ] = None def __str__ ( self ): \"\"\"Return a string representation of this object.\"\"\" if self . href is None : text = self . plain_text or \"\" elif self . plain_text is None or len ( self . plain_text ) == 0 : text = f \"( { self . href } )\" else : text = f \"[ { self . plain_text } ]( { self . href } )\" if self . annotations : if self . annotations . bold : text = f \"* { text } *\" if self . annotations . italic : text = f \"** { text } **\" if self . annotations . underline : text = f \"_ { text } _\" if self . annotations . strikethrough : text = f \"~ { text } ~\" if self . annotations . code : text = f \"` { text } `\" return text","title":"RichTextObject"},{"location":"reference/text/#notional.text.RichTextObject.__str__","text":"Return a string representation of this object. Source code in notional/text.py def __str__ ( self ): \"\"\"Return a string representation of this object.\"\"\" if self . href is None : text = self . plain_text or \"\" elif self . plain_text is None or len ( self . plain_text ) == 0 : text = f \"( { self . href } )\" else : text = f \"[ { self . plain_text } ]( { self . href } )\" if self . annotations : if self . annotations . bold : text = f \"* { text } *\" if self . annotations . italic : text = f \"** { text } **\" if self . annotations . underline : text = f \"_ { text } _\" if self . annotations . strikethrough : text = f \"~ { text } ~\" if self . annotations . code : text = f \"` { text } `\" return text","title":"__str__()"},{"location":"reference/text/#notional.text.TextObject","text":"Notion text element. Source code in notional/text.py class TextObject ( RichTextObject , type = \"text\" ): \"\"\"Notion text element.\"\"\" class _NestedData ( NestedObject ): content : str = None link : Optional [ LinkObject ] = None text : _NestedData = _NestedData () @classmethod def __compose__ ( cls , text , href = None , style = None ): \"\"\"Compose a TextObject from the given properties. :param text: the plain text of this object :param href: an optional link for this object :param style: an optional Annotations object for this text \"\"\" if text is None : return None # TODO convert markdown in text:str to RichText? link = LinkObject ( url = href ) if href else None nested = TextObject . _NestedData ( content = text , link = link ) style = deepcopy ( style ) return TextObject ( plain_text = text , text = nested , href = href , annotations = style , )","title":"TextObject"},{"location":"reference/text/#notional.text.TextObject.__compose__","text":"Compose a TextObject from the given properties. :param text: the plain text of this object :param href: an optional link for this object :param style: an optional Annotations object for this text Source code in notional/text.py @classmethod def __compose__ ( cls , text , href = None , style = None ): \"\"\"Compose a TextObject from the given properties. :param text: the plain text of this object :param href: an optional link for this object :param style: an optional Annotations object for this text \"\"\" if text is None : return None # TODO convert markdown in text:str to RichText? link = LinkObject ( url = href ) if href else None nested = TextObject . _NestedData ( content = text , link = link ) style = deepcopy ( style ) return TextObject ( plain_text = text , text = nested , href = href , annotations = style , )","title":"__compose__()"},{"location":"reference/text/#notional.text.chunky","text":"Break the given text into chunks of at most length size. Source code in notional/text.py def chunky ( text , length = MAX_TEXT_OBJECT_SIZE ): \"\"\"Break the given `text` into chunks of at most `length` size.\"\"\" return ( text [ idx : idx + length ] for idx in range ( 0 , len ( text ), length ))","title":"chunky()"},{"location":"reference/text/#notional.text.lstrip","text":"Remove leading whitespace from each TextObject in the list. Source code in notional/text.py def lstrip ( * rtf ): \"\"\"Remove leading whitespace from each `TextObject` in the list.\"\"\" if rtf is None or len ( rtf ) < 1 : return for obj in rtf : if not isinstance ( obj , TextObject ): raise AttributeError ( \"invalid object in rtf\" ) if obj . text and obj . text . content : strip_text = obj . text . content . lstrip () obj . text . content = strip_text obj . plain_text = strip_text","title":"lstrip()"},{"location":"reference/text/#notional.text.make_safe_python_name","text":"Make the given string safe for use as a Python identifier. This will remove any leading characters that are not valid and change all invalid interior sequences to underscore. Source code in notional/text.py def make_safe_python_name ( name ): \"\"\"Make the given string safe for use as a Python identifier. This will remove any leading characters that are not valid and change all invalid interior sequences to underscore. \"\"\" s = re . sub ( r \"[^0-9a-zA-Z_]+\" , \"_\" , name ) s = re . sub ( r \"^[^a-zA-Z]+\" , \"\" , s ) # remove trailing underscores return s . rstrip ( \"_\" )","title":"make_safe_python_name()"},{"location":"reference/text/#notional.text.markdown","text":"Return text as markdown from the list of RichText objects. Source code in notional/text.py def markdown ( * rtf ): \"\"\"Return text as markdown from the list of RichText objects.\"\"\" return \"\" . join ( str ( text ) for text in rtf if text )","title":"markdown()"},{"location":"reference/text/#notional.text.plain_text","text":"Return the combined plain text from the list of RichText objects. Source code in notional/text.py def plain_text ( * rtf ): \"\"\"Return the combined plain text from the list of RichText objects.\"\"\" return \"\" . join ( text . plain_text for text in rtf if text )","title":"plain_text()"},{"location":"reference/text/#notional.text.rstrip","text":"Remove trailing whitespace from each TextObject in the list. Source code in notional/text.py def rstrip ( * rtf ): \"\"\"Remove trailing whitespace from each `TextObject` in the list.\"\"\" if rtf is None or len ( rtf ) < 1 : return for obj in rtf : if not isinstance ( obj , TextObject ): raise AttributeError ( \"invalid object in rtf\" ) if obj . text and obj . text . content : strip_text = obj . text . content . rstrip () obj . text . content = strip_text obj . plain_text = strip_text","title":"rstrip()"},{"location":"reference/text/#notional.text.strip","text":"Remove leading and trailing whitespace from each TextObject in the list. This is functionally equivalent to: lstrip ( * rtf ) rstrip ( * rtf ) :param rtf: a list of TextObject 's Source code in notional/text.py def strip ( * rtf ): \"\"\"Remove leading and trailing whitespace from each `TextObject` in the list. This is functionally equivalent to: ```python lstrip(*rtf) rstrip(*rtf) ``` :param rtf: a list of `TextObject`'s \"\"\" lstrip ( * rtf ) rstrip ( * rtf )","title":"strip()"},{"location":"reference/text/#notional.text.truncate","text":"Truncate the given text, using a supplied tail as a placeholder. Source code in notional/text.py def truncate ( text , length =- 1 , trail = \"...\" ): \"\"\"Truncate the given text, using a supplied tail as a placeholder.\"\"\" if text is None : return None # repr() includes open and close quotes... literal = repr ( text )[ 1 : - 1 ] if 0 < length < len ( literal ): literal = literal [: length ] if trail is not None : literal += trail return literal","title":"truncate()"},{"location":"reference/types/","text":"Wrapper for Notion API data types. Similar to other records, these object provide access to the primitive data structure used in the Notion API as well as higher-level methods. Checkbox ( NativeTypeMixin , PropertyValue ) pydantic-model Simple checkbox type; represented as a boolean. Source code in notional/types.py class Checkbox ( NativeTypeMixin , PropertyValue , type = \"checkbox\" ): \"\"\"Simple checkbox type; represented as a boolean.\"\"\" checkbox : Optional [ bool ] = None CreatedBy ( PropertyValue ) pydantic-model A Notion created-by property value. Source code in notional/types.py class CreatedBy ( PropertyValue , type = \"created_by\" ): \"\"\"A Notion created-by property value.\"\"\" created_by : User def __str__ ( self ): \"\"\"Return the contents of this property as a string.\"\"\" return str ( self . created_by ) __str__ ( self ) special Return the contents of this property as a string. Source code in notional/types.py def __str__ ( self ): \"\"\"Return the contents of this property as a string.\"\"\" return str ( self . created_by ) CreatedTime ( NativeTypeMixin , PropertyValue ) pydantic-model A Notion created-time property value. Source code in notional/types.py class CreatedTime ( NativeTypeMixin , PropertyValue , type = \"created_time\" ): \"\"\"A Notion created-time property value.\"\"\" created_time : datetime Date ( PropertyValue ) pydantic-model Notion complex date type - may include timestamp and/or be a date range. Source code in notional/types.py class Date ( PropertyValue , type = \"date\" ): \"\"\"Notion complex date type - may include timestamp and/or be a date range.\"\"\" date : Optional [ DateRange ] = None def __contains__ ( self , other ): \"\"\"Determine if the given date is in the range (inclusive) of this Date. Raises ValueError if the Date object is not a range - e.g. has no end date. \"\"\" if not self . IsRange : raise ValueError ( \"This date is not a range\" ) return self . Start <= other <= self . End def __str__ ( self ): \"\"\"Return a string representation of this property.\"\"\" return \"\" if self . date is None else str ( self . date ) @classmethod def __compose__ ( cls , start , end = None ): \"\"\"Create a new Date from the native values.\"\"\" return cls ( date = DateRange ( start = start , end = end )) @property def IsRange ( self ): \"\"\"Determine if this object represents a date range (versus a single date).\"\"\" if self . date is None : return False return self . date . end is not None @property def Start ( self ): \"\"\"Return the start date of this property.\"\"\" return None if self . date is None else self . date . start @property def End ( self ): \"\"\"Return the end date of this property.\"\"\" return None if self . date is None else self . date . end End property readonly Return the end date of this property. IsRange property readonly Determine if this object represents a date range (versus a single date). Start property readonly Return the start date of this property. __compose__ ( start , end = None ) classmethod special Create a new Date from the native values. Source code in notional/types.py @classmethod def __compose__ ( cls , start , end = None ): \"\"\"Create a new Date from the native values.\"\"\" return cls ( date = DateRange ( start = start , end = end )) __contains__ ( self , other ) special Determine if the given date is in the range (inclusive) of this Date. Raises ValueError if the Date object is not a range - e.g. has no end date. Source code in notional/types.py def __contains__ ( self , other ): \"\"\"Determine if the given date is in the range (inclusive) of this Date. Raises ValueError if the Date object is not a range - e.g. has no end date. \"\"\" if not self . IsRange : raise ValueError ( \"This date is not a range\" ) return self . Start <= other <= self . End __str__ ( self ) special Return a string representation of this property. Source code in notional/types.py def __str__ ( self ): \"\"\"Return a string representation of this property.\"\"\" return \"\" if self . date is None else str ( self . date ) DateFormula ( FormulaResult ) pydantic-model A Notion date formula result. Source code in notional/types.py class DateFormula ( FormulaResult , type = \"date\" ): \"\"\"A Notion date formula result.\"\"\" date : Optional [ DateRange ] = None @property def Result ( self ): \"\"\"Return the result of this DateFormula.\"\"\" return self . date Result property readonly Return the result of this DateFormula. DateRange ( DataObject ) pydantic-model A Notion date range, with an optional end date. Source code in notional/types.py class DateRange ( DataObject ): \"\"\"A Notion date range, with an optional end date.\"\"\" start : Union [ date , datetime ] end : Optional [ Union [ date , datetime ]] = None def __str__ ( self ): \"\"\"Return a string representation of this object.\"\"\" if self . end is None : return f \" { self . start } \" return f \" { self . start } :: { self . end } \" __str__ ( self ) special Return a string representation of this object. Source code in notional/types.py def __str__ ( self ): \"\"\"Return a string representation of this object.\"\"\" if self . end is None : return f \" { self . start } \" return f \" { self . start } :: { self . end } \" Email ( NativeTypeMixin , PropertyValue ) pydantic-model Notion email type. Source code in notional/types.py class Email ( NativeTypeMixin , PropertyValue , type = \"email\" ): \"\"\"Notion email type.\"\"\" email : Optional [ str ] = None EmojiObject ( TypedObject ) pydantic-model A Notion emoji object. Source code in notional/types.py class EmojiObject ( TypedObject , type = \"emoji\" ): \"\"\"A Notion emoji object.\"\"\" emoji : str def __str__ ( self ): \"\"\"Return this EmojiObject as a simple string.\"\"\" return self . emoji @classmethod def __compose__ ( cls , emoji ): \"\"\"Compose an EmojiObject from the given emjoi string.\"\"\" return EmojiObject ( emoji = emoji ) __compose__ ( emoji ) classmethod special Compose an EmojiObject from the given emjoi string. Source code in notional/types.py @classmethod def __compose__ ( cls , emoji ): \"\"\"Compose an EmojiObject from the given emjoi string.\"\"\" return EmojiObject ( emoji = emoji ) __str__ ( self ) special Return this EmojiObject as a simple string. Source code in notional/types.py def __str__ ( self ): \"\"\"Return this EmojiObject as a simple string.\"\"\" return self . emoji EquationObject ( RichTextObject ) pydantic-model Notion equation element. Source code in notional/types.py class EquationObject ( RichTextObject , type = \"equation\" ): \"\"\"Notion equation element.\"\"\" class _NestedData ( NestedObject ): expression : str equation : _NestedData def __str__ ( self ): \"\"\"Return a string representation of this object.\"\"\" if self . equation is None : return None return self . equation . expression ExternalFile ( FileObject ) pydantic-model An external file object. Source code in notional/types.py class ExternalFile ( FileObject , type = \"external\" ): \"\"\"An external file object.\"\"\" class _NestedData ( NestedObject ): url : str external : _NestedData def __str__ ( self ): \"\"\"Return a string representation of this object.\"\"\" name = self . name or \"__unknown__\" if self . external and self . external . url : return f \"![ { name } ]( { self . external . url } )\" return name @classmethod def __compose__ ( cls , url , name = None ): \"\"\"Create a new `ExternalFile` from the given URL.\"\"\" return cls ( name = name , external = cls . _NestedData ( url = url )) __compose__ ( url , name = None ) classmethod special Create a new ExternalFile from the given URL. Source code in notional/types.py @classmethod def __compose__ ( cls , url , name = None ): \"\"\"Create a new `ExternalFile` from the given URL.\"\"\" return cls ( name = name , external = cls . _NestedData ( url = url )) FileObject ( TypedObject ) pydantic-model A Notion file object. Depending on the context, a FileObject may require a name (such as in the Files property). This makes the object heirarchy difficult, so here we simply allow name to be optional. It is the responsibility of the caller to set name if required by the API. Source code in notional/types.py class FileObject ( TypedObject ): \"\"\"A Notion file object. Depending on the context, a FileObject may require a name (such as in the `Files` property). This makes the object heirarchy difficult, so here we simply allow `name` to be optional. It is the responsibility of the caller to set `name` if required by the API. \"\"\" name : Optional [ str ] = None def __str__ ( self ): \"\"\"Return a string representation of this object.\"\"\" return self . name or \"__unknown__\" __str__ ( self ) special Return a string representation of this object. Source code in notional/types.py def __str__ ( self ): \"\"\"Return a string representation of this object.\"\"\" return self . name or \"__unknown__\" Files ( PropertyValue ) pydantic-model Notion files type. Source code in notional/types.py class Files ( PropertyValue , type = \"files\" ): \"\"\"Notion files type.\"\"\" files : List [ FileObject ] = [] def __contains__ ( self , other ): \"\"\"Determine if the given FileObject or name is in the property.\"\"\" if self . files is None : return False for ref in self . files : if ref == other : return True if ref . name == other : return True return False def __str__ ( self ): \"\"\"Return a string representation of this property.\"\"\" return \"; \" . join ([ str ( file ) for file in self . files ]) def __iter__ ( self ): \"\"\"Iterate over the FileObject's in this property.\"\"\" if self . files is None : return None return iter ( self . files ) def __len__ ( self ): \"\"\"Return the number of Files in this property.\"\"\" return len ( self . files ) def __getitem__ ( self , name ): \"\"\"Return the FileObject with the given name.\"\"\" if self . files is None : return None for ref in self . files : if ref . name == name : return ref raise AttributeError ( \"No such file\" ) def __iadd__ ( self , obj ): \"\"\"Append the given `FileObject` in place.\"\"\" if obj in self : raise ValueError ( f \"Item exists: { obj } \" ) self . append ( obj ) return self def __isub__ ( self , obj ): \"\"\"Remove the given `FileObject` in place.\"\"\" if obj not in self : raise ValueError ( f \"No such item: { obj } \" ) self . remove ( obj ) return self def append ( self , obj ): \"\"\"Append the given file reference to this property. :param ref: the `FileObject` to be added \"\"\" log . debug ( \"append file - %s \" , obj ) self . files . append ( obj ) def remove ( self , obj ): \"\"\"Remove the given file reference from this property. :param ref: the `FileObject` to be removed \"\"\" log . debug ( \"remove file - %s \" , obj ) self . files . remove ( obj ) __contains__ ( self , other ) special Determine if the given FileObject or name is in the property. Source code in notional/types.py def __contains__ ( self , other ): \"\"\"Determine if the given FileObject or name is in the property.\"\"\" if self . files is None : return False for ref in self . files : if ref == other : return True if ref . name == other : return True return False __getitem__ ( self , name ) special Return the FileObject with the given name. Source code in notional/types.py def __getitem__ ( self , name ): \"\"\"Return the FileObject with the given name.\"\"\" if self . files is None : return None for ref in self . files : if ref . name == name : return ref raise AttributeError ( \"No such file\" ) __iadd__ ( self , obj ) special Append the given FileObject in place. Source code in notional/types.py def __iadd__ ( self , obj ): \"\"\"Append the given `FileObject` in place.\"\"\" if obj in self : raise ValueError ( f \"Item exists: { obj } \" ) self . append ( obj ) return self __isub__ ( self , obj ) special Remove the given FileObject in place. Source code in notional/types.py def __isub__ ( self , obj ): \"\"\"Remove the given `FileObject` in place.\"\"\" if obj not in self : raise ValueError ( f \"No such item: { obj } \" ) self . remove ( obj ) return self __iter__ ( self ) special Iterate over the FileObject's in this property. Source code in notional/types.py def __iter__ ( self ): \"\"\"Iterate over the FileObject's in this property.\"\"\" if self . files is None : return None return iter ( self . files ) __len__ ( self ) special Return the number of Files in this property. Source code in notional/types.py def __len__ ( self ): \"\"\"Return the number of Files in this property.\"\"\" return len ( self . files ) __str__ ( self ) special Return a string representation of this property. Source code in notional/types.py def __str__ ( self ): \"\"\"Return a string representation of this property.\"\"\" return \"; \" . join ([ str ( file ) for file in self . files ]) append ( self , obj ) Append the given file reference to this property. :param ref: the FileObject to be added Source code in notional/types.py def append ( self , obj ): \"\"\"Append the given file reference to this property. :param ref: the `FileObject` to be added \"\"\" log . debug ( \"append file - %s \" , obj ) self . files . append ( obj ) remove ( self , obj ) Remove the given file reference from this property. :param ref: the FileObject to be removed Source code in notional/types.py def remove ( self , obj ): \"\"\"Remove the given file reference from this property. :param ref: the `FileObject` to be removed \"\"\" log . debug ( \"remove file - %s \" , obj ) self . files . remove ( obj ) Formula ( PropertyValue ) pydantic-model A Notion formula property value. Source code in notional/types.py class Formula ( PropertyValue , type = \"formula\" ): \"\"\"A Notion formula property value.\"\"\" formula : Optional [ FormulaResult ] = None def __str__ ( self ): \"\"\"Return the result of this formula as a string.\"\"\" return str ( self . Result or \"\" ) @property def Result ( self ): \"\"\"Return the result of this Formula in its native type.\"\"\" if self . formula is None : return None return self . formula . Result Result property readonly Return the result of this Formula in its native type. __str__ ( self ) special Return the result of this formula as a string. Source code in notional/types.py def __str__ ( self ): \"\"\"Return the result of this formula as a string.\"\"\" return str ( self . Result or \"\" ) FormulaResult ( TypedObject ) pydantic-model A Notion formula result. This object contains the result of the expression in the database properties. Source code in notional/types.py class FormulaResult ( TypedObject ): \"\"\"A Notion formula result. This object contains the result of the expression in the database properties. \"\"\" def __str__ ( self ): \"\"\"Return the formula result as a string.\"\"\" return self . Result or \"\" @property def Result ( self ): \"\"\"Return the result of this FormulaResult.\"\"\" raise NotImplementedError ( \"Result unavailable\" ) Result property readonly Return the result of this FormulaResult. __str__ ( self ) special Return the formula result as a string. Source code in notional/types.py def __str__ ( self ): \"\"\"Return the formula result as a string.\"\"\" return self . Result or \"\" HostedFile ( FileObject ) pydantic-model A Notion file object. Source code in notional/types.py class HostedFile ( FileObject , type = \"file\" ): \"\"\"A Notion file object.\"\"\" class _NestedData ( NestedObject ): url : str expiry_time : Optional [ datetime ] = None file : _NestedData LastEditedBy ( PropertyValue ) pydantic-model A Notion last-edited-by property value. Source code in notional/types.py class LastEditedBy ( PropertyValue , type = \"last_edited_by\" ): \"\"\"A Notion last-edited-by property value.\"\"\" last_edited_by : User def __str__ ( self ): \"\"\"Return the contents of this property as a string.\"\"\" return str ( self . last_edited_by ) __str__ ( self ) special Return the contents of this property as a string. Source code in notional/types.py def __str__ ( self ): \"\"\"Return the contents of this property as a string.\"\"\" return str ( self . last_edited_by ) LastEditedTime ( NativeTypeMixin , PropertyValue ) pydantic-model A Notion last-edited-time property value. Source code in notional/types.py class LastEditedTime ( NativeTypeMixin , PropertyValue , type = \"last_edited_time\" ): \"\"\"A Notion last-edited-time property value.\"\"\" last_edited_time : datetime MentionData ( TypedObject ) pydantic-model Base class for typed Mention data objects. Source code in notional/types.py class MentionData ( TypedObject ): \"\"\"Base class for typed `Mention` data objects.\"\"\" MentionDatabase ( MentionData ) pydantic-model Nested database information for Mention properties. Source code in notional/types.py class MentionDatabase ( MentionData , type = \"database\" ): \"\"\"Nested database information for `Mention` properties.\"\"\" database : PageReference MentionDate ( MentionData ) pydantic-model Nested date data for Mention properties. Source code in notional/types.py class MentionDate ( MentionData , type = \"date\" ): \"\"\"Nested date data for `Mention` properties.\"\"\" date : DateRange MentionLink ( MentionData ) pydantic-model Nested url data for Mention properties. Source code in notional/types.py class MentionLink ( MentionData , type = \"link_preview\" ): \"\"\"Nested url data for `Mention` properties.\"\"\" url : str MentionObject ( RichTextObject ) pydantic-model Notion mention element. Source code in notional/types.py class MentionObject ( RichTextObject , type = \"mention\" ): \"\"\"Notion mention element.\"\"\" mention : MentionData MentionPage ( MentionData ) pydantic-model Nested page data for Mention properties. Source code in notional/types.py class MentionPage ( MentionData , type = \"page\" ): \"\"\"Nested page data for `Mention` properties.\"\"\" page : PageReference MentionTemplate ( MentionData ) pydantic-model Nested template data for Mention properties. Source code in notional/types.py class MentionTemplate ( MentionData , type = \"template_mention\" ): \"\"\"Nested template data for `Mention` properties.\"\"\" template_mention : MentionTemplateData MentionTemplateData ( TypedObject ) pydantic-model Nested template data for Mention properties. Source code in notional/types.py class MentionTemplateData ( TypedObject ): \"\"\"Nested template data for `Mention` properties.\"\"\" MentionTemplateDate ( MentionTemplateData ) pydantic-model Nested date template data for Mention properties. Source code in notional/types.py class MentionTemplateDate ( MentionTemplateData , type = \"template_mention_date\" ): \"\"\"Nested date template data for `Mention` properties.\"\"\" template_mention_date : str MentionTemplateUser ( MentionTemplateData ) pydantic-model Nested user template data for Mention properties. Source code in notional/types.py class MentionTemplateUser ( MentionTemplateData , type = \"template_mention_user\" ): \"\"\"Nested user template data for `Mention` properties.\"\"\" template_mention_user : str MentionUser ( MentionData ) pydantic-model Nested user data for Mention properties. Source code in notional/types.py class MentionUser ( MentionData , type = \"user\" ): \"\"\"Nested user data for `Mention` properties.\"\"\" user : User MultiSelect ( PropertyValue ) pydantic-model Notion multi-select type. Source code in notional/types.py class MultiSelect ( PropertyValue , type = \"multi_select\" ): \"\"\"Notion multi-select type.\"\"\" multi_select : List [ SelectValue ] = [] def __str__ ( self ): \"\"\"Return a string representation of this property.\"\"\" return \", \" . join ( self . Values ) def __len__ ( self ): \"\"\"Count the number of selected values.\"\"\" return len ( self . multi_select ) def __getitem__ ( self , index ): \"\"\"Return the SelectValue object at the given index.\"\"\" if self . multi_select is None : raise IndexError ( \"empty property\" ) if index > len ( self . multi_select ): raise IndexError ( \"index out of range\" ) return self . multi_select [ index ] def __iadd__ ( self , other ): \"\"\"Add the given option to this MultiSelect.\"\"\" if other in self : raise ValueError ( f \"Duplicate item: { other } \" ) self . append ( other ) return self def __isub__ ( self , other ): \"\"\"Remove the given value from this MultiSelect.\"\"\" if other not in self : raise ValueError ( f \"No such item: { other } \" ) self . remove ( other ) return self def __contains__ ( self , name ): \"\"\"Determine if the given name is in this MultiSelect. To avoid confusion, only names are considered for comparison, not ID's. \"\"\" for opt in self . multi_select : if opt . name == name : return True return False def __iter__ ( self ): \"\"\"Iterate over the SelectValue's in this property.\"\"\" if self . multi_select is None : return None return iter ( self . multi_select ) @classmethod def __compose__ ( cls , value ): \"\"\"Initialize a new MultiSelect from the given value.\"\"\" if isinstance ( value , list ): return cls . _compose_from_list ( * value ) return cls . _compose_from_list ( value ) def append ( self , * values ): \"\"\"Add selected values to this MultiSelect.\"\"\" for value in values : if value is None : raise ValueError ( \"'None' is an invalid value\" ) if value not in self : opt = SelectValue ( name = value ) self . multi_select . append ( opt ) def remove ( self , * values ): \"\"\"Remove selected values from this MultiSelect.\"\"\" self . multi_select = [ opt for opt in self . multi_select if opt . name not in values ] @property def Values ( self ): \"\"\"Return the names of each value in this MultiSelect as a list.\"\"\" if self . multi_select is None : return None return [ str ( val ) for val in self . multi_select if val . name is not None ] @classmethod def _compose_from_list ( cls , * values ): \"\"\"Create a Select block from a list of values. All values in the list will be automatically converted to strings. \"\"\" select = [] for value in values : if value is None : continue select . append ( SelectValue ( name = str ( value ))) return cls ( multi_select = select ) Values property readonly Return the names of each value in this MultiSelect as a list. __compose__ ( value ) classmethod special Initialize a new MultiSelect from the given value. Source code in notional/types.py @classmethod def __compose__ ( cls , value ): \"\"\"Initialize a new MultiSelect from the given value.\"\"\" if isinstance ( value , list ): return cls . _compose_from_list ( * value ) return cls . _compose_from_list ( value ) __contains__ ( self , name ) special Determine if the given name is in this MultiSelect. To avoid confusion, only names are considered for comparison, not ID's. Source code in notional/types.py def __contains__ ( self , name ): \"\"\"Determine if the given name is in this MultiSelect. To avoid confusion, only names are considered for comparison, not ID's. \"\"\" for opt in self . multi_select : if opt . name == name : return True return False __getitem__ ( self , index ) special Return the SelectValue object at the given index. Source code in notional/types.py def __getitem__ ( self , index ): \"\"\"Return the SelectValue object at the given index.\"\"\" if self . multi_select is None : raise IndexError ( \"empty property\" ) if index > len ( self . multi_select ): raise IndexError ( \"index out of range\" ) return self . multi_select [ index ] __iadd__ ( self , other ) special Add the given option to this MultiSelect. Source code in notional/types.py def __iadd__ ( self , other ): \"\"\"Add the given option to this MultiSelect.\"\"\" if other in self : raise ValueError ( f \"Duplicate item: { other } \" ) self . append ( other ) return self __isub__ ( self , other ) special Remove the given value from this MultiSelect. Source code in notional/types.py def __isub__ ( self , other ): \"\"\"Remove the given value from this MultiSelect.\"\"\" if other not in self : raise ValueError ( f \"No such item: { other } \" ) self . remove ( other ) return self __iter__ ( self ) special Iterate over the SelectValue's in this property. Source code in notional/types.py def __iter__ ( self ): \"\"\"Iterate over the SelectValue's in this property.\"\"\" if self . multi_select is None : return None return iter ( self . multi_select ) __len__ ( self ) special Count the number of selected values. Source code in notional/types.py def __len__ ( self ): \"\"\"Count the number of selected values.\"\"\" return len ( self . multi_select ) __str__ ( self ) special Return a string representation of this property. Source code in notional/types.py def __str__ ( self ): \"\"\"Return a string representation of this property.\"\"\" return \", \" . join ( self . Values ) append ( self , * values ) Add selected values to this MultiSelect. Source code in notional/types.py def append ( self , * values ): \"\"\"Add selected values to this MultiSelect.\"\"\" for value in values : if value is None : raise ValueError ( \"'None' is an invalid value\" ) if value not in self : opt = SelectValue ( name = value ) self . multi_select . append ( opt ) remove ( self , * values ) Remove selected values from this MultiSelect. Source code in notional/types.py def remove ( self , * values ): \"\"\"Remove selected values from this MultiSelect.\"\"\" self . multi_select = [ opt for opt in self . multi_select if opt . name not in values ] NativeTypeMixin Mixin class for properties that can be represented as native Python types. Source code in notional/types.py class NativeTypeMixin : \"\"\"Mixin class for properties that can be represented as native Python types.\"\"\" def __str__ ( self ): \"\"\"Return a string representation of this object.\"\"\" value = self . Value if value is None : return \"\" return str ( value ) def __eq__ ( self , other ): \"\"\"Determine if this property is equal to the given object.\"\"\" return self . Value == other def __ne__ ( self , other ): \"\"\"Determine if this property is not equal to the given object.\"\"\" return self . Value != other @classmethod def __compose__ ( cls , value ): \"\"\"Build the property value from the native Python value.\"\"\" # use type-name field to instantiate the class when possible if hasattr ( cls , \"type\" ): return cls ( ** { cls . type : value }) raise NotImplementedError () @property def Value ( self ): \"\"\"Get the current value of this property as a native Python type.\"\"\" cls = self . __class__ # check to see if the object has a field with the type-name # (this is assigned by TypedObject during subclass creation) if hasattr ( cls , \"type\" ) and hasattr ( self , cls . type ): return getattr ( self , cls . type ) raise NotImplementedError () Value property readonly Get the current value of this property as a native Python type. __compose__ ( value ) classmethod special Build the property value from the native Python value. Source code in notional/types.py @classmethod def __compose__ ( cls , value ): \"\"\"Build the property value from the native Python value.\"\"\" # use type-name field to instantiate the class when possible if hasattr ( cls , \"type\" ): return cls ( ** { cls . type : value }) raise NotImplementedError () __eq__ ( self , other ) special Determine if this property is equal to the given object. Source code in notional/types.py def __eq__ ( self , other ): \"\"\"Determine if this property is equal to the given object.\"\"\" return self . Value == other __ne__ ( self , other ) special Determine if this property is not equal to the given object. Source code in notional/types.py def __ne__ ( self , other ): \"\"\"Determine if this property is not equal to the given object.\"\"\" return self . Value != other __str__ ( self ) special Return a string representation of this object. Source code in notional/types.py def __str__ ( self ): \"\"\"Return a string representation of this object.\"\"\" value = self . Value if value is None : return \"\" return str ( value ) Number ( NativeTypeMixin , PropertyValue ) pydantic-model Simple number type. Source code in notional/types.py class Number ( NativeTypeMixin , PropertyValue , type = \"number\" ): \"\"\"Simple number type.\"\"\" number : Optional [ Union [ float , int ]] = None def __iadd__ ( self , other ): \"\"\"Add the given value to this Number.\"\"\" self . number += other return self def __isub__ ( self , other ): \"\"\"Subtract the given value from this Number.\"\"\" self . number -= other return self @property def Value ( self ): \"\"\"Get the current value of this property as a native Python number.\"\"\" if self . number is None : return None if self . number == int ( self . number ): return int ( self . number ) return self . number Value property readonly Get the current value of this property as a native Python number. __iadd__ ( self , other ) special Add the given value to this Number. Source code in notional/types.py def __iadd__ ( self , other ): \"\"\"Add the given value to this Number.\"\"\" self . number += other return self __isub__ ( self , other ) special Subtract the given value from this Number. Source code in notional/types.py def __isub__ ( self , other ): \"\"\"Subtract the given value from this Number.\"\"\" self . number -= other return self NumberFormula ( FormulaResult ) pydantic-model A Notion number formula result. Source code in notional/types.py class NumberFormula ( FormulaResult , type = \"number\" ): \"\"\"A Notion number formula result.\"\"\" number : Optional [ Union [ float , int ]] = None @property def Result ( self ): \"\"\"Return the result of this NumberFormula.\"\"\" return self . number Result property readonly Return the result of this NumberFormula. PageReference ( DataObject ) pydantic-model A page reference is an object with an id property. Source code in notional/types.py class PageReference ( DataObject ): \"\"\"A page reference is an object with an id property.\"\"\" id : UUID @classmethod def __compose__ ( cls , page ): \"\"\"Return the correct page reference based on the object type.\"\"\" if isinstance ( page , str ): return PageReference ( id = page ) if isinstance ( page , UUID ): return PageReference ( id = page ) if hasattr ( page , \"id\" ): return PageReference ( id = page . id ) raise ValueError ( \"Unrecognized 'page' attribute\" ) __compose__ ( page ) classmethod special Return the correct page reference based on the object type. Source code in notional/types.py @classmethod def __compose__ ( cls , page ): \"\"\"Return the correct page reference based on the object type.\"\"\" if isinstance ( page , str ): return PageReference ( id = page ) if isinstance ( page , UUID ): return PageReference ( id = page ) if hasattr ( page , \"id\" ): return PageReference ( id = page . id ) raise ValueError ( \"Unrecognized 'page' attribute\" ) People ( PropertyValue ) pydantic-model Notion people type. Source code in notional/types.py class People ( PropertyValue , type = \"people\" ): \"\"\"Notion people type.\"\"\" people : List [ User ] = [] def __iter__ ( self ): \"\"\"Iterate over the User's in this property.\"\"\" if self . people is None : return None return iter ( self . people ) def __contains__ ( self , other ): \"\"\"Determine if the given User or name is in this People. To avoid confusion, only names are considered for comparison (not ID's). \"\"\" for user in self . people : if user == other : return True if user . name == other : return True return False def __len__ ( self ): \"\"\"Return the number of People in this property.\"\"\" return len ( self . people ) def __getitem__ ( self , index ): \"\"\"Return the People object at the given index.\"\"\" if self . people is None : raise IndexError ( \"empty property\" ) if index > len ( self . people ): raise IndexError ( \"index out of range\" ) return self . people [ index ] def __str__ ( self ): \"\"\"Return a string representation of this property.\"\"\" return \", \" . join ([ str ( user ) for user in self . people ]) __contains__ ( self , other ) special Determine if the given User or name is in this People. To avoid confusion, only names are considered for comparison (not ID's). Source code in notional/types.py def __contains__ ( self , other ): \"\"\"Determine if the given User or name is in this People. To avoid confusion, only names are considered for comparison (not ID's). \"\"\" for user in self . people : if user == other : return True if user . name == other : return True return False __getitem__ ( self , index ) special Return the People object at the given index. Source code in notional/types.py def __getitem__ ( self , index ): \"\"\"Return the People object at the given index.\"\"\" if self . people is None : raise IndexError ( \"empty property\" ) if index > len ( self . people ): raise IndexError ( \"index out of range\" ) return self . people [ index ] __iter__ ( self ) special Iterate over the User's in this property. Source code in notional/types.py def __iter__ ( self ): \"\"\"Iterate over the User's in this property.\"\"\" if self . people is None : return None return iter ( self . people ) __len__ ( self ) special Return the number of People in this property. Source code in notional/types.py def __len__ ( self ): \"\"\"Return the number of People in this property.\"\"\" return len ( self . people ) __str__ ( self ) special Return a string representation of this property. Source code in notional/types.py def __str__ ( self ): \"\"\"Return a string representation of this property.\"\"\" return \", \" . join ([ str ( user ) for user in self . people ]) PhoneNumber ( NativeTypeMixin , PropertyValue ) pydantic-model Notion phone type. Source code in notional/types.py class PhoneNumber ( NativeTypeMixin , PropertyValue , type = \"phone_number\" ): \"\"\"Notion phone type.\"\"\" phone_number : Optional [ str ] = None PropertyValue ( TypedObject ) pydantic-model Base class for Notion property values. Source code in notional/types.py class PropertyValue ( TypedObject ): \"\"\"Base class for Notion property values.\"\"\" id : Optional [ str ] = None Relation ( PropertyValue ) pydantic-model A Notion relation property value. Source code in notional/types.py class Relation ( PropertyValue , type = \"relation\" ): \"\"\"A Notion relation property value.\"\"\" relation : List [ PageReference ] = [] @classmethod def __compose__ ( cls , pages ): \"\"\"Return a `Relation` property with the specified pages.\"\"\" if isinstance ( pages , list ): refs = [ PageReference [ page ] for page in pages ] else : refs = [ PageReference [ pages ]] return cls ( relation = refs ) def __contains__ ( self , page ): \"\"\"Determine if the given page is in this Relation.\"\"\" return PageReference [ page ] in self . relation def __iter__ ( self ): \"\"\"Iterate over the PageReference's in this property.\"\"\" if self . relation is None : return None return iter ( self . relation ) def __len__ ( self ): \"\"\"Return the number of PageReference's in this property.\"\"\" return len ( self . relation ) def __getitem__ ( self , index ): \"\"\"Return the PageReference object at the given index.\"\"\" if self . relation is None : raise IndexError ( \"empty property\" ) if index > len ( self . relation ): raise IndexError ( \"index out of range\" ) return self . relation [ index ] def __iadd__ ( self , page ): \"\"\"Add the given page to this Relation in place.\"\"\" ref = PageReference [ page ] if ref in self . relation : raise ValueError ( f \"Duplicate item: { ref . id } \" ) self . relation . append ( ref ) return self def __isub__ ( self , page ): \"\"\"Remove the given page from this Relation in place.\"\"\" ref = PageReference [ page ] if ref in self . relation : raise ValueError ( f \"No such item: { ref . id } \" ) self . relation . remove ( ref ) return self __compose__ ( pages ) classmethod special Return a Relation property with the specified pages. Source code in notional/types.py @classmethod def __compose__ ( cls , pages ): \"\"\"Return a `Relation` property with the specified pages.\"\"\" if isinstance ( pages , list ): refs = [ PageReference [ page ] for page in pages ] else : refs = [ PageReference [ pages ]] return cls ( relation = refs ) __contains__ ( self , page ) special Determine if the given page is in this Relation. Source code in notional/types.py def __contains__ ( self , page ): \"\"\"Determine if the given page is in this Relation.\"\"\" return PageReference [ page ] in self . relation __getitem__ ( self , index ) special Return the PageReference object at the given index. Source code in notional/types.py def __getitem__ ( self , index ): \"\"\"Return the PageReference object at the given index.\"\"\" if self . relation is None : raise IndexError ( \"empty property\" ) if index > len ( self . relation ): raise IndexError ( \"index out of range\" ) return self . relation [ index ] __iadd__ ( self , page ) special Add the given page to this Relation in place. Source code in notional/types.py def __iadd__ ( self , page ): \"\"\"Add the given page to this Relation in place.\"\"\" ref = PageReference [ page ] if ref in self . relation : raise ValueError ( f \"Duplicate item: { ref . id } \" ) self . relation . append ( ref ) return self __isub__ ( self , page ) special Remove the given page from this Relation in place. Source code in notional/types.py def __isub__ ( self , page ): \"\"\"Remove the given page from this Relation in place.\"\"\" ref = PageReference [ page ] if ref in self . relation : raise ValueError ( f \"No such item: { ref . id } \" ) self . relation . remove ( ref ) return self __iter__ ( self ) special Iterate over the PageReference's in this property. Source code in notional/types.py def __iter__ ( self ): \"\"\"Iterate over the PageReference's in this property.\"\"\" if self . relation is None : return None return iter ( self . relation ) __len__ ( self ) special Return the number of PageReference's in this property. Source code in notional/types.py def __len__ ( self ): \"\"\"Return the number of PageReference's in this property.\"\"\" return len ( self . relation ) RichText ( NativeTypeMixin , PropertyValue ) pydantic-model Notion rich text type. Source code in notional/types.py class RichText ( NativeTypeMixin , PropertyValue , type = \"rich_text\" ): \"\"\"Notion rich text type.\"\"\" rich_text : List [ RichTextObject ] = [] def __len__ ( self ): \"\"\"Return the number of object in the RichText object.\"\"\" return len ( self . rich_text ) @classmethod def __compose__ ( cls , text ): \"\"\"Create a new `RichText` property from the given strings.\"\"\" return cls ( rich_text = [ TextObject [ text ]]) @property def Value ( self ): \"\"\"Return the plain text from this RichText.\"\"\" if self . rich_text is None : return None return plain_text ( * self . rich_text ) Value property readonly Return the plain text from this RichText. __compose__ ( text ) classmethod special Create a new RichText property from the given strings. Source code in notional/types.py @classmethod def __compose__ ( cls , text ): \"\"\"Create a new `RichText` property from the given strings.\"\"\" return cls ( rich_text = [ TextObject [ text ]]) __len__ ( self ) special Return the number of object in the RichText object. Source code in notional/types.py def __len__ ( self ): \"\"\"Return the number of object in the RichText object.\"\"\" return len ( self . rich_text ) Rollup ( PropertyValue ) pydantic-model A Notion rollup property value. Source code in notional/types.py class Rollup ( PropertyValue , type = \"rollup\" ): \"\"\"A Notion rollup property value.\"\"\" rollup : Optional [ RollupObject ] = None def __str__ ( self ): \"\"\"Return a string representation of this Rollup property.\"\"\" if self . rollup is None : return \"\" value = self . rollup . Value if value is None : return \"\" return str ( value ) __str__ ( self ) special Return a string representation of this Rollup property. Source code in notional/types.py def __str__ ( self ): \"\"\"Return a string representation of this Rollup property.\"\"\" if self . rollup is None : return \"\" value = self . rollup . Value if value is None : return \"\" return str ( value ) RollupArray ( RollupObject ) pydantic-model A Notion rollup array property value. Source code in notional/types.py class RollupArray ( RollupObject , type = \"array\" ): \"\"\"A Notion rollup array property value.\"\"\" array : List [ PropertyValue ] @property def Value ( self ): \"\"\"Return the native representation of this Rollup object.\"\"\" return self . array Value property readonly Return the native representation of this Rollup object. RollupDate ( RollupObject ) pydantic-model A Notion rollup date property value. Source code in notional/types.py class RollupDate ( RollupObject , type = \"date\" ): \"\"\"A Notion rollup date property value.\"\"\" date : Optional [ DateRange ] = None @property def Value ( self ): \"\"\"Return the native representation of this Rollup object.\"\"\" return self . date Value property readonly Return the native representation of this Rollup object. RollupNumber ( RollupObject ) pydantic-model A Notion rollup number property value. Source code in notional/types.py class RollupNumber ( RollupObject , type = \"number\" ): \"\"\"A Notion rollup number property value.\"\"\" number : Optional [ Union [ float , int ]] = None @property def Value ( self ): \"\"\"Return the native representation of this Rollup object.\"\"\" return self . number Value property readonly Return the native representation of this Rollup object. RollupObject ( TypedObject , ABC ) pydantic-model A Notion rollup property value. Source code in notional/types.py class RollupObject ( TypedObject , ABC ): \"\"\"A Notion rollup property value.\"\"\" function : Optional [ Function ] = None @property @abstractmethod def Value ( self ): \"\"\"Return the native representation of this Rollup object.\"\"\" Value property readonly Return the native representation of this Rollup object. SelectOne ( NativeTypeMixin , PropertyValue ) pydantic-model Notion select type. Source code in notional/types.py class SelectOne ( NativeTypeMixin , PropertyValue , type = \"select\" ): \"\"\"Notion select type.\"\"\" select : Optional [ SelectValue ] = None def __str__ ( self ): \"\"\"Return a string representation of this property.\"\"\" return self . Value or \"\" def __eq__ ( self , other ): \"\"\"Determine if this property is equal to the given object. To avoid confusion, this method compares Select options by name. \"\"\" if self . select is None : return other is None return other == self . select . name @classmethod def __compose__ ( cls , value ): \"\"\"Create a `SelectOne` property from the given value. :param value: a string to use for this property \"\"\" if value is None : raise ValueError ( \"'name' cannot be None\" ) return cls ( select = SelectValue ( name = value )) @property def Value ( self ): \"\"\"Return the value of this property as a string.\"\"\" if self . select is None : return None return str ( self . select ) Value property readonly Return the value of this property as a string. __compose__ ( value ) classmethod special Create a SelectOne property from the given value. :param value: a string to use for this property Source code in notional/types.py @classmethod def __compose__ ( cls , value ): \"\"\"Create a `SelectOne` property from the given value. :param value: a string to use for this property \"\"\" if value is None : raise ValueError ( \"'name' cannot be None\" ) return cls ( select = SelectValue ( name = value )) __eq__ ( self , other ) special Determine if this property is equal to the given object. To avoid confusion, this method compares Select options by name. Source code in notional/types.py def __eq__ ( self , other ): \"\"\"Determine if this property is equal to the given object. To avoid confusion, this method compares Select options by name. \"\"\" if self . select is None : return other is None return other == self . select . name __str__ ( self ) special Return a string representation of this property. Source code in notional/types.py def __str__ ( self ): \"\"\"Return a string representation of this property.\"\"\" return self . Value or \"\" SelectValue ( DataObject ) pydantic-model Values for select & multi-select properties. Source code in notional/types.py class SelectValue ( DataObject ): \"\"\"Values for select & multi-select properties.\"\"\" name : str id : Optional [ Union [ UUID , str ]] = None color : Optional [ Color ] = None def __str__ ( self ): \"\"\"Return a string representation of this property.\"\"\" return self . name __str__ ( self ) special Return a string representation of this property. Source code in notional/types.py def __str__ ( self ): \"\"\"Return a string representation of this property.\"\"\" return self . name StringFormula ( FormulaResult ) pydantic-model A Notion string formula result. Source code in notional/types.py class StringFormula ( FormulaResult , type = \"string\" ): \"\"\"A Notion string formula result.\"\"\" string : Optional [ str ] = None @property def Result ( self ): \"\"\"Return the result of this StringFormula.\"\"\" return self . string Result property readonly Return the result of this StringFormula. Title ( NativeTypeMixin , PropertyValue ) pydantic-model Notion title type. Source code in notional/types.py class Title ( NativeTypeMixin , PropertyValue , type = \"title\" ): \"\"\"Notion title type.\"\"\" title : List [ RichTextObject ] = [] def __len__ ( self ): \"\"\"Return the number of object in the Title object.\"\"\" return len ( self . title ) @classmethod def __compose__ ( cls , text ): \"\"\"Create a new `Title` property from the given text.\"\"\" return cls ( title = [ TextObject [ text ]]) @property def Value ( self ): \"\"\"Return the plain text from this Title.\"\"\" if self . title is None : return None return plain_text ( * self . title ) Value property readonly Return the plain text from this Title. __compose__ ( text ) classmethod special Create a new Title property from the given text. Source code in notional/types.py @classmethod def __compose__ ( cls , text ): \"\"\"Create a new `Title` property from the given text.\"\"\" return cls ( title = [ TextObject [ text ]]) __len__ ( self ) special Return the number of object in the Title object. Source code in notional/types.py def __len__ ( self ): \"\"\"Return the number of object in the Title object.\"\"\" return len ( self . title ) URL ( NativeTypeMixin , PropertyValue ) pydantic-model Notion URL type. Source code in notional/types.py class URL ( NativeTypeMixin , PropertyValue , type = \"url\" ): \"\"\"Notion URL type.\"\"\" url : Optional [ str ] = None","title":"Types"},{"location":"reference/types/#notional.types.Checkbox","text":"Simple checkbox type; represented as a boolean. Source code in notional/types.py class Checkbox ( NativeTypeMixin , PropertyValue , type = \"checkbox\" ): \"\"\"Simple checkbox type; represented as a boolean.\"\"\" checkbox : Optional [ bool ] = None","title":"Checkbox"},{"location":"reference/types/#notional.types.CreatedBy","text":"A Notion created-by property value. Source code in notional/types.py class CreatedBy ( PropertyValue , type = \"created_by\" ): \"\"\"A Notion created-by property value.\"\"\" created_by : User def __str__ ( self ): \"\"\"Return the contents of this property as a string.\"\"\" return str ( self . created_by )","title":"CreatedBy"},{"location":"reference/types/#notional.types.CreatedBy.__str__","text":"Return the contents of this property as a string. Source code in notional/types.py def __str__ ( self ): \"\"\"Return the contents of this property as a string.\"\"\" return str ( self . created_by )","title":"__str__()"},{"location":"reference/types/#notional.types.CreatedTime","text":"A Notion created-time property value. Source code in notional/types.py class CreatedTime ( NativeTypeMixin , PropertyValue , type = \"created_time\" ): \"\"\"A Notion created-time property value.\"\"\" created_time : datetime","title":"CreatedTime"},{"location":"reference/types/#notional.types.Date","text":"Notion complex date type - may include timestamp and/or be a date range. Source code in notional/types.py class Date ( PropertyValue , type = \"date\" ): \"\"\"Notion complex date type - may include timestamp and/or be a date range.\"\"\" date : Optional [ DateRange ] = None def __contains__ ( self , other ): \"\"\"Determine if the given date is in the range (inclusive) of this Date. Raises ValueError if the Date object is not a range - e.g. has no end date. \"\"\" if not self . IsRange : raise ValueError ( \"This date is not a range\" ) return self . Start <= other <= self . End def __str__ ( self ): \"\"\"Return a string representation of this property.\"\"\" return \"\" if self . date is None else str ( self . date ) @classmethod def __compose__ ( cls , start , end = None ): \"\"\"Create a new Date from the native values.\"\"\" return cls ( date = DateRange ( start = start , end = end )) @property def IsRange ( self ): \"\"\"Determine if this object represents a date range (versus a single date).\"\"\" if self . date is None : return False return self . date . end is not None @property def Start ( self ): \"\"\"Return the start date of this property.\"\"\" return None if self . date is None else self . date . start @property def End ( self ): \"\"\"Return the end date of this property.\"\"\" return None if self . date is None else self . date . end","title":"Date"},{"location":"reference/types/#notional.types.Date.End","text":"Return the end date of this property.","title":"End"},{"location":"reference/types/#notional.types.Date.IsRange","text":"Determine if this object represents a date range (versus a single date).","title":"IsRange"},{"location":"reference/types/#notional.types.Date.Start","text":"Return the start date of this property.","title":"Start"},{"location":"reference/types/#notional.types.Date.__compose__","text":"Create a new Date from the native values. Source code in notional/types.py @classmethod def __compose__ ( cls , start , end = None ): \"\"\"Create a new Date from the native values.\"\"\" return cls ( date = DateRange ( start = start , end = end ))","title":"__compose__()"},{"location":"reference/types/#notional.types.Date.__contains__","text":"Determine if the given date is in the range (inclusive) of this Date. Raises ValueError if the Date object is not a range - e.g. has no end date. Source code in notional/types.py def __contains__ ( self , other ): \"\"\"Determine if the given date is in the range (inclusive) of this Date. Raises ValueError if the Date object is not a range - e.g. has no end date. \"\"\" if not self . IsRange : raise ValueError ( \"This date is not a range\" ) return self . Start <= other <= self . End","title":"__contains__()"},{"location":"reference/types/#notional.types.Date.__str__","text":"Return a string representation of this property. Source code in notional/types.py def __str__ ( self ): \"\"\"Return a string representation of this property.\"\"\" return \"\" if self . date is None else str ( self . date )","title":"__str__()"},{"location":"reference/types/#notional.types.DateFormula","text":"A Notion date formula result. Source code in notional/types.py class DateFormula ( FormulaResult , type = \"date\" ): \"\"\"A Notion date formula result.\"\"\" date : Optional [ DateRange ] = None @property def Result ( self ): \"\"\"Return the result of this DateFormula.\"\"\" return self . date","title":"DateFormula"},{"location":"reference/types/#notional.types.DateFormula.Result","text":"Return the result of this DateFormula.","title":"Result"},{"location":"reference/types/#notional.types.DateRange","text":"A Notion date range, with an optional end date. Source code in notional/types.py class DateRange ( DataObject ): \"\"\"A Notion date range, with an optional end date.\"\"\" start : Union [ date , datetime ] end : Optional [ Union [ date , datetime ]] = None def __str__ ( self ): \"\"\"Return a string representation of this object.\"\"\" if self . end is None : return f \" { self . start } \" return f \" { self . start } :: { self . end } \"","title":"DateRange"},{"location":"reference/types/#notional.types.DateRange.__str__","text":"Return a string representation of this object. Source code in notional/types.py def __str__ ( self ): \"\"\"Return a string representation of this object.\"\"\" if self . end is None : return f \" { self . start } \" return f \" { self . start } :: { self . end } \"","title":"__str__()"},{"location":"reference/types/#notional.types.Email","text":"Notion email type. Source code in notional/types.py class Email ( NativeTypeMixin , PropertyValue , type = \"email\" ): \"\"\"Notion email type.\"\"\" email : Optional [ str ] = None","title":"Email"},{"location":"reference/types/#notional.types.EmojiObject","text":"A Notion emoji object. Source code in notional/types.py class EmojiObject ( TypedObject , type = \"emoji\" ): \"\"\"A Notion emoji object.\"\"\" emoji : str def __str__ ( self ): \"\"\"Return this EmojiObject as a simple string.\"\"\" return self . emoji @classmethod def __compose__ ( cls , emoji ): \"\"\"Compose an EmojiObject from the given emjoi string.\"\"\" return EmojiObject ( emoji = emoji )","title":"EmojiObject"},{"location":"reference/types/#notional.types.EmojiObject.__compose__","text":"Compose an EmojiObject from the given emjoi string. Source code in notional/types.py @classmethod def __compose__ ( cls , emoji ): \"\"\"Compose an EmojiObject from the given emjoi string.\"\"\" return EmojiObject ( emoji = emoji )","title":"__compose__()"},{"location":"reference/types/#notional.types.EmojiObject.__str__","text":"Return this EmojiObject as a simple string. Source code in notional/types.py def __str__ ( self ): \"\"\"Return this EmojiObject as a simple string.\"\"\" return self . emoji","title":"__str__()"},{"location":"reference/types/#notional.types.EquationObject","text":"Notion equation element. Source code in notional/types.py class EquationObject ( RichTextObject , type = \"equation\" ): \"\"\"Notion equation element.\"\"\" class _NestedData ( NestedObject ): expression : str equation : _NestedData def __str__ ( self ): \"\"\"Return a string representation of this object.\"\"\" if self . equation is None : return None return self . equation . expression","title":"EquationObject"},{"location":"reference/types/#notional.types.ExternalFile","text":"An external file object. Source code in notional/types.py class ExternalFile ( FileObject , type = \"external\" ): \"\"\"An external file object.\"\"\" class _NestedData ( NestedObject ): url : str external : _NestedData def __str__ ( self ): \"\"\"Return a string representation of this object.\"\"\" name = self . name or \"__unknown__\" if self . external and self . external . url : return f \"![ { name } ]( { self . external . url } )\" return name @classmethod def __compose__ ( cls , url , name = None ): \"\"\"Create a new `ExternalFile` from the given URL.\"\"\" return cls ( name = name , external = cls . _NestedData ( url = url ))","title":"ExternalFile"},{"location":"reference/types/#notional.types.ExternalFile.__compose__","text":"Create a new ExternalFile from the given URL. Source code in notional/types.py @classmethod def __compose__ ( cls , url , name = None ): \"\"\"Create a new `ExternalFile` from the given URL.\"\"\" return cls ( name = name , external = cls . _NestedData ( url = url ))","title":"__compose__()"},{"location":"reference/types/#notional.types.FileObject","text":"A Notion file object. Depending on the context, a FileObject may require a name (such as in the Files property). This makes the object heirarchy difficult, so here we simply allow name to be optional. It is the responsibility of the caller to set name if required by the API. Source code in notional/types.py class FileObject ( TypedObject ): \"\"\"A Notion file object. Depending on the context, a FileObject may require a name (such as in the `Files` property). This makes the object heirarchy difficult, so here we simply allow `name` to be optional. It is the responsibility of the caller to set `name` if required by the API. \"\"\" name : Optional [ str ] = None def __str__ ( self ): \"\"\"Return a string representation of this object.\"\"\" return self . name or \"__unknown__\"","title":"FileObject"},{"location":"reference/types/#notional.types.FileObject.__str__","text":"Return a string representation of this object. Source code in notional/types.py def __str__ ( self ): \"\"\"Return a string representation of this object.\"\"\" return self . name or \"__unknown__\"","title":"__str__()"},{"location":"reference/types/#notional.types.Files","text":"Notion files type. Source code in notional/types.py class Files ( PropertyValue , type = \"files\" ): \"\"\"Notion files type.\"\"\" files : List [ FileObject ] = [] def __contains__ ( self , other ): \"\"\"Determine if the given FileObject or name is in the property.\"\"\" if self . files is None : return False for ref in self . files : if ref == other : return True if ref . name == other : return True return False def __str__ ( self ): \"\"\"Return a string representation of this property.\"\"\" return \"; \" . join ([ str ( file ) for file in self . files ]) def __iter__ ( self ): \"\"\"Iterate over the FileObject's in this property.\"\"\" if self . files is None : return None return iter ( self . files ) def __len__ ( self ): \"\"\"Return the number of Files in this property.\"\"\" return len ( self . files ) def __getitem__ ( self , name ): \"\"\"Return the FileObject with the given name.\"\"\" if self . files is None : return None for ref in self . files : if ref . name == name : return ref raise AttributeError ( \"No such file\" ) def __iadd__ ( self , obj ): \"\"\"Append the given `FileObject` in place.\"\"\" if obj in self : raise ValueError ( f \"Item exists: { obj } \" ) self . append ( obj ) return self def __isub__ ( self , obj ): \"\"\"Remove the given `FileObject` in place.\"\"\" if obj not in self : raise ValueError ( f \"No such item: { obj } \" ) self . remove ( obj ) return self def append ( self , obj ): \"\"\"Append the given file reference to this property. :param ref: the `FileObject` to be added \"\"\" log . debug ( \"append file - %s \" , obj ) self . files . append ( obj ) def remove ( self , obj ): \"\"\"Remove the given file reference from this property. :param ref: the `FileObject` to be removed \"\"\" log . debug ( \"remove file - %s \" , obj ) self . files . remove ( obj )","title":"Files"},{"location":"reference/types/#notional.types.Files.__contains__","text":"Determine if the given FileObject or name is in the property. Source code in notional/types.py def __contains__ ( self , other ): \"\"\"Determine if the given FileObject or name is in the property.\"\"\" if self . files is None : return False for ref in self . files : if ref == other : return True if ref . name == other : return True return False","title":"__contains__()"},{"location":"reference/types/#notional.types.Files.__getitem__","text":"Return the FileObject with the given name. Source code in notional/types.py def __getitem__ ( self , name ): \"\"\"Return the FileObject with the given name.\"\"\" if self . files is None : return None for ref in self . files : if ref . name == name : return ref raise AttributeError ( \"No such file\" )","title":"__getitem__()"},{"location":"reference/types/#notional.types.Files.__iadd__","text":"Append the given FileObject in place. Source code in notional/types.py def __iadd__ ( self , obj ): \"\"\"Append the given `FileObject` in place.\"\"\" if obj in self : raise ValueError ( f \"Item exists: { obj } \" ) self . append ( obj ) return self","title":"__iadd__()"},{"location":"reference/types/#notional.types.Files.__isub__","text":"Remove the given FileObject in place. Source code in notional/types.py def __isub__ ( self , obj ): \"\"\"Remove the given `FileObject` in place.\"\"\" if obj not in self : raise ValueError ( f \"No such item: { obj } \" ) self . remove ( obj ) return self","title":"__isub__()"},{"location":"reference/types/#notional.types.Files.__iter__","text":"Iterate over the FileObject's in this property. Source code in notional/types.py def __iter__ ( self ): \"\"\"Iterate over the FileObject's in this property.\"\"\" if self . files is None : return None return iter ( self . files )","title":"__iter__()"},{"location":"reference/types/#notional.types.Files.__len__","text":"Return the number of Files in this property. Source code in notional/types.py def __len__ ( self ): \"\"\"Return the number of Files in this property.\"\"\" return len ( self . files )","title":"__len__()"},{"location":"reference/types/#notional.types.Files.__str__","text":"Return a string representation of this property. Source code in notional/types.py def __str__ ( self ): \"\"\"Return a string representation of this property.\"\"\" return \"; \" . join ([ str ( file ) for file in self . files ])","title":"__str__()"},{"location":"reference/types/#notional.types.Files.append","text":"Append the given file reference to this property. :param ref: the FileObject to be added Source code in notional/types.py def append ( self , obj ): \"\"\"Append the given file reference to this property. :param ref: the `FileObject` to be added \"\"\" log . debug ( \"append file - %s \" , obj ) self . files . append ( obj )","title":"append()"},{"location":"reference/types/#notional.types.Files.remove","text":"Remove the given file reference from this property. :param ref: the FileObject to be removed Source code in notional/types.py def remove ( self , obj ): \"\"\"Remove the given file reference from this property. :param ref: the `FileObject` to be removed \"\"\" log . debug ( \"remove file - %s \" , obj ) self . files . remove ( obj )","title":"remove()"},{"location":"reference/types/#notional.types.Formula","text":"A Notion formula property value. Source code in notional/types.py class Formula ( PropertyValue , type = \"formula\" ): \"\"\"A Notion formula property value.\"\"\" formula : Optional [ FormulaResult ] = None def __str__ ( self ): \"\"\"Return the result of this formula as a string.\"\"\" return str ( self . Result or \"\" ) @property def Result ( self ): \"\"\"Return the result of this Formula in its native type.\"\"\" if self . formula is None : return None return self . formula . Result","title":"Formula"},{"location":"reference/types/#notional.types.Formula.Result","text":"Return the result of this Formula in its native type.","title":"Result"},{"location":"reference/types/#notional.types.Formula.__str__","text":"Return the result of this formula as a string. Source code in notional/types.py def __str__ ( self ): \"\"\"Return the result of this formula as a string.\"\"\" return str ( self . Result or \"\" )","title":"__str__()"},{"location":"reference/types/#notional.types.FormulaResult","text":"A Notion formula result. This object contains the result of the expression in the database properties. Source code in notional/types.py class FormulaResult ( TypedObject ): \"\"\"A Notion formula result. This object contains the result of the expression in the database properties. \"\"\" def __str__ ( self ): \"\"\"Return the formula result as a string.\"\"\" return self . Result or \"\" @property def Result ( self ): \"\"\"Return the result of this FormulaResult.\"\"\" raise NotImplementedError ( \"Result unavailable\" )","title":"FormulaResult"},{"location":"reference/types/#notional.types.FormulaResult.Result","text":"Return the result of this FormulaResult.","title":"Result"},{"location":"reference/types/#notional.types.FormulaResult.__str__","text":"Return the formula result as a string. Source code in notional/types.py def __str__ ( self ): \"\"\"Return the formula result as a string.\"\"\" return self . Result or \"\"","title":"__str__()"},{"location":"reference/types/#notional.types.HostedFile","text":"A Notion file object. Source code in notional/types.py class HostedFile ( FileObject , type = \"file\" ): \"\"\"A Notion file object.\"\"\" class _NestedData ( NestedObject ): url : str expiry_time : Optional [ datetime ] = None file : _NestedData","title":"HostedFile"},{"location":"reference/types/#notional.types.LastEditedBy","text":"A Notion last-edited-by property value. Source code in notional/types.py class LastEditedBy ( PropertyValue , type = \"last_edited_by\" ): \"\"\"A Notion last-edited-by property value.\"\"\" last_edited_by : User def __str__ ( self ): \"\"\"Return the contents of this property as a string.\"\"\" return str ( self . last_edited_by )","title":"LastEditedBy"},{"location":"reference/types/#notional.types.LastEditedBy.__str__","text":"Return the contents of this property as a string. Source code in notional/types.py def __str__ ( self ): \"\"\"Return the contents of this property as a string.\"\"\" return str ( self . last_edited_by )","title":"__str__()"},{"location":"reference/types/#notional.types.LastEditedTime","text":"A Notion last-edited-time property value. Source code in notional/types.py class LastEditedTime ( NativeTypeMixin , PropertyValue , type = \"last_edited_time\" ): \"\"\"A Notion last-edited-time property value.\"\"\" last_edited_time : datetime","title":"LastEditedTime"},{"location":"reference/types/#notional.types.MentionData","text":"Base class for typed Mention data objects. Source code in notional/types.py class MentionData ( TypedObject ): \"\"\"Base class for typed `Mention` data objects.\"\"\"","title":"MentionData"},{"location":"reference/types/#notional.types.MentionDatabase","text":"Nested database information for Mention properties. Source code in notional/types.py class MentionDatabase ( MentionData , type = \"database\" ): \"\"\"Nested database information for `Mention` properties.\"\"\" database : PageReference","title":"MentionDatabase"},{"location":"reference/types/#notional.types.MentionDate","text":"Nested date data for Mention properties. Source code in notional/types.py class MentionDate ( MentionData , type = \"date\" ): \"\"\"Nested date data for `Mention` properties.\"\"\" date : DateRange","title":"MentionDate"},{"location":"reference/types/#notional.types.MentionLink","text":"Nested url data for Mention properties. Source code in notional/types.py class MentionLink ( MentionData , type = \"link_preview\" ): \"\"\"Nested url data for `Mention` properties.\"\"\" url : str","title":"MentionLink"},{"location":"reference/types/#notional.types.MentionObject","text":"Notion mention element. Source code in notional/types.py class MentionObject ( RichTextObject , type = \"mention\" ): \"\"\"Notion mention element.\"\"\" mention : MentionData","title":"MentionObject"},{"location":"reference/types/#notional.types.MentionPage","text":"Nested page data for Mention properties. Source code in notional/types.py class MentionPage ( MentionData , type = \"page\" ): \"\"\"Nested page data for `Mention` properties.\"\"\" page : PageReference","title":"MentionPage"},{"location":"reference/types/#notional.types.MentionTemplate","text":"Nested template data for Mention properties. Source code in notional/types.py class MentionTemplate ( MentionData , type = \"template_mention\" ): \"\"\"Nested template data for `Mention` properties.\"\"\" template_mention : MentionTemplateData","title":"MentionTemplate"},{"location":"reference/types/#notional.types.MentionTemplateData","text":"Nested template data for Mention properties. Source code in notional/types.py class MentionTemplateData ( TypedObject ): \"\"\"Nested template data for `Mention` properties.\"\"\"","title":"MentionTemplateData"},{"location":"reference/types/#notional.types.MentionTemplateDate","text":"Nested date template data for Mention properties. Source code in notional/types.py class MentionTemplateDate ( MentionTemplateData , type = \"template_mention_date\" ): \"\"\"Nested date template data for `Mention` properties.\"\"\" template_mention_date : str","title":"MentionTemplateDate"},{"location":"reference/types/#notional.types.MentionTemplateUser","text":"Nested user template data for Mention properties. Source code in notional/types.py class MentionTemplateUser ( MentionTemplateData , type = \"template_mention_user\" ): \"\"\"Nested user template data for `Mention` properties.\"\"\" template_mention_user : str","title":"MentionTemplateUser"},{"location":"reference/types/#notional.types.MentionUser","text":"Nested user data for Mention properties. Source code in notional/types.py class MentionUser ( MentionData , type = \"user\" ): \"\"\"Nested user data for `Mention` properties.\"\"\" user : User","title":"MentionUser"},{"location":"reference/types/#notional.types.MultiSelect","text":"Notion multi-select type. Source code in notional/types.py class MultiSelect ( PropertyValue , type = \"multi_select\" ): \"\"\"Notion multi-select type.\"\"\" multi_select : List [ SelectValue ] = [] def __str__ ( self ): \"\"\"Return a string representation of this property.\"\"\" return \", \" . join ( self . Values ) def __len__ ( self ): \"\"\"Count the number of selected values.\"\"\" return len ( self . multi_select ) def __getitem__ ( self , index ): \"\"\"Return the SelectValue object at the given index.\"\"\" if self . multi_select is None : raise IndexError ( \"empty property\" ) if index > len ( self . multi_select ): raise IndexError ( \"index out of range\" ) return self . multi_select [ index ] def __iadd__ ( self , other ): \"\"\"Add the given option to this MultiSelect.\"\"\" if other in self : raise ValueError ( f \"Duplicate item: { other } \" ) self . append ( other ) return self def __isub__ ( self , other ): \"\"\"Remove the given value from this MultiSelect.\"\"\" if other not in self : raise ValueError ( f \"No such item: { other } \" ) self . remove ( other ) return self def __contains__ ( self , name ): \"\"\"Determine if the given name is in this MultiSelect. To avoid confusion, only names are considered for comparison, not ID's. \"\"\" for opt in self . multi_select : if opt . name == name : return True return False def __iter__ ( self ): \"\"\"Iterate over the SelectValue's in this property.\"\"\" if self . multi_select is None : return None return iter ( self . multi_select ) @classmethod def __compose__ ( cls , value ): \"\"\"Initialize a new MultiSelect from the given value.\"\"\" if isinstance ( value , list ): return cls . _compose_from_list ( * value ) return cls . _compose_from_list ( value ) def append ( self , * values ): \"\"\"Add selected values to this MultiSelect.\"\"\" for value in values : if value is None : raise ValueError ( \"'None' is an invalid value\" ) if value not in self : opt = SelectValue ( name = value ) self . multi_select . append ( opt ) def remove ( self , * values ): \"\"\"Remove selected values from this MultiSelect.\"\"\" self . multi_select = [ opt for opt in self . multi_select if opt . name not in values ] @property def Values ( self ): \"\"\"Return the names of each value in this MultiSelect as a list.\"\"\" if self . multi_select is None : return None return [ str ( val ) for val in self . multi_select if val . name is not None ] @classmethod def _compose_from_list ( cls , * values ): \"\"\"Create a Select block from a list of values. All values in the list will be automatically converted to strings. \"\"\" select = [] for value in values : if value is None : continue select . append ( SelectValue ( name = str ( value ))) return cls ( multi_select = select )","title":"MultiSelect"},{"location":"reference/types/#notional.types.MultiSelect.Values","text":"Return the names of each value in this MultiSelect as a list.","title":"Values"},{"location":"reference/types/#notional.types.MultiSelect.__compose__","text":"Initialize a new MultiSelect from the given value. Source code in notional/types.py @classmethod def __compose__ ( cls , value ): \"\"\"Initialize a new MultiSelect from the given value.\"\"\" if isinstance ( value , list ): return cls . _compose_from_list ( * value ) return cls . _compose_from_list ( value )","title":"__compose__()"},{"location":"reference/types/#notional.types.MultiSelect.__contains__","text":"Determine if the given name is in this MultiSelect. To avoid confusion, only names are considered for comparison, not ID's. Source code in notional/types.py def __contains__ ( self , name ): \"\"\"Determine if the given name is in this MultiSelect. To avoid confusion, only names are considered for comparison, not ID's. \"\"\" for opt in self . multi_select : if opt . name == name : return True return False","title":"__contains__()"},{"location":"reference/types/#notional.types.MultiSelect.__getitem__","text":"Return the SelectValue object at the given index. Source code in notional/types.py def __getitem__ ( self , index ): \"\"\"Return the SelectValue object at the given index.\"\"\" if self . multi_select is None : raise IndexError ( \"empty property\" ) if index > len ( self . multi_select ): raise IndexError ( \"index out of range\" ) return self . multi_select [ index ]","title":"__getitem__()"},{"location":"reference/types/#notional.types.MultiSelect.__iadd__","text":"Add the given option to this MultiSelect. Source code in notional/types.py def __iadd__ ( self , other ): \"\"\"Add the given option to this MultiSelect.\"\"\" if other in self : raise ValueError ( f \"Duplicate item: { other } \" ) self . append ( other ) return self","title":"__iadd__()"},{"location":"reference/types/#notional.types.MultiSelect.__isub__","text":"Remove the given value from this MultiSelect. Source code in notional/types.py def __isub__ ( self , other ): \"\"\"Remove the given value from this MultiSelect.\"\"\" if other not in self : raise ValueError ( f \"No such item: { other } \" ) self . remove ( other ) return self","title":"__isub__()"},{"location":"reference/types/#notional.types.MultiSelect.__iter__","text":"Iterate over the SelectValue's in this property. Source code in notional/types.py def __iter__ ( self ): \"\"\"Iterate over the SelectValue's in this property.\"\"\" if self . multi_select is None : return None return iter ( self . multi_select )","title":"__iter__()"},{"location":"reference/types/#notional.types.MultiSelect.__len__","text":"Count the number of selected values. Source code in notional/types.py def __len__ ( self ): \"\"\"Count the number of selected values.\"\"\" return len ( self . multi_select )","title":"__len__()"},{"location":"reference/types/#notional.types.MultiSelect.__str__","text":"Return a string representation of this property. Source code in notional/types.py def __str__ ( self ): \"\"\"Return a string representation of this property.\"\"\" return \", \" . join ( self . Values )","title":"__str__()"},{"location":"reference/types/#notional.types.MultiSelect.append","text":"Add selected values to this MultiSelect. Source code in notional/types.py def append ( self , * values ): \"\"\"Add selected values to this MultiSelect.\"\"\" for value in values : if value is None : raise ValueError ( \"'None' is an invalid value\" ) if value not in self : opt = SelectValue ( name = value ) self . multi_select . append ( opt )","title":"append()"},{"location":"reference/types/#notional.types.MultiSelect.remove","text":"Remove selected values from this MultiSelect. Source code in notional/types.py def remove ( self , * values ): \"\"\"Remove selected values from this MultiSelect.\"\"\" self . multi_select = [ opt for opt in self . multi_select if opt . name not in values ]","title":"remove()"},{"location":"reference/types/#notional.types.NativeTypeMixin","text":"Mixin class for properties that can be represented as native Python types. Source code in notional/types.py class NativeTypeMixin : \"\"\"Mixin class for properties that can be represented as native Python types.\"\"\" def __str__ ( self ): \"\"\"Return a string representation of this object.\"\"\" value = self . Value if value is None : return \"\" return str ( value ) def __eq__ ( self , other ): \"\"\"Determine if this property is equal to the given object.\"\"\" return self . Value == other def __ne__ ( self , other ): \"\"\"Determine if this property is not equal to the given object.\"\"\" return self . Value != other @classmethod def __compose__ ( cls , value ): \"\"\"Build the property value from the native Python value.\"\"\" # use type-name field to instantiate the class when possible if hasattr ( cls , \"type\" ): return cls ( ** { cls . type : value }) raise NotImplementedError () @property def Value ( self ): \"\"\"Get the current value of this property as a native Python type.\"\"\" cls = self . __class__ # check to see if the object has a field with the type-name # (this is assigned by TypedObject during subclass creation) if hasattr ( cls , \"type\" ) and hasattr ( self , cls . type ): return getattr ( self , cls . type ) raise NotImplementedError ()","title":"NativeTypeMixin"},{"location":"reference/types/#notional.types.NativeTypeMixin.Value","text":"Get the current value of this property as a native Python type.","title":"Value"},{"location":"reference/types/#notional.types.NativeTypeMixin.__compose__","text":"Build the property value from the native Python value. Source code in notional/types.py @classmethod def __compose__ ( cls , value ): \"\"\"Build the property value from the native Python value.\"\"\" # use type-name field to instantiate the class when possible if hasattr ( cls , \"type\" ): return cls ( ** { cls . type : value }) raise NotImplementedError ()","title":"__compose__()"},{"location":"reference/types/#notional.types.NativeTypeMixin.__eq__","text":"Determine if this property is equal to the given object. Source code in notional/types.py def __eq__ ( self , other ): \"\"\"Determine if this property is equal to the given object.\"\"\" return self . Value == other","title":"__eq__()"},{"location":"reference/types/#notional.types.NativeTypeMixin.__ne__","text":"Determine if this property is not equal to the given object. Source code in notional/types.py def __ne__ ( self , other ): \"\"\"Determine if this property is not equal to the given object.\"\"\" return self . Value != other","title":"__ne__()"},{"location":"reference/types/#notional.types.NativeTypeMixin.__str__","text":"Return a string representation of this object. Source code in notional/types.py def __str__ ( self ): \"\"\"Return a string representation of this object.\"\"\" value = self . Value if value is None : return \"\" return str ( value )","title":"__str__()"},{"location":"reference/types/#notional.types.Number","text":"Simple number type. Source code in notional/types.py class Number ( NativeTypeMixin , PropertyValue , type = \"number\" ): \"\"\"Simple number type.\"\"\" number : Optional [ Union [ float , int ]] = None def __iadd__ ( self , other ): \"\"\"Add the given value to this Number.\"\"\" self . number += other return self def __isub__ ( self , other ): \"\"\"Subtract the given value from this Number.\"\"\" self . number -= other return self @property def Value ( self ): \"\"\"Get the current value of this property as a native Python number.\"\"\" if self . number is None : return None if self . number == int ( self . number ): return int ( self . number ) return self . number","title":"Number"},{"location":"reference/types/#notional.types.Number.Value","text":"Get the current value of this property as a native Python number.","title":"Value"},{"location":"reference/types/#notional.types.Number.__iadd__","text":"Add the given value to this Number. Source code in notional/types.py def __iadd__ ( self , other ): \"\"\"Add the given value to this Number.\"\"\" self . number += other return self","title":"__iadd__()"},{"location":"reference/types/#notional.types.Number.__isub__","text":"Subtract the given value from this Number. Source code in notional/types.py def __isub__ ( self , other ): \"\"\"Subtract the given value from this Number.\"\"\" self . number -= other return self","title":"__isub__()"},{"location":"reference/types/#notional.types.NumberFormula","text":"A Notion number formula result. Source code in notional/types.py class NumberFormula ( FormulaResult , type = \"number\" ): \"\"\"A Notion number formula result.\"\"\" number : Optional [ Union [ float , int ]] = None @property def Result ( self ): \"\"\"Return the result of this NumberFormula.\"\"\" return self . number","title":"NumberFormula"},{"location":"reference/types/#notional.types.NumberFormula.Result","text":"Return the result of this NumberFormula.","title":"Result"},{"location":"reference/types/#notional.types.PageReference","text":"A page reference is an object with an id property. Source code in notional/types.py class PageReference ( DataObject ): \"\"\"A page reference is an object with an id property.\"\"\" id : UUID @classmethod def __compose__ ( cls , page ): \"\"\"Return the correct page reference based on the object type.\"\"\" if isinstance ( page , str ): return PageReference ( id = page ) if isinstance ( page , UUID ): return PageReference ( id = page ) if hasattr ( page , \"id\" ): return PageReference ( id = page . id ) raise ValueError ( \"Unrecognized 'page' attribute\" )","title":"PageReference"},{"location":"reference/types/#notional.types.PageReference.__compose__","text":"Return the correct page reference based on the object type. Source code in notional/types.py @classmethod def __compose__ ( cls , page ): \"\"\"Return the correct page reference based on the object type.\"\"\" if isinstance ( page , str ): return PageReference ( id = page ) if isinstance ( page , UUID ): return PageReference ( id = page ) if hasattr ( page , \"id\" ): return PageReference ( id = page . id ) raise ValueError ( \"Unrecognized 'page' attribute\" )","title":"__compose__()"},{"location":"reference/types/#notional.types.People","text":"Notion people type. Source code in notional/types.py class People ( PropertyValue , type = \"people\" ): \"\"\"Notion people type.\"\"\" people : List [ User ] = [] def __iter__ ( self ): \"\"\"Iterate over the User's in this property.\"\"\" if self . people is None : return None return iter ( self . people ) def __contains__ ( self , other ): \"\"\"Determine if the given User or name is in this People. To avoid confusion, only names are considered for comparison (not ID's). \"\"\" for user in self . people : if user == other : return True if user . name == other : return True return False def __len__ ( self ): \"\"\"Return the number of People in this property.\"\"\" return len ( self . people ) def __getitem__ ( self , index ): \"\"\"Return the People object at the given index.\"\"\" if self . people is None : raise IndexError ( \"empty property\" ) if index > len ( self . people ): raise IndexError ( \"index out of range\" ) return self . people [ index ] def __str__ ( self ): \"\"\"Return a string representation of this property.\"\"\" return \", \" . join ([ str ( user ) for user in self . people ])","title":"People"},{"location":"reference/types/#notional.types.People.__contains__","text":"Determine if the given User or name is in this People. To avoid confusion, only names are considered for comparison (not ID's). Source code in notional/types.py def __contains__ ( self , other ): \"\"\"Determine if the given User or name is in this People. To avoid confusion, only names are considered for comparison (not ID's). \"\"\" for user in self . people : if user == other : return True if user . name == other : return True return False","title":"__contains__()"},{"location":"reference/types/#notional.types.People.__getitem__","text":"Return the People object at the given index. Source code in notional/types.py def __getitem__ ( self , index ): \"\"\"Return the People object at the given index.\"\"\" if self . people is None : raise IndexError ( \"empty property\" ) if index > len ( self . people ): raise IndexError ( \"index out of range\" ) return self . people [ index ]","title":"__getitem__()"},{"location":"reference/types/#notional.types.People.__iter__","text":"Iterate over the User's in this property. Source code in notional/types.py def __iter__ ( self ): \"\"\"Iterate over the User's in this property.\"\"\" if self . people is None : return None return iter ( self . people )","title":"__iter__()"},{"location":"reference/types/#notional.types.People.__len__","text":"Return the number of People in this property. Source code in notional/types.py def __len__ ( self ): \"\"\"Return the number of People in this property.\"\"\" return len ( self . people )","title":"__len__()"},{"location":"reference/types/#notional.types.People.__str__","text":"Return a string representation of this property. Source code in notional/types.py def __str__ ( self ): \"\"\"Return a string representation of this property.\"\"\" return \", \" . join ([ str ( user ) for user in self . people ])","title":"__str__()"},{"location":"reference/types/#notional.types.PhoneNumber","text":"Notion phone type. Source code in notional/types.py class PhoneNumber ( NativeTypeMixin , PropertyValue , type = \"phone_number\" ): \"\"\"Notion phone type.\"\"\" phone_number : Optional [ str ] = None","title":"PhoneNumber"},{"location":"reference/types/#notional.types.PropertyValue","text":"Base class for Notion property values. Source code in notional/types.py class PropertyValue ( TypedObject ): \"\"\"Base class for Notion property values.\"\"\" id : Optional [ str ] = None","title":"PropertyValue"},{"location":"reference/types/#notional.types.Relation","text":"A Notion relation property value. Source code in notional/types.py class Relation ( PropertyValue , type = \"relation\" ): \"\"\"A Notion relation property value.\"\"\" relation : List [ PageReference ] = [] @classmethod def __compose__ ( cls , pages ): \"\"\"Return a `Relation` property with the specified pages.\"\"\" if isinstance ( pages , list ): refs = [ PageReference [ page ] for page in pages ] else : refs = [ PageReference [ pages ]] return cls ( relation = refs ) def __contains__ ( self , page ): \"\"\"Determine if the given page is in this Relation.\"\"\" return PageReference [ page ] in self . relation def __iter__ ( self ): \"\"\"Iterate over the PageReference's in this property.\"\"\" if self . relation is None : return None return iter ( self . relation ) def __len__ ( self ): \"\"\"Return the number of PageReference's in this property.\"\"\" return len ( self . relation ) def __getitem__ ( self , index ): \"\"\"Return the PageReference object at the given index.\"\"\" if self . relation is None : raise IndexError ( \"empty property\" ) if index > len ( self . relation ): raise IndexError ( \"index out of range\" ) return self . relation [ index ] def __iadd__ ( self , page ): \"\"\"Add the given page to this Relation in place.\"\"\" ref = PageReference [ page ] if ref in self . relation : raise ValueError ( f \"Duplicate item: { ref . id } \" ) self . relation . append ( ref ) return self def __isub__ ( self , page ): \"\"\"Remove the given page from this Relation in place.\"\"\" ref = PageReference [ page ] if ref in self . relation : raise ValueError ( f \"No such item: { ref . id } \" ) self . relation . remove ( ref ) return self","title":"Relation"},{"location":"reference/types/#notional.types.Relation.__compose__","text":"Return a Relation property with the specified pages. Source code in notional/types.py @classmethod def __compose__ ( cls , pages ): \"\"\"Return a `Relation` property with the specified pages.\"\"\" if isinstance ( pages , list ): refs = [ PageReference [ page ] for page in pages ] else : refs = [ PageReference [ pages ]] return cls ( relation = refs )","title":"__compose__()"},{"location":"reference/types/#notional.types.Relation.__contains__","text":"Determine if the given page is in this Relation. Source code in notional/types.py def __contains__ ( self , page ): \"\"\"Determine if the given page is in this Relation.\"\"\" return PageReference [ page ] in self . relation","title":"__contains__()"},{"location":"reference/types/#notional.types.Relation.__getitem__","text":"Return the PageReference object at the given index. Source code in notional/types.py def __getitem__ ( self , index ): \"\"\"Return the PageReference object at the given index.\"\"\" if self . relation is None : raise IndexError ( \"empty property\" ) if index > len ( self . relation ): raise IndexError ( \"index out of range\" ) return self . relation [ index ]","title":"__getitem__()"},{"location":"reference/types/#notional.types.Relation.__iadd__","text":"Add the given page to this Relation in place. Source code in notional/types.py def __iadd__ ( self , page ): \"\"\"Add the given page to this Relation in place.\"\"\" ref = PageReference [ page ] if ref in self . relation : raise ValueError ( f \"Duplicate item: { ref . id } \" ) self . relation . append ( ref ) return self","title":"__iadd__()"},{"location":"reference/types/#notional.types.Relation.__isub__","text":"Remove the given page from this Relation in place. Source code in notional/types.py def __isub__ ( self , page ): \"\"\"Remove the given page from this Relation in place.\"\"\" ref = PageReference [ page ] if ref in self . relation : raise ValueError ( f \"No such item: { ref . id } \" ) self . relation . remove ( ref ) return self","title":"__isub__()"},{"location":"reference/types/#notional.types.Relation.__iter__","text":"Iterate over the PageReference's in this property. Source code in notional/types.py def __iter__ ( self ): \"\"\"Iterate over the PageReference's in this property.\"\"\" if self . relation is None : return None return iter ( self . relation )","title":"__iter__()"},{"location":"reference/types/#notional.types.Relation.__len__","text":"Return the number of PageReference's in this property. Source code in notional/types.py def __len__ ( self ): \"\"\"Return the number of PageReference's in this property.\"\"\" return len ( self . relation )","title":"__len__()"},{"location":"reference/types/#notional.types.RichText","text":"Notion rich text type. Source code in notional/types.py class RichText ( NativeTypeMixin , PropertyValue , type = \"rich_text\" ): \"\"\"Notion rich text type.\"\"\" rich_text : List [ RichTextObject ] = [] def __len__ ( self ): \"\"\"Return the number of object in the RichText object.\"\"\" return len ( self . rich_text ) @classmethod def __compose__ ( cls , text ): \"\"\"Create a new `RichText` property from the given strings.\"\"\" return cls ( rich_text = [ TextObject [ text ]]) @property def Value ( self ): \"\"\"Return the plain text from this RichText.\"\"\" if self . rich_text is None : return None return plain_text ( * self . rich_text )","title":"RichText"},{"location":"reference/types/#notional.types.RichText.Value","text":"Return the plain text from this RichText.","title":"Value"},{"location":"reference/types/#notional.types.RichText.__compose__","text":"Create a new RichText property from the given strings. Source code in notional/types.py @classmethod def __compose__ ( cls , text ): \"\"\"Create a new `RichText` property from the given strings.\"\"\" return cls ( rich_text = [ TextObject [ text ]])","title":"__compose__()"},{"location":"reference/types/#notional.types.RichText.__len__","text":"Return the number of object in the RichText object. Source code in notional/types.py def __len__ ( self ): \"\"\"Return the number of object in the RichText object.\"\"\" return len ( self . rich_text )","title":"__len__()"},{"location":"reference/types/#notional.types.Rollup","text":"A Notion rollup property value. Source code in notional/types.py class Rollup ( PropertyValue , type = \"rollup\" ): \"\"\"A Notion rollup property value.\"\"\" rollup : Optional [ RollupObject ] = None def __str__ ( self ): \"\"\"Return a string representation of this Rollup property.\"\"\" if self . rollup is None : return \"\" value = self . rollup . Value if value is None : return \"\" return str ( value )","title":"Rollup"},{"location":"reference/types/#notional.types.Rollup.__str__","text":"Return a string representation of this Rollup property. Source code in notional/types.py def __str__ ( self ): \"\"\"Return a string representation of this Rollup property.\"\"\" if self . rollup is None : return \"\" value = self . rollup . Value if value is None : return \"\" return str ( value )","title":"__str__()"},{"location":"reference/types/#notional.types.RollupArray","text":"A Notion rollup array property value. Source code in notional/types.py class RollupArray ( RollupObject , type = \"array\" ): \"\"\"A Notion rollup array property value.\"\"\" array : List [ PropertyValue ] @property def Value ( self ): \"\"\"Return the native representation of this Rollup object.\"\"\" return self . array","title":"RollupArray"},{"location":"reference/types/#notional.types.RollupArray.Value","text":"Return the native representation of this Rollup object.","title":"Value"},{"location":"reference/types/#notional.types.RollupDate","text":"A Notion rollup date property value. Source code in notional/types.py class RollupDate ( RollupObject , type = \"date\" ): \"\"\"A Notion rollup date property value.\"\"\" date : Optional [ DateRange ] = None @property def Value ( self ): \"\"\"Return the native representation of this Rollup object.\"\"\" return self . date","title":"RollupDate"},{"location":"reference/types/#notional.types.RollupDate.Value","text":"Return the native representation of this Rollup object.","title":"Value"},{"location":"reference/types/#notional.types.RollupNumber","text":"A Notion rollup number property value. Source code in notional/types.py class RollupNumber ( RollupObject , type = \"number\" ): \"\"\"A Notion rollup number property value.\"\"\" number : Optional [ Union [ float , int ]] = None @property def Value ( self ): \"\"\"Return the native representation of this Rollup object.\"\"\" return self . number","title":"RollupNumber"},{"location":"reference/types/#notional.types.RollupNumber.Value","text":"Return the native representation of this Rollup object.","title":"Value"},{"location":"reference/types/#notional.types.RollupObject","text":"A Notion rollup property value. Source code in notional/types.py class RollupObject ( TypedObject , ABC ): \"\"\"A Notion rollup property value.\"\"\" function : Optional [ Function ] = None @property @abstractmethod def Value ( self ): \"\"\"Return the native representation of this Rollup object.\"\"\"","title":"RollupObject"},{"location":"reference/types/#notional.types.RollupObject.Value","text":"Return the native representation of this Rollup object.","title":"Value"},{"location":"reference/types/#notional.types.SelectOne","text":"Notion select type. Source code in notional/types.py class SelectOne ( NativeTypeMixin , PropertyValue , type = \"select\" ): \"\"\"Notion select type.\"\"\" select : Optional [ SelectValue ] = None def __str__ ( self ): \"\"\"Return a string representation of this property.\"\"\" return self . Value or \"\" def __eq__ ( self , other ): \"\"\"Determine if this property is equal to the given object. To avoid confusion, this method compares Select options by name. \"\"\" if self . select is None : return other is None return other == self . select . name @classmethod def __compose__ ( cls , value ): \"\"\"Create a `SelectOne` property from the given value. :param value: a string to use for this property \"\"\" if value is None : raise ValueError ( \"'name' cannot be None\" ) return cls ( select = SelectValue ( name = value )) @property def Value ( self ): \"\"\"Return the value of this property as a string.\"\"\" if self . select is None : return None return str ( self . select )","title":"SelectOne"},{"location":"reference/types/#notional.types.SelectOne.Value","text":"Return the value of this property as a string.","title":"Value"},{"location":"reference/types/#notional.types.SelectOne.__compose__","text":"Create a SelectOne property from the given value. :param value: a string to use for this property Source code in notional/types.py @classmethod def __compose__ ( cls , value ): \"\"\"Create a `SelectOne` property from the given value. :param value: a string to use for this property \"\"\" if value is None : raise ValueError ( \"'name' cannot be None\" ) return cls ( select = SelectValue ( name = value ))","title":"__compose__()"},{"location":"reference/types/#notional.types.SelectOne.__eq__","text":"Determine if this property is equal to the given object. To avoid confusion, this method compares Select options by name. Source code in notional/types.py def __eq__ ( self , other ): \"\"\"Determine if this property is equal to the given object. To avoid confusion, this method compares Select options by name. \"\"\" if self . select is None : return other is None return other == self . select . name","title":"__eq__()"},{"location":"reference/types/#notional.types.SelectOne.__str__","text":"Return a string representation of this property. Source code in notional/types.py def __str__ ( self ): \"\"\"Return a string representation of this property.\"\"\" return self . Value or \"\"","title":"__str__()"},{"location":"reference/types/#notional.types.SelectValue","text":"Values for select & multi-select properties. Source code in notional/types.py class SelectValue ( DataObject ): \"\"\"Values for select & multi-select properties.\"\"\" name : str id : Optional [ Union [ UUID , str ]] = None color : Optional [ Color ] = None def __str__ ( self ): \"\"\"Return a string representation of this property.\"\"\" return self . name","title":"SelectValue"},{"location":"reference/types/#notional.types.SelectValue.__str__","text":"Return a string representation of this property. Source code in notional/types.py def __str__ ( self ): \"\"\"Return a string representation of this property.\"\"\" return self . name","title":"__str__()"},{"location":"reference/types/#notional.types.StringFormula","text":"A Notion string formula result. Source code in notional/types.py class StringFormula ( FormulaResult , type = \"string\" ): \"\"\"A Notion string formula result.\"\"\" string : Optional [ str ] = None @property def Result ( self ): \"\"\"Return the result of this StringFormula.\"\"\" return self . string","title":"StringFormula"},{"location":"reference/types/#notional.types.StringFormula.Result","text":"Return the result of this StringFormula.","title":"Result"},{"location":"reference/types/#notional.types.Title","text":"Notion title type. Source code in notional/types.py class Title ( NativeTypeMixin , PropertyValue , type = \"title\" ): \"\"\"Notion title type.\"\"\" title : List [ RichTextObject ] = [] def __len__ ( self ): \"\"\"Return the number of object in the Title object.\"\"\" return len ( self . title ) @classmethod def __compose__ ( cls , text ): \"\"\"Create a new `Title` property from the given text.\"\"\" return cls ( title = [ TextObject [ text ]]) @property def Value ( self ): \"\"\"Return the plain text from this Title.\"\"\" if self . title is None : return None return plain_text ( * self . title )","title":"Title"},{"location":"reference/types/#notional.types.Title.Value","text":"Return the plain text from this Title.","title":"Value"},{"location":"reference/types/#notional.types.Title.__compose__","text":"Create a new Title property from the given text. Source code in notional/types.py @classmethod def __compose__ ( cls , text ): \"\"\"Create a new `Title` property from the given text.\"\"\" return cls ( title = [ TextObject [ text ]])","title":"__compose__()"},{"location":"reference/types/#notional.types.Title.__len__","text":"Return the number of object in the Title object. Source code in notional/types.py def __len__ ( self ): \"\"\"Return the number of object in the Title object.\"\"\" return len ( self . title )","title":"__len__()"},{"location":"reference/types/#notional.types.URL","text":"Notion URL type. Source code in notional/types.py class URL ( NativeTypeMixin , PropertyValue , type = \"url\" ): \"\"\"Notion URL type.\"\"\" url : Optional [ str ] = None","title":"URL"},{"location":"reference/user/","text":"Wrapper for Notion user objects. Bot ( User ) pydantic-model Represents a Bot in Notion. Source code in notional/user.py class Bot ( User ): \"\"\"Represents a Bot in Notion.\"\"\" class _NestedData ( NestedObject ): pass bot : _NestedData = None def __str__ ( self ): \"\"\"Return a string representation of this `Bot`.\"\"\" return f \"[% { self . name } ]\" __str__ ( self ) special Return a string representation of this Bot . Source code in notional/user.py def __str__ ( self ): \"\"\"Return a string representation of this `Bot`.\"\"\" return f \"[% { self . name } ]\" Person ( User ) pydantic-model Represents a Person in Notion. Source code in notional/user.py class Person ( User ): \"\"\"Represents a Person in Notion.\"\"\" class _NestedData ( NestedObject ): email : str person : _NestedData = None def __str__ ( self ): \"\"\"Return a string representation of this `Person`.\"\"\" return f \"[@ { self . name } ]\" __str__ ( self ) special Return a string representation of this Person . Source code in notional/user.py def __str__ ( self ): \"\"\"Return a string representation of this `Person`.\"\"\" return f \"[@ { self . name } ]\" User ( DataObject ) pydantic-model Represents a User in Notion. Source code in notional/user.py class User ( DataObject ): \"\"\"Represents a User in Notion.\"\"\" # XXX why isn't this a TypedObject ? id : UUID object : str = \"user\" type : Optional [ UserType ] = None name : Optional [ str ] = None avatar_url : Optional [ str ] = None @classmethod def parse_obj ( cls , obj ): \"\"\"Attempt to parse the given object data into the correct `User` type.\"\"\" if obj is None : return None if \"type\" in obj : if obj [ \"type\" ] == \"person\" : return Person ( ** obj ) if obj [ \"type\" ] == \"bot\" : return Bot ( ** obj ) return cls ( obj ) parse_obj ( obj ) classmethod Attempt to parse the given object data into the correct User type. Source code in notional/user.py @classmethod def parse_obj ( cls , obj ): \"\"\"Attempt to parse the given object data into the correct `User` type.\"\"\" if obj is None : return None if \"type\" in obj : if obj [ \"type\" ] == \"person\" : return Person ( ** obj ) if obj [ \"type\" ] == \"bot\" : return Bot ( ** obj ) return cls ( obj ) UserType ( str , Enum ) Available user types. Source code in notional/user.py class UserType ( str , Enum ): \"\"\"Available user types.\"\"\" PERSON = \"person\" BOT = \"bot\"","title":"User"},{"location":"reference/user/#notional.user.Bot","text":"Represents a Bot in Notion. Source code in notional/user.py class Bot ( User ): \"\"\"Represents a Bot in Notion.\"\"\" class _NestedData ( NestedObject ): pass bot : _NestedData = None def __str__ ( self ): \"\"\"Return a string representation of this `Bot`.\"\"\" return f \"[% { self . name } ]\"","title":"Bot"},{"location":"reference/user/#notional.user.Bot.__str__","text":"Return a string representation of this Bot . Source code in notional/user.py def __str__ ( self ): \"\"\"Return a string representation of this `Bot`.\"\"\" return f \"[% { self . name } ]\"","title":"__str__()"},{"location":"reference/user/#notional.user.Person","text":"Represents a Person in Notion. Source code in notional/user.py class Person ( User ): \"\"\"Represents a Person in Notion.\"\"\" class _NestedData ( NestedObject ): email : str person : _NestedData = None def __str__ ( self ): \"\"\"Return a string representation of this `Person`.\"\"\" return f \"[@ { self . name } ]\"","title":"Person"},{"location":"reference/user/#notional.user.Person.__str__","text":"Return a string representation of this Person . Source code in notional/user.py def __str__ ( self ): \"\"\"Return a string representation of this `Person`.\"\"\" return f \"[@ { self . name } ]\"","title":"__str__()"},{"location":"reference/user/#notional.user.User","text":"Represents a User in Notion. Source code in notional/user.py class User ( DataObject ): \"\"\"Represents a User in Notion.\"\"\" # XXX why isn't this a TypedObject ? id : UUID object : str = \"user\" type : Optional [ UserType ] = None name : Optional [ str ] = None avatar_url : Optional [ str ] = None @classmethod def parse_obj ( cls , obj ): \"\"\"Attempt to parse the given object data into the correct `User` type.\"\"\" if obj is None : return None if \"type\" in obj : if obj [ \"type\" ] == \"person\" : return Person ( ** obj ) if obj [ \"type\" ] == \"bot\" : return Bot ( ** obj ) return cls ( obj )","title":"User"},{"location":"reference/user/#notional.user.User.parse_obj","text":"Attempt to parse the given object data into the correct User type. Source code in notional/user.py @classmethod def parse_obj ( cls , obj ): \"\"\"Attempt to parse the given object data into the correct `User` type.\"\"\" if obj is None : return None if \"type\" in obj : if obj [ \"type\" ] == \"person\" : return Person ( ** obj ) if obj [ \"type\" ] == \"bot\" : return Bot ( ** obj ) return cls ( obj )","title":"parse_obj()"},{"location":"reference/user/#notional.user.UserType","text":"Available user types. Source code in notional/user.py class UserType ( str , Enum ): \"\"\"Available user types.\"\"\" PERSON = \"person\" BOT = \"bot\"","title":"UserType"}]}